

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Google 开源项目风格指南</title>
  

  
  
  
  

  

  
  
    

  

  
  

  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="None" href="contents.html#document-index"/> 

  
  <script src="_static/js/modernizr.min.js"></script>


<!-- RTD Extra Head -->

<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="http://zh-google-styleguide.readthedocs.io/en/latest/contents.html" />

<link rel="stylesheet" href="https://media.readthedocs.org/css/readthedocs-doc-embed.css" type="text/css" />

<script type="text/javascript" src="_static/readthedocs-data.js"></script>

<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = 'contents'
</script>

<script type="text/javascript" src="_static/readthedocs-dynamic-include.js"></script>

<!-- end RTD <extrahead> --></head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="contents.html#document-contents" class="icon icon-home"> Google 开源项目风格指南
          

          
          </a>

          
            
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li class="toctree-l1"><a class="reference internal" href="contents.html#document-index">Google 开源项目风格指南 (中文版)</a></li>
<li class="toctree-l1"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/contents">C++ 风格指南 - 内容目录</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/index">0. 扉页</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id2">0.1 译者前言</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id4">0.2 背景</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/headers">1. 头文件</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#self-contained">1.1. Self-contained 头文件</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#define">1.2. #define 保护</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#forward-declarations">1.3. 前置声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#inline-functions">1.4. 内联函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#include">1.5. <code class="docutils literal"><span class="pre">#include</span></code> 的路径及顺序</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#yulefox">译者 (YuleFox) 笔记</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#acgtyrant">译者（acgtyrant）笔记</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/scoping">2. 作用域</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#namespaces">2.1. 命名空间</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#unnamed-namespace-and-static-variables">2.2. 匿名命名空间和静态变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#nonmember-static-member-and-global-functions">2.3. 非成员函数、静态成员函数和全局函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#local-variables">2.4. 局部变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#static-and-global-variables">2.5. 静态和全局变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#yulefox">译者 (YuleFox) 笔记</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#acgtyrant">译者（acgtyrant）笔记</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/classes">3. 类</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id2">3.1. 构造函数的职责</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#implicit-conversions">3.2. 隐式类型转换</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#copyable-and-movable-types">3.3. 可拷贝类型和可移动类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#vs">3.4. 结构体 VS. 类</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#inheritance">3.5. 继承</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#multiple-inheritance">3.6. 多重继承</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#interface">3.7. 接口</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id10">3.8. 运算符重载</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#access-control">3.9. 存取控制</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#declaration-order">3.10. 声明顺序</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#yulefox">译者 (YuleFox) 笔记</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/functions">4. 函数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id2">4.1. 参数顺序</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id3">4.2. 编写简短函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id4">4.3. 引用参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#function-overloading">4.4. 函数重载</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id6">4.5. 缺省参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id7">4.6. 函数返回类型后置语法</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/magic">5. 来自 Google 的奇技</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id1">5.1. 所有权与智能指针</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#cpplint">5.2. Cpplint</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#acgtyrant">译者（acgtyrant）笔记</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/others">5. 其他 C++ 特性</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id1">5.1. 引用参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id2">5.2. 右值引用</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#function-overloading">5.3. 函数重载</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id4">5.4. 缺省参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#alloca">5.5. 变长数组和 alloca()</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id5">5.6. 友元</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#exceptions">5.7. 异常</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#rtti">5.8. 运行时类型识别</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id8">5.9. 类型转换</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#streams">5.10. 流</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id10">5.11. 前置自增和自减</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#const">5.12. <code class="docutils literal"><span class="pre">const</span></code> 用法</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#constexpr">5.13. <code class="docutils literal"><span class="pre">constexpr</span></code> 用法</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id11">5.14. 整型</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id12">5.15. 64 位下的可移植性</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#preprocessor-macros">5.16. 预处理宏</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#nullptr-null">5.17. 0, <code class="docutils literal"><span class="pre">nullptr</span></code> 和 <code class="docutils literal"><span class="pre">NULL</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#sizeof">5.18. sizeof</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#auto">5.19. auto</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#braced-initializer-list">5.20. 列表初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#lambda">5.21. Lambda 表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#template-metaprogramming">5.22. 模板编程</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#boost">5.23. Boost 库</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#c-11">5.24. C++11</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#acgtyrant">译者（acgtyrant）笔记</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/naming">7. 命名约定</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#general-naming-rules">7.1. 通用命名规则</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id3">7.2. 文件命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#type-names">7.3. 类型命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#variable-names">7.4. 变量命名</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id6">普通变量命名</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id7">类数据成员</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id8">结构体变量</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#constant-names">7.5. 常量命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#function-names">7.7. 函数命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id12">7.7. 命名空间命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id13">7.8. 枚举命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#macro-names">7.9. 宏命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id15">7.10. 命名规则的特例</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#acgtyrant">译者（acgtyrant）笔记</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/comments">8. 注释</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id2">8.1. 注释风格</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id3">8.2. 文件注释</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id4">法律公告和作者信息</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id5">文件内容</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#class-comments">8.3. 类注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id7">8.4. 函数注释</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id8">函数声明</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id9">函数定义</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id10">8.5. 变量注释</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id11">类数据成员</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id12">全局变量</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id13">8.6. 实现注释</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id14">代码前注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id15">行注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id16">函数参数注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id17">不允许的行为</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id18">8.8. 标点, 拼写和语法</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#todo">8.8. TODO 注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id19">8.9. 弃用注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#yulefox">译者 (YuleFox) 笔记</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/formatting">9. 格式</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#line-length">9.1. 行长度</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#ascii">9.2. 非 ASCII 字符</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id3">9.3. 空格还是制表位</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id4">9.4. 函数声明与定义</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#lambda">9.5. Lambda 表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#function-calls">9.6. 函数调用</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#braced-initializer-list-format">9.7. 列表初始化格式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id7">9.9. 条件语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id8">9.9. 循环和开关选择语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id9">9.10. 指针和引用表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id10">9.11. 布尔表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id11">9.12. 函数返回值</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id12">9.13. 变量及数组初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id13">9.14. 预处理指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id14">9.15. 类格式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id15">9.16. 构造函数初始值列表</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id16">9.17. 命名空间格式化</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id17">9.19. 水平留白</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id18">通用</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id19">循环和条件语句</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id20">操作符</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id21">模板和转换</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id22">9.19. 垂直留白</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#yulefox">译者 (YuleFox) 笔记</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#acgtyrant">译者（acgtyrant）笔记</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/exceptions">10. 规则特例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id2">10.1. 现有不合规范的代码</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#windows">10.2. Windows 代码</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/end">11. 结束语</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contents.html#document-google-objc-styleguide/contents">Objective-C 风格指南 - 内容目录</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-objc-styleguide/index">Google Objective-C Style Guide 中文版</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id1">译者的话</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#ewanke">ewanke</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id2">Yang.Y</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id3">背景介绍</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id4">例子</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-objc-styleguide/spacing">留白和格式</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#vs">空格 vs. 制表符</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id2">行宽</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id3">方法声明和定义</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id4">方法调用</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#public-private"><code class="docutils literal"><span class="pre">&#64;public</span></code> 和 <code class="docutils literal"><span class="pre">&#64;private</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id5">异常</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id6">协议名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id7">块（闭包）</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-objc-styleguide/naming">命名</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id3">文件名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#objective-c">Objective-C++</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id4">类名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id5">类别名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id6">Objective-C 方法名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id7">变量名</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id8">普通变量名</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id9">实例变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id10">常量</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-objc-styleguide/comments">注释</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id2">文件注释</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id3">版权信息及作者</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id4">声明部分的注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id5">实现部分的注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id6">对象所有权</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-objc-styleguide/features">Cocoa 和 Objective-C 特性</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#private">成员变量应该是 <code class="docutils literal"><span class="pre">&#64;private</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id1">明确指定构造函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id2">重载指定构造函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#nsobject">重载 <code class="docutils literal"><span class="pre">NSObject</span></code> 的方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id3">初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#new">避免 <code class="docutils literal"><span class="pre">+new</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#api">保持公共 API 简单</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#import-and-include"><code class="docutils literal"><span class="pre">#import</span></code> and <code class="docutils literal"><span class="pre">#include</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id5">使用根框架</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#autorelease">构建时即设定 <code class="docutils literal"><span class="pre">autorelease</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#autorelease-retain"><code class="docutils literal"><span class="pre">autorelease</span></code> 优先 <code class="docutils literal"><span class="pre">retain</span></code> 其次</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#init-dealloc"><code class="docutils literal"><span class="pre">init</span></code> 和 <code class="docutils literal"><span class="pre">dealloc</span></code> 内避免使用访问器</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id6">按声明顺序销毁实例变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#setter-nsstrings"><code class="docutils literal"><span class="pre">setter</span></code> 应复制 NSStrings</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#avoid-throwing-exceptions">避免抛异常</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#nil">nil 检查</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#bool">BOOL 若干陷阱</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#property">属性（Property）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id8">命名</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id9">位置</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#copy-attribute">字符串应使用 <code class="docutils literal"><span class="pre">copy</span></code> 属性（Attribute）</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id10">原子性</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#id11">点引用</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id12">没有实例变量的接口</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#synthesize">自动 <code class="docutils literal"><span class="pre">synthesize</span></code> 实例变量</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-objc-styleguide/patterns">Cocoa 模式</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id1">委托模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#mvc">模型/视图/控制器（MVC）</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contents.html#document-google-python-styleguide/contents">Python 风格指南 - 内容目录</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-python-styleguide/index">扉页</a></li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-python-styleguide/background">背景</a></li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-python-styleguide/python_language_rules">Python语言规范</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#lint">Lint</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id1">导入</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id2">包</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id3">异常</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id4">全局变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id5">嵌套/局部/内部类或函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#list-comprehensions">列表推导(List Comprehensions)</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id6">默认迭代器和操作符</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id7">生成器</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#lambda">Lambda函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id8">条件表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id9">默认参数值</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#properties">属性(properties)</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#true-false">True/False的求值</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id11">过时的语言特性</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#lexical-scoping">词法作用域(Lexical Scoping)</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id12">函数与方法装饰器</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id14">线程</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id15">威力过大的特性</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-python-styleguide/python_style_rules">Python风格规范</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id1">分号</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#line-length">行长度</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id4">括号</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#indentation">缩进</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id6">空行</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id7">空格</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#shebang">Shebang</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#comments">注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id11">类</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id12">字符串</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#sockets">文件和sockets</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#todo">TODO注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id13">导入格式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id14">语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id15">访问控制</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id16">命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#main">Main</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-python-styleguide/parting_words">临别赠言</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contents.html#document-google-shell-styleguide/contents">Shell 风格指南 - 内容目录</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/index">扉页</a></li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/background">背景</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#shell">使用哪一种Shell</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id2">什么时候使用Shell</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/shell_files_and_interpreter_invocation">Shell文件和解释器调用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id1">文件扩展名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#suid-sgid">SUID / SGID</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/environment">环境</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#stdout-vs-stderr">STDOUT vs STDERR</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/comments">注释</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id2">文件头</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id3">功能注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id4">实现部分的注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#todo">TODO注释</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/formatting">格式</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id2">缩进</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id3">行的长度和长字符串</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id4">管道</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id5">循环</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#case">case语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id6">变量扩展</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id7">引用</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/features_and_bugs">特性及错误</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id2">命令替换</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#test">test，[和[[</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id3">测试字符串</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id4">文件名的通配符扩展</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#eval">Eval</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#while">管道导向while循环</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/naming_conventions">命名约定</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id2">函数名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id3">变量名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id4">常量和环境变量名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id5">源文件名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id6">只读变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id7">使用本地变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id8">函数位置</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#main">主函数main</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/calling_commands">调用命令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id2">检查返回值</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#id3">内建命令和外部命令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/conclusion">结论</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="contents.html#document-contents">Google 开源项目风格指南</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="contents.html#document-contents">Docs</a> &raquo;</li>
        
      <li>Google 开源项目风格指南</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/zh-google-styleguide/zh-google-styleguide/blob/master/./contents.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="contents">
<span id="id1"></span><h1>内容目录</h1>
<div class="toctree-wrapper compound">
<span id="document-index"></span><div class="section" id="google">
<h2>Google 开源项目风格指南 (中文版)</h2>
<ul class="simple">
<li>在线文档托管在 ReadTheDocs : <a class="reference external" href="http://zh-google-styleguide.readthedocs.org/">在线阅读最新版本</a></li>
<li>中文风格指南 GitHub 托管地址：<a class="reference external" href="https://github.com/zh-google-styleguide/zh-google-styleguide">zh-google-styleguide</a></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>声明.</p>
<p>本项目并非 Google 官方项目, 而是由国内程序员凭热情创建和维护.</p>
<p class="last">如果你关注的是 Google 官方英文版, 请移步 <a class="reference external" href="https://github.com/google/styleguide">Google Style Guide</a></p>
</div>
<p>每个较大的开源项目都有自己的风格指南: 关于如何为该项目编写代码的一系列约定 (有时候会比较武断).
当所有代码均保持一致的风格, 在理解大型代码库时更为轻松.</p>
<p>&#8220;风格&#8221; 的含义涵盖范围广, 从 &#8220;变量使用驼峰格式 (camelCase)&#8221; 到 &#8220;决不使用全局变量&#8221; 再到 &#8220;决不使用异常&#8221;.
英文版项目维护的是在 Google 使用的编程风格指南. 如果你正在修改的项目源自 Google, 你可能会被引导至
英文版项目页面, 以了解项目所使用的风格.</p>
<p>我们已经发布了五份 <strong>中文版</strong> 的风格指南:</p>
<ol class="arabic simple">
<li><a class="reference external" href="http://zh-google-styleguide.readthedocs.org/en/latest/google-cpp-styleguide/">Google C++ 风格指南</a></li>
<li><a class="reference external" href="http://zh-google-styleguide.readthedocs.org/en/latest/google-objc-styleguide/">Google Objective-C 风格指南</a></li>
<li><a class="reference external" href="http://zh-google-styleguide.readthedocs.org/en/latest/google-python-styleguide/">Google Python 风格指南</a></li>
<li><a class="reference external" href="https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md">Google JSON 风格指南</a></li>
<li><a class="reference external" href="http://zh-google-styleguide.readthedocs.org/en/latest/google-shell-styleguide/">Google Shell 风格指南</a></li>
</ol>
<p>中文版项目采用 reStructuredText 纯文本标记语法, 并使用 Sphinx 生成 HTML / CHM / PDF 等文档格式.</p>
<ul class="simple">
<li>英文版项目还包含 <a class="reference external" href="https://github.com/google/styleguide/tree/gh-pages/cpplint">cpplint</a> - 一个用来帮助适应风格准则的工具, 以及 <a class="reference external" href="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">google-c-style.el</a>, Google 风格的 Emacs 配置文件.</li>
<li>另外, 招募志愿者翻译 <a class="reference external" href="http://google.github.io/styleguide/javascriptguide.xml">JavaScript Style Guide</a> 以及 <a class="reference external" href="http://google.github.io/styleguide/xmlstyle.html">XML Document Format Style Guide</a>, 有意者请联系 <a class="reference external" href="https://github.com/yangyubo">Yang.Y</a>.</li>
</ul>
</div>
<span id="document-google-cpp-styleguide/contents"></span><div class="section" id="c">
<span id="cpp-contents"></span><h2>C++ 风格指南 - 内容目录</h2>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#c" id="id1">C++ 风格指南 - 内容目录</a></li>
</ul>
</div>
<div class="toctree-wrapper compound">
<span id="document-google-cpp-styleguide/index"></span><div class="section" id="id1">
<h3>0. 扉页</h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">版本:</th><td class="field-body"><p class="first">4.45</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">原作者:</th><td class="field-body"><div class="first line-block">
<div class="line">Benjy Weinberger</div>
<div class="line">Craig Silverstein</div>
<div class="line">Gregory Eitzmann</div>
<div class="line">Mark Mentovai</div>
<div class="line">Tashana Landray</div>
</div>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">翻译:</th><td class="field-body"><div class="first line-block">
<div class="line"><a class="reference external" href="http://www.yulefox.com">YuleFox</a></div>
<div class="line"><a class="reference external" href="https://github.com/yangyubo">Yang.Y</a></div>
<div class="line"><a class="reference external" href="http://acgtyrant.com">acgtyrant</a></div>
<div class="line"><a class="reference external" href="http://github.com/lilinsanity">lilinsanity</a></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">项目主页:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference external" href="http://google-styleguide.googlecode.com">Google Style Guide</a></li>
<li><a class="reference external" href="http://github.com/zh-google-styleguide/zh-google-styleguide">Google 开源项目风格指南 - 中文版</a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="section" id="id2">
<h4>0.1 译者前言</h4>
<p>Google 经常会发布一些开源项目, 意味着会接受来自其他代码贡献者的代码. 但是如果代码贡献者的编程风格与 Google 的不一致, 会给代码阅读者和其他代码提交者造成不小的困扰. Google 因此发布了这份自己的编程风格指南, 使所有提交代码的人都能获知 Google 的编程风格.</p>
<p>翻译初衷:</p>
<blockquote>
<div><p>规则的作用就是避免混乱. 但规则本身一定要权威, 有说服力, 并且是理性的. 我们所见过的大部分编程规范, 其内容或不够严谨, 或阐述过于简单, 或带有一定的武断性.</p>
<p>Google 保持其一贯的严谨精神, 5 万汉字的指南涉及广泛, 论证严密. 我们翻译该系列指南的主因也正是其严谨性. 严谨意味着指南的价值不仅仅局限于它罗列出的规范, 更具参考意义的是它为了列出规范而做的谨慎权衡过程.</p>
<p>指南不仅列出你要怎么做, 还告诉你为什么要这么做, 哪些情况下可以不这么做, 以及如何权衡其利弊. 其他团队未必要完全遵照指南亦步亦趋, 如前面所说, 这份指南是 Google 根据自身实际情况打造的, 适用于其主导的开源项目. 其他团队可以参照该指南, 或从中汲取灵感, 建立适合自身实际情况的规范.</p>
<p>我们在翻译的过程中, 收获颇多. 希望本系列指南中文版对你同样能有所帮助.</p>
</div></blockquote>
<p>我们翻译时也是尽力保持严谨, 但水平所限, bug 在所难免. 有任何意见或建议, 可与我们取得联系.</p>
<p>中文版和英文版一样, 使用 <code class="docutils literal"><span class="pre">Artistic</span> <span class="pre">License/GPL</span></code> 开源许可.</p>
<p>中文版修订历史:</p>
<blockquote>
<div><ul>
<li><p class="first">2015-08 : 热心的清华大学同学 &#64;lilinsanity 完善了「类」章节以及其它一些小章节。至此，对 Google CPP Style Guide 4.45 的翻译正式竣工。</p>
</li>
<li><p class="first">2015-07 4.45 : acgtyrant 为了学习 C++ 的规范，顺便重新翻译了本 C++ 风格指南，特别是 C++11 的全新内容。排版大幅度优化，翻译措辞更地道，添加了新译者笔记。Google 总部 C++ 工程师 innocentim, 清华大学不愿意透露姓名的唐马儒先生，大阪大学大学院情报科学研究科计算机科学专攻博士 farseerfc 和其它 Arch Linux 中文社区众帮了译者不少忙，谢谢他们。因为 C++ Primer 尚未完全入门，暂时没有翻译「类」章节和其它一些小章节。</p>
</li>
<li><p class="first">2009-06 3.133 : YuleFox 的 1.0 版已经相当完善, 但原版在近一年的时间里, 其规范也发生了一些变化.</p>
<blockquote>
<div><p>Yang.Y 与 YuleFox 一拍即合, 以项目的形式来延续中文版 : <a class="reference external" href="http://github.com/yangyubo/zh-google-styleguide">Google 开源项目风格指南 - 中文版项目</a>.</p>
<p>主要变化是同步到 3.133 最新英文版本, 做部分勘误和改善可读性方面的修改, 并改进排版效果. Yang.Y 重新翻修, YuleFox 做后续评审.</p>
</div></blockquote>
</li>
<li><p class="first">2008-07 1.0 : 出自 <a class="reference external" href="http://www.yulefox.com/?p=207">YuleFox 的 Blog</a>, 很多地方摘录的也是该版本.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id4">
<h4>0.2 背景</h4>
<p>C++ 是 Google 大部分开源项目的主要编程语言. 正如每个 C++ 程序员都知道的, C++ 有很多强大的特性, 但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug, 难以阅读和维护.</p>
<p>本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性. 这些规则在保证代码易于管理的同时, 也能高效使用 C++ 的语言特性.</p>
<p><em>风格</em>, 亦被称作可读性, 也就是指导 C++ 编程的约定. 使用术语 &#8220;风格&#8221; 有些用词不当, 因为这些习惯远不止源代码文件格式化这么简单.</p>
<p>使代码易于管理的方法之一是加强代码一致性. 让任何程序员都可以快速读懂你的代码这点非常重要. 保持统一编程风格并遵守约定意味着可以很容易根据 &#8220;模式匹配&#8221; 规则来推断各种标识符的含义. 创建通用, 必需的习惯用语和模式可以使代码更容易理解. 在一些情况下可能有充分的理由改变某些编程风格, 但我们还是应该遵循一致性原则，尽量不这么做.</p>
<p>本指南的另一个观点是 C++ 特性的臃肿. C++ 是一门包含大量高级特性的庞大语言. 某些情况下, 我们会限制甚至禁止使用某些特性. 这么做是为了保持代码清爽, 避免这些特性可能导致的各种问题. 指南中列举了这类特性, 并解释为什么这些特性被限制使用.</p>
<p>Google 主导的开源项目均符合本指南的规定.</p>
<p>注意: 本指南并非 C++ 教程, 我们假定读者已经对 C++ 非常熟悉.</p>
</div>
</div>
<span id="document-google-cpp-styleguide/headers"></span><div class="section" id="id1">
<h3>1. 头文件</h3>
<p>通常每一个 <code class="docutils literal"><span class="pre">.cc</span></code> 文件都有一个对应的 <code class="docutils literal"><span class="pre">.h</span></code> 文件. 也有一些常见例外, 如单元测试代码和只包含 <code class="docutils literal"><span class="pre">main()</span></code> 函数的 <code class="docutils literal"><span class="pre">.cc</span></code> 文件.</p>
<p>正确使用头文件可令代码在可读性、文件大小和性能上大为改观.</p>
<p>下面的规则将引导你规避使用头文件时的各种陷阱.</p>
<div class="section" id="self-contained">
<span id="self-contained-headers"></span><h4>1.1. Self-contained 头文件</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以 <code class="docutils literal"><span class="pre">.h</span></code> 结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以 <code class="docutils literal"><span class="pre">.inc</span></code> 结尾。不允许分离出 <code class="docutils literal"><span class="pre">-inl.h</span></code> 头文件的做法.</p>
</div>
<p>所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。详言之，一个头文件要有 <a class="reference internal" href="#define-guard"><span class="std std-ref">1.2. #define 保护</span></a>，统统包含它所需要的其它头文件，也不要求定义任何特别 symbols.</p>
<p>不过有一个例外，即一个文件并不是 self-contained 的，而是作为文本插入到代码某处。或者，文件内容实际上是其它头文件的特定平台（platform-specific）扩展部分。这些文件就要用 <code class="docutils literal"><span class="pre">.inc</span></code> 文件扩展名。</p>
<p>如果 <code class="docutils literal"><span class="pre">.h</span></code> 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 <code class="docutils literal"><span class="pre">.cc</span></code> 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。不要把这些定义放到分离的 <code class="docutils literal"><span class="pre">-inl.h</span></code>  文件里（译者注：过去该规范曾提倡把定义放到 -inl.h 里过）。</p>
<p>有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 <code class="docutils literal"><span class="pre">.cc</span></code> 文件里。</p>
</div>
<div class="section" id="define">
<span id="define-guard"></span><h4>1.2. #define 保护</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">所有头文件都应该使用 <code class="docutils literal"><span class="pre">#define</span></code> 来防止头文件被多重包含, 命名格式当是: <code class="docutils literal"><span class="pre">&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</span></code> .</p>
</div>
<p>为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 <code class="docutils literal"><span class="pre">foo</span></code> 中的头文件 <code class="docutils literal"><span class="pre">foo/src/bar/baz.h</span></code> 可按如下方式保护:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#ifndef FOO_BAR_BAZ_H_</span>
<span class="cp">#define FOO_BAR_BAZ_H_</span>
<span class="p">...</span>
<span class="cp">#endif </span><span class="c1">// FOO_BAR_BAZ_H_</span>
</pre></div>
</div>
</div>
<div class="section" id="forward-declarations">
<span id="id2"></span><h4>1.3. 前置声明</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">尽可能地避免使用前置声明。使用 <code class="docutils literal"><span class="pre">#include</span></code> 包含需要的头文件即可。</p>
</div>
<p><strong>定义：</strong></p>
<blockquote>
<div>所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义.</div></blockquote>
<p><strong>优点：</strong></p>
<blockquote>
<div><ul class="simple">
<li>前置声明能够节省编译时间，多余的 <code class="docutils literal"><span class="pre">#include</span></code> 会迫使编译器展开更多的文件，处理更多的输入。</li>
<li>前置声明能够节省不必要的重新编译的时间。 <code class="docutils literal"><span class="pre">#include</span></code> 使代码因为头文件中无关的改动而被重新编译多次。</li>
</ul>
</div></blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<div><ul>
<li><p class="first">前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</p>
</li>
<li><p class="first">前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。</p>
</li>
<li><p class="first">前置声明来自命名空间 <code class="docutils literal"><span class="pre">std::</span></code> 的 symbol 时，其行为未定义。</p>
</li>
<li><p class="first">很难判断什么时候该用前置声明，什么时候该用 <code class="docutils literal"><span class="pre">#include</span></code> 。极端情况下，用前置声明代替 <code class="docutils literal"><span class="pre">includes</span></code> 甚至都会暗暗地改变代码的含义：</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// b.h:</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">D</span> <span class="p">:</span> <span class="n">B</span> <span class="p">{}</span>

<span class="c1">// good_user.cc:</span>
<span class="cp">#include</span> <span class="cpf">&quot;b.h&quot;</span><span class="cp"></span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">B</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="n">D</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="p">}</span>  <span class="c1">// calls f(B*)</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
<blockquote>
<div>如果 <code class="docutils literal"><span class="pre">#include</span></code> 被 <code class="docutils literal"><span class="pre">B</span></code> 和 <code class="docutils literal"><span class="pre">D</span></code> 的前置声明替代， <code class="docutils literal"><span class="pre">test()</span></code> 就会调用 <code class="docutils literal"><span class="pre">f(void*)</span></code> .</div></blockquote>
<ul class="simple">
<li>前置声明了不少来自头文件的 symbol 时，就会比单单一行的 <code class="docutils literal"><span class="pre">include</span></code> 冗长。</li>
<li>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂.</li>
</ul>
</div></blockquote>
<p><strong>结论：</strong></p>
<blockquote>
<div><ul class="simple">
<li>尽量避免前置声明那些定义在其他项目中的实体.</li>
<li>函数：总是使用 <code class="docutils literal"><span class="pre">#include</span></code>.</li>
<li>类模板：优先使用 <code class="docutils literal"><span class="pre">#include</span></code>.</li>
</ul>
</div></blockquote>
<p>至于什么时候包含头文件，参见 <a class="reference internal" href="#name-and-order-of-includes"><span class="std std-ref">1.5. #include 的路径及顺序</span></a> 。</p>
</div>
<div class="section" id="inline-functions">
<span id="id3"></span><h4>1.4. 内联函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p>
</div>
<p><strong>定义:</strong></p>
<blockquote>
<div>当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.</div></blockquote>
<p><strong>优点:</strong></p>
<blockquote>
<div>只要内联的函数体较小, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.</div></blockquote>
<p><strong>缺点:</strong></p>
<blockquote>
<div>滥用内联将导致程序变得更慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。</div></blockquote>
<p><strong>结论:</strong></p>
<blockquote>
<div><p>一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</p>
<p>另一个实用的经验准则: 内联那些包含循环或 <code class="docutils literal"><span class="pre">switch</span></code> 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 <code class="docutils literal"><span class="pre">switch</span></code> 语句从不被执行).</p>
<p>有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联.  通常, 递归函数不应该声明成内联函数.（YuleFox 注: 递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</p>
</div></blockquote>
</div>
<div class="section" id="include">
<span id="name-and-order-of-includes"></span><h4>1.5. <code class="docutils literal"><span class="pre">#include</span></code> 的路径及顺序</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 <cite>.h</cite>, 本项目内的 <cite>.h</cite>.</p>
</div>
<p>项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 <code class="docutils literal"><span class="pre">.</span></code> (当前目录) 或 <code class="docutils literal"><span class="pre">..</span></code> (上级目录). 例如, <code class="docutils literal"><span class="pre">google-awesome-project/src/base/logging.h</span></code> 应该按如下方式包含:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;base/logging.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>又如, <code class="docutils literal"><span class="pre">dir/foo.cc</span></code> 或 <code class="docutils literal"><span class="pre">dir/foo_test.cc</span></code> 的主要作用是实现或测试 <code class="docutils literal"><span class="pre">dir2/foo2.h</span></code> 的功能, <code class="docutils literal"><span class="pre">foo.cc</span></code> 中包含头文件的次序如下:</p>
<blockquote>
<div><ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">dir2/foo2.h</span></code> (优先位置, 详情如下)</li>
<li>C 系统文件</li>
<li>C++ 系统文件</li>
<li>其他库的 <code class="docutils literal"><span class="pre">.h</span></code> 文件</li>
<li>本项目内 <code class="docutils literal"><span class="pre">.h</span></code> 文件</li>
</ol>
</div></blockquote>
<p>这种优先的顺序排序保证当 <code class="docutils literal"><span class="pre">dir2/foo2.h</span></code> 遗漏某些必要的库时， <code class="docutils literal"><span class="pre">dir/foo.cc</span></code> 或 <code class="docutils literal"><span class="pre">dir/foo_test.cc</span></code> 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</p>
<p><code class="docutils literal"><span class="pre">dir/foo.cc</span></code> 和 <code class="docutils literal"><span class="pre">dir2/foo2.h</span></code> 通常位于同一目录下 (如 <code class="docutils literal"><span class="pre">base/basictypes_unittest.cc</span></code> 和 <code class="docutils literal"><span class="pre">base/basictypes.h</span></code>), 但也可以放在不同目录下.</p>
<p>按字母顺序分别对每种类型的头文件进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们。</p>
<p>您所依赖的符号 (symbols) 被哪些头文件所定义，您就应该包含（include）哪些头文件，<a class="reference internal" href="#forward-declarations">前置声明</a> (forward declarations) 情况除外。比如您要用到 <code class="docutils literal"><span class="pre">bar.h</span></code> 中的某个符号, 哪怕您所包含的 <code class="docutils literal"><span class="pre">foo.h</span></code> 已经包含了 <code class="docutils literal"><span class="pre">bar.h</span></code>, 也照样得包含 <code class="docutils literal"><span class="pre">bar.h</span></code>, 除非 <code class="docutils literal"><span class="pre">foo.h</span></code> 有明确说明它会自动向您提供 <code class="docutils literal"><span class="pre">bar.h</span></code> 中的 symbol. 不过，凡是 cc 文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 cc 文件里面了，就像 <code class="docutils literal"><span class="pre">foo.cc</span></code> 只包含 <code class="docutils literal"><span class="pre">foo.h</span></code> 就够了，不用再管后者所包含的其它内容。</p>
<p>举例来说, <code class="docutils literal"><span class="pre">google-awesome-project/src/foo/internal/fooserver.cc</span></code> 的包含次序如下:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;foo/public/fooserver.h&quot; // 优先位置</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;hash_map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;base/basictypes.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;base/commandlineflags.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;foo/public/bar.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
</div></blockquote>
<p><strong>例外：</strong></p>
<p>有时，平台特定（system-specific）代码需要条件编译（conditional includes），这些代码可以放到其它 includes 之后。当然，您的平台特定代码也要够简练且独立，比如：</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;foo/public/fooserver.h&quot;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;base/port.h&quot;  // For LANG_CXX11.</span><span class="cp"></span>

<span class="cp">#ifdef LANG_CXX11</span>
<span class="cp">#include</span> <span class="cpf">&lt;initializer_list&gt;</span><span class="cp"></span>
<span class="cp">#endif  </span><span class="c1">// LANG_CXX11</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="yulefox">
<h4>译者 (YuleFox) 笔记</h4>
<ol class="arabic simple">
<li>避免多重包含是学编程时最基本的要求;</li>
<li>前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应;</li>
<li>内联函数的合理使用可提高代码执行效率;</li>
<li><code class="docutils literal"><span class="pre">-inl.h</span></code> 可提高代码可读性 (一般用不到吧:D);</li>
<li>标准化函数参数顺序可以提高可读性和易维护性 (对函数参数的堆栈空间有轻微影响, 我以前大多是相同类型放在一起);</li>
<li>包含文件的名称使用 <code class="docutils literal"><span class="pre">.</span></code> 和 <code class="docutils literal"><span class="pre">..</span></code> 虽然方便却易混乱, 使用比较完整的项目路径看上去很清晰, 很条理, 包含文件的次序除了美观之外, 最重要的是可以减少隐藏依赖, 使每个头文件在 &#8220;最需要编译&#8221; (对应源文件处 :D) 的地方编译, 有人提出库文件放在最后, 这样出错先是项目内的文件, 头文件都放在对应源文件的最前面, 这一点足以保证内部错误的及时发现了.</li>
</ol>
</div>
<div class="section" id="acgtyrant">
<h4>译者（acgtyrant）笔记</h4>
<ol class="arabic simple">
<li>原来还真有项目用 <code class="docutils literal"><span class="pre">#includes</span></code> 来插入文本，且其文件扩展名 <code class="docutils literal"><span class="pre">.inc</span></code> 看上去也很科学。</li>
<li>Google 已经不再提倡 <code class="docutils literal"><span class="pre">-inl.h</span></code> 用法。</li>
<li>注意，前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。</li>
<li>类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 <code class="docutils literal"><span class="pre">.cc</span></code> 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。</li>
<li>在 <code class="docutils literal"><span class="pre">#include</span></code> 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 <code class="docutils literal"><span class="pre">.h</span></code> 和本项目内的 <code class="docutils literal"><span class="pre">.h</span></code> 是个好习惯。</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/scoping"></span><div class="section" id="id1">
<h3>2. 作用域</h3>
<div class="section" id="namespaces">
<span id="id2"></span><h4>2.1. 命名空间</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">鼓励在 <code class="docutils literal"><span class="pre">.cc</span></code> 文件内使用匿名命名空间或 <code class="docutils literal"><span class="pre">static</span></code> 声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。</p>
</div>
<p><strong>定义:</strong></p>
<blockquote>
<div>命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突.</div></blockquote>
<p><strong>优点:</strong></p>
<blockquote>
<div><p>虽然类已经提供了（可嵌套的）命名轴线 (YuleFox 注: 将命名分割在不同类的作用域内), 命名空间在这基础上又封装了一层.</p>
<p>举例来说, 两个不同项目的全局作用域都有一个类 <code class="docutils literal"><span class="pre">Foo</span></code>, 这样在编译或运行时造成冲突. 如果每个项目将代码置于不同命名空间中, <code class="docutils literal"><span class="pre">project1::Foo</span></code> 和 <code class="docutils literal"><span class="pre">project2::Foo</span></code> 作为不同符号自然不会冲突.</p>
<p>内联命名空间会自动把内部的标识符放到外层作用域，比如：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">X</span> <span class="p">{</span>
<span class="kr">inline</span> <span class="k">namespace</span> <span class="n">Y</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>  <span class="c1">// namespace Y</span>
<span class="p">}</span>  <span class="c1">// namespace X</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">X::Y::foo()</span></code> 与 <code class="docutils literal"><span class="pre">X::foo()</span></code> 彼此可代替。内联命名空间主要用来保持跨版本的 ABI 兼容性。</p>
</div></blockquote>
<p><strong>缺点:</strong></p>
<blockquote>
<div><p>命名空间具有迷惑性, 因为它们使得区分两个相同命名所指代的定义更加困难。</p>
<p>内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。</p>
<p>有时候不得不多次引用某个定义在许多嵌套命名空间里的实体，使用完整的命名空间会导致代码的冗长。</p>
<p>在头文件中使用匿名空间导致违背 C++ 的唯一定义原则 (One Definition Rule (ODR)).</p>
</div></blockquote>
<p><strong>结论:</strong></p>
<blockquote>
<div><p>根据下文将要提到的策略合理使用命名空间.</p>
<ul>
<li><p class="first">遵守 <a class="reference external" href="naming.html#namespace-names">命名空间命名</a> 中的规则。</p>
</li>
<li><p class="first">像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。</p>
</li>
<li><p class="first">用命名空间把文件包含, <a class="reference external" href="https://gflags.github.io/gflags/">gflags</a> 的声明/定义, 以及类的前置声明以外的整个源文件封装起来, 以区别于其它命名空间:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// .h 文件</span>
<span class="k">namespace</span> <span class="n">mynamespace</span> <span class="p">{</span>

<span class="c1">// 所有声明都置于命名空间中</span>
<span class="c1">// 注意不要使用缩进</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="p">...</span>
    <span class="kt">void</span> <span class="n">Foo</span><span class="p">();</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace mynamespace</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// .cc 文件</span>
<span class="k">namespace</span> <span class="n">mynamespace</span> <span class="p">{</span>

<span class="c1">// 函数定义都置于命名空间中</span>
<span class="kt">void</span> <span class="n">MyClass</span><span class="o">::</span><span class="n">Foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace mynamespace</span>
</pre></div>
</div>
<p>更复杂的 <code class="docutils literal"><span class="pre">.cc</span></code> 文件包含更多, 更复杂的细节, 比如 gflags 或 using 声明。</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;a.h&quot;</span><span class="cp"></span>

<span class="n">DEFINE_FLAG</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">someflag</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="s">&quot;dummy flag&quot;</span><span class="p">);</span>

<span class="k">namespace</span> <span class="n">a</span> <span class="p">{</span>

<span class="p">...</span><span class="n">code</span> <span class="k">for</span> <span class="n">a</span><span class="p">...</span>                <span class="c1">// 左对齐</span>

<span class="p">}</span> <span class="c1">// namespace a</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">不要在命名空间 <code class="docutils literal"><span class="pre">std</span></code> 内声明任何东西, 包括标准库的类前置声明. 在 <code class="docutils literal"><span class="pre">std</span></code> 命名空间声明实体是未定义的行为, 会导致如不可移植. 声明标准库下的实体, 需要包含对应的头文件.</p>
</li>
<li><p class="first">不应该使用 <em>using 指示</em> 引入整个命名空间的标识符号。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 禁止 —— 污染命名空间</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">foo</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">不要在头文件中使用 <em>命名空间别名</em> 除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 在 .cc 中使用别名缩短常用的命名空间</span>
<span class="k">namespace</span> <span class="n">baz</span> <span class="o">=</span> <span class="o">::</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="o">::</span><span class="n">baz</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 在 .h 中使用别名缩短常用的命名空间</span>
<span class="k">namespace</span> <span class="n">librarian</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">impl</span> <span class="p">{</span>  <span class="c1">// 仅限内部使用</span>
<span class="k">namespace</span> <span class="n">sidetable</span> <span class="o">=</span> <span class="o">::</span><span class="n">pipeline_diagnostics</span><span class="o">::</span><span class="n">sidetable</span><span class="p">;</span>
<span class="p">}</span>  <span class="c1">// namespace impl</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="n">my_inline_function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 限制在一个函数中的命名空间别名</span>
  <span class="k">namespace</span> <span class="n">baz</span> <span class="o">=</span> <span class="o">::</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="o">::</span><span class="n">baz</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace librarian</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">禁止用内联命名空间</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="unnamed-namespace-and-static-variables">
<span id="id4"></span><h4>2.2. 匿名命名空间和静态变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">在 <code class="docutils literal"><span class="pre">.cc</span></code> 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 <code class="docutils literal"><span class="pre">static</span></code> 。但是不要在 <code class="docutils literal"><span class="pre">.h</span></code> 文件中这么做。</p>
</div>
<p><strong>定义:</strong></p>
<blockquote>
<div>所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为 <code class="docutils literal"><span class="pre">static</span></code> 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</div></blockquote>
<p><strong>结论:</strong></p>
<blockquote>
<div><p>推荐、鼓励在 <code class="docutils literal"><span class="pre">.cc</span></code> 中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在 <code class="docutils literal"><span class="pre">.h</span></code> 中使用。</p>
<p>匿名命名空间的声明和具名的格式相同，在最后注释上 <code class="docutils literal"><span class="pre">namespace</span></code> :</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>  <span class="c1">// namespace</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="nonmember-static-member-and-global-functions">
<span id="id5"></span><h4>2.3. 非成员函数、静态成员函数和全局函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.</p>
</div>
<p><strong>优点:</strong></p>
<blockquote>
<div>某些情况下, 非成员函数和静态成员函数是非常有用的, 将非成员函数放在命名空间内可避免污染全局作用域.</div></blockquote>
<p><strong>缺点:</strong></p>
<blockquote>
<div>将非成员函数和静态成员函数作为新类的成员或许更有意义, 当它们需要访问外部资源或具有重要的依赖关系时更是如此.</div></blockquote>
<p><strong>结论:</strong></p>
<blockquote>
<div><p>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用 <a class="reference internal" href="#namespaces"><span class="std std-ref">2.1. 命名空间</span></a> 。举例而言，对于头文件 <code class="docutils literal"><span class="pre">myproject/foo_bar.h</span></code> , 应当使用</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">myproject</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">foo_bar</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">Function1</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">Function2</span><span class="p">();</span>
<span class="p">}</span>  <span class="c1">// namespace foo_bar</span>
<span class="p">}</span>  <span class="c1">// namespace myproject</span>
</pre></div>
</div>
<p>而非</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">myproject</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">FooBar</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">Function1</span><span class="p">();</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="nf">Function2</span><span class="p">();</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace myproject</span>
</pre></div>
</div>
<p>定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感. 可以考虑提取到新类中, 或者将函数置于独立库的命名空间内.</p>
<p>如果你必须定义非成员函数, 又只是在 <code class="docutils literal"><span class="pre">.cc</span></code> 文件中使用它, 可使用匿名 <a class="reference internal" href="#namespaces"><span class="std std-ref">2.1. 命名空间</span></a> 或 <code class="docutils literal"><span class="pre">static</span></code> 链接关键字 (如 <code class="docutils literal"><span class="pre">static</span> <span class="pre">int</span> <span class="pre">Foo()</span> <span class="pre">{...}</span></code>) 限定其作用域.</p>
</div></blockquote>
</div>
<div class="section" id="local-variables">
<span id="id6"></span><h4>2.4. 局部变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.</p>
</div>
<p>C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值, 比如:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// 坏——初始化和声明分离</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">g</span><span class="p">();</span> <span class="c1">// 好——初始化时声明</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 用花括号初始化更好</span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span> <span class="c1">// 好——v 一开始就初始化</span>
</pre></div>
</div>
</div></blockquote>
<p>属于 <code class="docutils literal"><span class="pre">if</span></code>, <code class="docutils literal"><span class="pre">while</span></code> 和 <code class="docutils literal"><span class="pre">for</span></code> 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">))</span> <span class="n">str</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低.</p>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 低效的实现</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>                  <span class="c1">// 构造函数和析构函数分别调用 1000000 次!</span>
    <span class="n">f</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在循环作用域外面声明这类变量要高效的多:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>                      <span class="c1">// 构造函数和析构函数只调用 1 次</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="static-and-global-variables">
<span id="id7"></span><h4>2.5. 静态和全局变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</p>
</div>
<p>禁止使用类的 <a class="reference external" href="http://zh.cppreference.com/w/cpp/language/storage_duration#.E5.AD.98.E5.82.A8.E6.9C.9F">静态储存周期</a> 变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug 。不过 <code class="docutils literal"><span class="pre">constexpr</span></code> 变量除外，毕竟它们又不涉及动态初始化或析构。</p>
<p>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。</p>
<p>静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug. 所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD 变量，除非该函数（比如 <code class="docutils literal"><span class="pre">getenv()</span></code> 或 <code class="docutils literal"><span class="pre">getpid()</span></code> ）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Xris 译注:</p>
<p class="last">同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为 (unspecified behaviour)。</p>
</div>
<p>同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从 <code class="docutils literal"><span class="pre">main()</span></code> 返回还是对 <code class="docutils literal"><span class="pre">exit()</span></code> 的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态 string 变量也许会在一个引用了前者的其它变量析构之前被析构掉。</p>
<p>改善以上析构问题的办法之一是用 <code class="docutils literal"><span class="pre">quick_exit()</span></code> 来代替 <code class="docutils literal"><span class="pre">exit()</span></code> 并中断程序。它们的不同之处是前者不会执行任何析构，也不会执行 <code class="docutils literal"><span class="pre">atexit()</span></code> 所绑定的任何 handlers. 如果您想在执行 <code class="docutils literal"><span class="pre">quick_exit()</span></code> 来中断时执行某 handler（比如刷新 log），您可以把它绑定到 <code class="docutils literal"><span class="pre">_at_quick_exit()</span></code>. 如果您想在 <code class="docutils literal"><span class="pre">exit()</span></code> 和 <code class="docutils literal"><span class="pre">quick_exit()</span></code> 都用上该 handler, 都绑定上去。</p>
<p>综上所述，我们只允许 POD 类型的静态变量，即完全禁用 <code class="docutils literal"><span class="pre">vector</span></code> (使用 C 数组替代) 和 <code class="docutils literal"><span class="pre">string</span></code> (使用 <code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">[]</span></code>)。</p>
<p>如果您确实需要一个 <code class="docutils literal"><span class="pre">class</span></code> 类型的静态或全局变量，可以考虑在 <code class="docutils literal"><span class="pre">main()</span></code> 函数或 <code class="docutils literal"><span class="pre">pthread_once()</span></code> 内初始化一个指针且永不回收。注意只能用 raw 指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Yang.Y 译注:</p>
<p class="last">上文提及的静态变量泛指静态生存周期的对象, 包括: 全局变量, 静态变量, 静态类成员变量, 以及函数静态变量.</p>
</div>
</div>
<div class="section" id="yulefox">
<h4>译者 (YuleFox) 笔记</h4>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">cc</span></code> 中的匿名命名空间可避免命名冲突, 限定作用域, 避免直接使用 <code class="docutils literal"><span class="pre">using</span></code> 关键字污染命名空间;</li>
<li>嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要 <code class="docutils literal"><span class="pre">public</span></code>;</li>
<li>尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元;</li>
<li>多线程中的全局变量 (含静态成员变量) 不要使用 <code class="docutils literal"><span class="pre">class</span></code> 类型 (含 STL 容器), 避免不明确行为导致的 bug.</li>
<li>作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为降低耦合, 提高编译/执行效率.</li>
</ol>
</div>
<div class="section" id="acgtyrant">
<h4>译者（acgtyrant）笔记</h4>
<ol class="arabic simple">
<li>注意「using 指示（using-directive）」和「using 声明（using-declaration）」的区别。</li>
<li>匿名命名空间说白了就是文件作用域，就像 C static 声明的作用域一样，后者已经被 C++ 标准提倡弃用。</li>
<li>局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。</li>
<li>注意别在循环犯大量构造和析构的低级错误。</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/classes"></span><div class="section" id="id1">
<h3>3. 类</h3>
<p>类是 C++ 中代码的基本单元. 显然, 它们被广泛使用. 本节列举了在写一个类时的主要注意事项.</p>
<div class="section" id="id2">
<h4>3.1. 构造函数的职责</h4>
<p><strong>总述</strong></p>
<p>不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p>
<p><strong>定义</strong></p>
<p>在构造函数中可以进行各种初始化操作.</p>
<p><strong>优点</strong></p>
<ul class="simple">
<li>无需考虑类是否被初始化.</li>
<li>经过构造函数完全初始化后的对象可以为 <code class="docutils literal"><span class="pre">const</span></code> 类型, 也能更方便地被标准容器或算法使用.</li>
</ul>
<p><strong>缺点</strong></p>
<ul class="simple">
<li>如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.</li>
<li>在没有使程序崩溃 (因为并不是一个始终合适的方法) 或者使用异常 (因为已经被 <a class="reference internal" href="contents.html#exceptions"><span class="std std-ref">禁用</span></a> 了) 等方法的条件下, 构造函数很难上报错误</li>
<li>如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态, 必须使用 <code class="docutils literal"><span class="pre">bool</span> <span class="pre">isValid()</span></code> 或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法.</li>
<li>构造函数的地址是无法被取得的, 因此, 举例来说, 由构造函数完成的工作是无法以简单的方式交给其他线程的.</li>
</ul>
<p><strong>结论</strong></p>
<p>构造函数不允许调用虚函数. 如果代码允许, 直接终止程序是一个合适的处理错误的方式. 否则, 考虑用 <code class="docutils literal"><span class="pre">Init()</span></code> 方法或工厂函数.</p>
<p>构造函数不得调用虚函数, 或尝试报告一个非致命错误. 如果对象需要进行有意义的 (non-trivial) 初始化, 考虑使用明确的 Init() 方法或使用工厂模式. Avoid <code class="docutils literal"><span class="pre">Init()</span></code> methods on objects with no other states that affect which public methods may be called (此类形式的半构造对象有时无法正确工作).</p>
</div>
<div class="section" id="implicit-conversions">
<span id="id3"></span><h4>3.2. 隐式类型转换</h4>
<p><strong>总述</strong></p>
<p>不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 <code class="docutils literal"><span class="pre">explicit</span></code> 关键字.</p>
<p><strong>定义</strong></p>
<p>隐式类型转换允许一个某种类型 (称作 <em>源类型</em>) 的对象被用于需要另一种类型 (称作 <em>目的类型</em>) 的位置, 例如, 将一个 <code class="docutils literal"><span class="pre">int</span></code> 类型的参数传递给需要 <code class="docutils literal"><span class="pre">double</span></code> 类型的函数.</p>
<p>除了语言所定义的隐式类型转换, 用户还可以通过在类定义中添加合适的成员定义自己需要的转换. 在源类型中定义隐式类型转换, 可以通过目的类型名的类型转换运算符实现 (例如 <code class="docutils literal"><span class="pre">operator</span> <span class="pre">bool()</span></code>). 在目的类型中定义隐式类型转换, 则通过以源类型作为其唯一参数 (或唯一无默认值的参数) 的构造函数实现.</p>
<p><code class="docutils literal"><span class="pre">explicit</span></code> 关键字可以用于构造函数或 (在 C++11 引入) 类型转换运算符, 以保证只有当目的类型在调用点被显式写明时才能进行类型转换, 例如使用 <code class="docutils literal"><span class="pre">cast</span></code>. 这不仅作用于隐式类型转换, 还能作用于 C++11 的列表初始化语法:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="k">explicit</span> <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Func</span><span class="p">(</span><span class="n">Foo</span> <span class="n">f</span><span class="p">);</span>
</pre></div>
</div>
<p>此时下面的代码是不允许的:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Func</span><span class="p">({</span><span class="mi">42</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">});</span>  <span class="c1">// Error</span>
</pre></div>
</div>
<p>这一代码从技术上说并非隐式类型转换, 但是语言标准认为这是 <code class="docutils literal"><span class="pre">explicit</span></code> 应当限制的行为.</p>
<p><strong>优点</strong></p>
<ul class="simple">
<li>有时目的类型名是一目了然的, 通过避免显式地写出类型名, 隐式类型转换可以让一个类型的可用性和表达性更强.</li>
<li>隐式类型转换可以简单地取代函数重载.</li>
<li>在初始化对象时, 列表初始化语法是一种简洁明了的写法.</li>
</ul>
<p><strong>缺点</strong></p>
<ul class="simple">
<li>隐式类型转换会隐藏类型不匹配的错误. 有时, 目的类型并不符合用户的期望, 甚至用户根本没有意识到发生了类型转换.</li>
<li>隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候, 因为这时很难判断到底是哪个函数被调用.</li>
<li>单参数构造函数有可能会被无意地用作隐式类型转换.</li>
<li>如果单参数构造函数没有加上 <code class="docutils literal"><span class="pre">explicit</span></code> 关键字, 读者无法判断这一函数究竟是要作为隐式类型转换, 还是作者忘了加上 <code class="docutils literal"><span class="pre">explicit</span></code> 标记.</li>
<li>并没有明确的方法用来判断哪个类应该提供类型转换, 这会使得代码变得含糊不清.</li>
<li>如果目的类型是隐式指定的, 那么列表初始化会出现和隐式类型转换一样的问题, 尤其是在列表中只有一个元素的时候.</li>
</ul>
<p><strong>结论</strong></p>
<p>在类型定义中, 类型转换运算符和单参数构造函数都应当用 <code class="docutils literal"><span class="pre">explicit</span></code> 进行标记. 一个例外是, 拷贝和移动构造函数不应当被标记为 <code class="docutils literal"><span class="pre">explicit</span></code>, 因为它们并不执行类型转换. 对于设计目的就是用于对其他类型进行透明包装的类来说, 隐式类型转换有时是必要且合适的. 这时应当联系项目组长并说明特殊情况.</p>
<p>不能以一个参数进行调用的构造函数不应当加上 <code class="docutils literal"><span class="pre">explicit</span></code>. 接受一个 <code class="docutils literal"><span class="pre">std::initializer_list</span></code> 作为参数的构造函数也应当省略 <code class="docutils literal"><span class="pre">explicit</span></code>, 以便支持拷贝初始化 (例如 <code class="docutils literal"><span class="pre">MyType</span> <span class="pre">m</span> <span class="pre">=</span> <span class="pre">{1,</span> <span class="pre">2};)</span></code> .</p>
</div>
<div class="section" id="copyable-and-movable-types">
<span id="id4"></span><h4>3.3. 可拷贝类型和可移动类型</h4>
<p><strong>总述</strong></p>
<p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p>
<p><strong>定义</strong></p>
<p>可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值, 或在赋值时被赋予相同类型的另一对象的值, 同时不改变源对象的值. 对于用户定义的类型, 拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义. <code class="docutils literal"><span class="pre">string</span></code> 类型就是一个可拷贝类型的例子.</p>
<p>可移动类型允许对象在初始化时得到来自相同类型的临时对象的值, 或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的). <code class="docutils literal"><span class="pre">std::unique_ptr&lt;int&gt;</span></code> 就是一个可移动但不可复制的对象的例子. 对于用户定义的类型, 移动操作一般是通过移动构造函数和移动赋值操作符实现的.</p>
<p>拷贝 / 移动构造函数在某些情况下会被编译器隐式调用. 例如, 通过传值的方式传递对象.</p>
<p><strong>优点</strong></p>
<p>可移动及可拷贝类型的对象可以通过传值的方式进行传递或者返回, 这使得 API 更简单, 更安全也更通用. 与传指针和引用不同, 这样的传递不会造成所有权, 生命周期, 可变性等方面的混乱, 也就没必要在协议中予以明确. 这同时也防止了客户端与实现在非作用域内的交互, 使得它们更容易被理解与维护. 这样的对象可以和需要传值操作的通用 API 一起使用, 例如大多数容器.</p>
<p>拷贝 / 移动构造函数与赋值操作一般来说要比它们的各种替代方案, 比如 <code class="docutils literal"><span class="pre">Clone()</span></code>, <code class="docutils literal"><span class="pre">CopyFrom()</span></code> or <code class="docutils literal"><span class="pre">Swap()</span></code>, 更容易定义, 因为它们能通过编译器产生, 无论是隐式的还是通过 <code class="docutils literal"><span class="pre">=</span> <span class="pre">default</span></code>. 这种方式很简洁, 也保证所有数据成员都会被复制. 拷贝与移动构造函数一般也更高效, 因为它们不需要堆的分配或者是单独的初始化和赋值步骤, 同时, 对于类似 <a class="reference external" href="http://en.cppreference.com/w/cpp/language/copy_elision">省略不必要的拷贝</a> 这样的优化它们也更加合适.</p>
<p>移动操作允许隐式且高效地将源数据转移出右值对象. 这有时能让代码风格更加清晰.</p>
<p><strong>缺点</strong></p>
<p>许多类型都不需要拷贝, 为它们提供拷贝操作会让人迷惑, 也显得荒谬而不合理. 单件类型 (<code class="docutils literal"><span class="pre">Registerer</span></code>), 与特定的作用域相关的类型 (<code class="docutils literal"><span class="pre">Cleanup</span></code>), 与其他对象实体紧耦合的类型 (<code class="docutils literal"><span class="pre">Mutex</span></code>) 从逻辑上来说都不应该提供拷贝操作. 为基类提供拷贝 / 赋值操作是有害的, 因为在使用它们时会造成 <a class="reference external" href="https://en.wikipedia.org/wiki/Object_slicing">对象切割</a> . 默认的或者随意的拷贝操作实现可能是不正确的, 这往往导致令人困惑并且难以诊断出的错误.</p>
<p>拷贝构造函数是隐式调用的, 也就是说, 这些调用很容易被忽略. 这会让人迷惑, 尤其是对那些所用的语言约定或强制要求传引用的程序员来说更是如此. 同时, 这从一定程度上说会鼓励过度拷贝, 从而导致性能上的问题.</p>
<p><strong>结论</strong></p>
<p>如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作.</p>
<p>如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的. 记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且/或可移动的.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">Foo</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">field_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">field</span><span class="p">)</span> <span class="p">{}</span>
  <span class="c1">// 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符.</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">Field</span> <span class="n">field_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性, 请提供一个 <code class="docutils literal"><span class="pre">public</span> <span class="pre">virtual</span> <span class="pre">Clone()</span></code> 和一个 <code class="docutils literal"><span class="pre">protected</span></code> 的拷贝构造函数以供派生类实现.</p>
<p>如果你的类不需要拷贝 / 移动操作, 请显式地通过在 <code class="docutils literal"><span class="pre">public</span></code> 域中使用 <code class="docutils literal"><span class="pre">=</span> <span class="pre">delete</span></code> 或其他手段禁用之.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// MyClass is neither copyable nor movable.</span>
<span class="n">MyClass</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="n">MyClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="vs">
<span id="structs-vs-classes"></span><h4>3.4. 结构体 VS. 类</h4>
<p><strong>总述</strong></p>
<p>仅当只有数据成员时使用 <code class="docutils literal"><span class="pre">struct</span></code>, 其它一概使用 <code class="docutils literal"><span class="pre">class</span></code>.</p>
<p><strong>说明</strong></p>
<p>在 C++ 中 <code class="docutils literal"><span class="pre">struct</span></code> 和 <code class="docutils literal"><span class="pre">class</span></code> 关键字几乎含义一样. 我们为这两个关键字添加我们自己的语义理解, 以便为定义的数据类型选择合适的关键字.</p>
<p><code class="docutils literal"><span class="pre">struct</span></code> 用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能. 并且存取功能是通过直接访问位域, 而非函数调用. 除了构造函数, 析构函数, <code class="docutils literal"><span class="pre">Initialize()</span></code>, <code class="docutils literal"><span class="pre">Reset()</span></code>, <code class="docutils literal"><span class="pre">Validate()</span></code> 等类似的用于设定数据成员的函数外, 不能提供其它功能的函数.</p>
<p>如果需要更多的函数功能, <code class="docutils literal"><span class="pre">class</span></code> 更适合. 如果拿不准, 就用 <code class="docutils literal"><span class="pre">class</span></code>.</p>
<p>为了和 STL 保持一致, 对于仿函数等特性可以不用 <code class="docutils literal"><span class="pre">class</span></code> 而是使用 <code class="docutils literal"><span class="pre">struct</span></code>.</p>
<p>注意: 类和结构体的成员变量使用不同的 <a class="reference internal" href="contents.html#variable-names"><span class="std std-ref">命名规则</span></a>.</p>
</div>
<div class="section" id="inheritance">
<span id="id7"></span><h4>3.5. 继承</h4>
<p><strong>总述</strong></p>
<p>使用组合 (YuleFox 注: 这一点也是 GoF 在 &lt;&lt;Design Patterns&gt;&gt; 里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为 <code class="docutils literal"><span class="pre">public</span></code> 继承.</p>
<p><strong>定义</strong></p>
<p>当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承, 子类继承父类的实现代码; <a class="reference internal" href="#interface"><span class="std std-ref">接口继承</span></a>, 子类仅继承父类的方法名称.</p>
<p><strong>优点</strong></p>
<p>实现继承通过原封不动的复用基类代码减少了代码量. 由于继承是在编译时声明, 程序员和编译器都可以理解相应操作并发现错误. 从编程角度而言, 接口继承是用来强制类输出特定的 API. 在类没有实现 API 中某个必须的方法时, 编译器同样会发现并报告错误.</p>
<p><strong>缺点</strong></p>
<p>对于实现继承, 由于子类的实现代码散布在父类和子类间之间, 要理解其实现变得更加困难. 子类不能重写父类的非虚函数, 当然也就不能修改其实现. 基类也可能定义了一些数据成员, 因此还必须区分基类的实际布局.</p>
<p><strong>结论</strong></p>
<p>所有继承必须是 <code class="docutils literal"><span class="pre">public</span></code> 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.</p>
<p>不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 &#8220;是一个&#8221; (&#8220;is-a&#8221;, YuleFox 注: 其他 &#8220;has-a&#8221; 情况下请使用组合) 的情况下使用继承: 如果 <code class="docutils literal"><span class="pre">Bar</span></code> 的确 &#8220;是一种&#8221; <code class="docutils literal"><span class="pre">Foo</span></code>, <code class="docutils literal"><span class="pre">Bar</span></code> 才能继承 <code class="docutils literal"><span class="pre">Foo</span></code>.</p>
<p>必要的话, 析构函数声明为 <code class="docutils literal"><span class="pre">virtual</span></code>. 如果你的类有虚函数, 则析构函数也应该为虚函数.</p>
<p>对于可能被子类访问的成员函数, 不要过度使用 <code class="docutils literal"><span class="pre">protected</span></code> 关键字. 注意, 数据成员都必须是 <a class="reference internal" href="#access-control"><span class="std std-ref">私有的</span></a>.</p>
<p>对于重载的虚函数或虚析构函数, 使用 <code class="docutils literal"><span class="pre">override</span></code>, 或 (较不常用的) <code class="docutils literal"><span class="pre">final</span></code> 关键字显式地进行标记. 较早 (早于 C++11) 的代码可能会使用 <code class="docutils literal"><span class="pre">virtual</span></code> 关键字作为不得已的选项. 因此, 在声明重载时, 请使用 <code class="docutils literal"><span class="pre">override</span></code>, <code class="docutils literal"><span class="pre">final</span></code> 或 <code class="docutils literal"><span class="pre">virtual</span></code> 的其中之一进行标记. 标记为 <code class="docutils literal"><span class="pre">override</span></code> 或 <code class="docutils literal"><span class="pre">final</span></code> 的析构函数如果不是对基类虚函数的重载的话, 编译会报错, 这有助于捕获常见的错误. 这些标记起到了文档的作用, 因为如果省略这些关键字, 代码阅读者不得不检查所有父类, 以判断该函数是否是虚函数.</p>
</div>
<div class="section" id="multiple-inheritance">
<span id="id8"></span><h4>3.6. 多重继承</h4>
<p><strong>总述</strong></p>
<p>真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 <code class="docutils literal"><span class="pre">Interface</span></code> 为后缀的 <a class="reference internal" href="#interface"><span class="std std-ref">纯接口类</span></a>.</p>
<p><strong>定义</strong></p>
<p>多重继承允许子类拥有多个基类. 要将作为 <em>纯接口</em> 的基类和具有 <em>实现</em> 的基类区别开来.</p>
<p><strong>优点</strong></p>
<p>相比单继承 (见 <a class="reference internal" href="#inheritance"><span class="std std-ref">继承</span></a>), 多重实现继承可以复用更多的代码.</p>
<p><strong>缺点</strong></p>
<p>真正需要用到多重 <em>实现</em> 继承的情况少之又少. 有时多重实现继承看上去是不错的解决方案, 但这时你通常也可以找到一个更明确, 更清晰的不同解决方案.</p>
<p><strong>结论</strong></p>
<p>只有当所有父类除第一个外都是 <a class="reference internal" href="#interface"><span class="std std-ref">纯接口类</span></a> 时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以 <code class="docutils literal"><span class="pre">Interface</span></code> 为后缀.</p>
<p><strong>注意</strong></p>
<p>关于该规则, Windows 下有个 <a class="reference internal" href="contents.html#windows-code"><span class="std std-ref">特例</span></a>.</p>
</div>
<div class="section" id="interface">
<span id="id9"></span><h4>3.7. 接口</h4>
<p><strong>总述</strong></p>
<p>接口是指满足特定条件的类, 这些类以 <code class="docutils literal"><span class="pre">Interface</span></code> 为后缀 (不强制).</p>
<p><strong>定义</strong></p>
<p>当一个类满足以下要求时, 称之为纯接口:</p>
<ul class="simple">
<li>只有纯虚函数 (&#8220;<code class="docutils literal"><span class="pre">=0</span></code>&#8221;) 和静态函数 (除了下文提到的析构函数).</li>
<li>没有非静态数据成员.</li>
<li>没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 <code class="docutils literal"><span class="pre">protected</span></code>.</li>
<li>如果它是一个子类, 也只能从满足上述条件并以 <code class="docutils literal"><span class="pre">Interface</span></code> 为后缀的类继承.</li>
</ul>
<p>接口类不能被直接实例化, 因为它声明了纯虚函数. 为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数 (作为上述第 1 条规则的特例, 析构函数不能是纯虚函数). 具体细节可参考 Stroustrup 的 <em>The C++ Programming Language, 3rd edition</em> 第 12.4 节.</p>
<p><strong>优点</strong></p>
<p>以 <code class="docutils literal"><span class="pre">Interface</span></code> 为后缀可以提醒其他人不要为该接口类增加函数实现或非静态数据成员. 这一点对于 <a class="reference internal" href="#multiple-inheritance"><span class="std std-ref">多重继承</span></a> 尤其重要. 另外, 对于 Java 程序员来说, 接口的概念已是深入人心.</p>
<p><strong>缺点</strong></p>
<p><code class="docutils literal"><span class="pre">Interface</span></code> 后缀增加了类名长度, 为阅读和理解带来不便. 同时, 接口属性作为实现细节不应暴露给用户.</p>
<p><strong>结论</strong></p>
<p>只有在满足上述条件时, 类才以 <code class="docutils literal"><span class="pre">Interface</span></code> 结尾, 但反过来, 满足上述需要的类未必一定以 <code class="docutils literal"><span class="pre">Interface</span></code> 结尾.</p>
</div>
<div class="section" id="id10">
<h4>3.8. 运算符重载</h4>
<p><strong>总述</strong></p>
<p>除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量.</p>
<p><strong>定义</strong></p>
<p>C++ 允许用户通过使用 <code class="docutils literal"><span class="pre">operator</span></code> 关键字 <a class="reference external" href="http://en.cppreference.com/w/cpp/language/operators">对内建运算符进行重载定义</a> , 只要其中一个参数是用户定义的类型. <code class="docutils literal"><span class="pre">operator</span></code> 关键字还允许用户使用 <code class="docutils literal"><span class="pre">operator&quot;&quot;</span></code> 定义新的字面运算符, 并且定义类型转换函数, 例如 <code class="docutils literal"><span class="pre">operator</span> <span class="pre">bool()</span></code>.</p>
<p><strong>优点</strong></p>
<p>重载运算符可以让代码更简洁易懂, 也使得用户定义的类型和内建类型拥有相似的行为. 重载运算符对于某些运算来说是符合符合语言习惯的名称 (例如 <code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">=</span></code>, <code class="docutils literal"><span class="pre">&lt;&lt;</span></code>), 遵循这些语言约定可以让用户定义的类型更易读, 也能更好地和需要这些重载运算符的函数库进行交互操作.</p>
<p>对于创建用户定义的类型的对象来说, 用户定义字面量是一种非常简洁的标记.</p>
<p><strong>缺点</strong></p>
<ul class="simple">
<li>要提供正确, 一致, 不出现异常行为的操作符运算需要花费不少精力, 而且如果达不到这些要求的话, 会导致令人迷惑的 Bug.</li>
<li>过度使用运算符会带来难以理解的代码, 尤其是在重载的操作符的语义与通常的约定不符合时.</li>
<li>函数重载有多少弊端, 运算符重载就至少有多少.</li>
<li>运算符重载会混淆视听, 让你误以为一些耗时的操作和操作内建类型一样轻巧.</li>
<li>对重载运算符的调用点的查找需要的可就不仅仅是像 grep 那样的程序了, 这时需要能够理解 C++ 语法的搜索工具.</li>
<li>如果重载运算符的参数写错, 此时得到的可能是一个完全不同的重载而非编译错误. 例如: <code class="docutils literal"><span class="pre">foo</span> <span class="pre">&lt;</span> <span class="pre">bar</span></code> 执行的是一个行为, 而 <code class="docutils literal"><span class="pre">&amp;foo</span> <span class="pre">&lt;</span> <span class="pre">&amp;bar</span></code> 执行的就是完全不同的另一个行为了.</li>
<li>重载某些运算符本身就是有害的. 例如, 重载一元运算符 <code class="docutils literal"><span class="pre">&amp;</span></code> 会导致同样的代码有完全不同的含义, 这取决于重载的声明对某段代码而言是否是可见的. 重载诸如 <code class="docutils literal"><span class="pre">&amp;&amp;</span></code>, <code class="docutils literal"><span class="pre">||</span></code> 和 <code class="docutils literal"><span class="pre">,</span></code> 会导致运算顺序和内建运算的顺序不一致.</li>
<li>运算符从通常定义在类的外部, 所以对于同一运算, 可能出现不同的文件引入了不同的定义的风险. 如果两种定义都链接到同一二进制文件, 就会导致未定义的行为, 有可能表现为难以发现的运行时错误.</li>
<li>用户定义字面量所创建的语义形式对于某些有经验的 C++ 程序员来说都是很陌生的.</li>
</ul>
<p><strong>结论</strong></p>
<p>只有在意义明显, 不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符. 例如, <code class="docutils literal"><span class="pre">|</span></code> 要作为位或或逻辑或来使用, 而不是作为 shell 中的管道.</p>
<p>只有对用户自己定义的类型重载运算符. 更准确地说, 将它们和它们所操作的类型定义在同一个头文件中, <code class="docutils literal"><span class="pre">.cc</span></code> 中和命名空间中. 这样做无论类型在哪里都能够使用定义的运算符, 并且最大程度上避免了多重定义的风险. 如果可能的话, 请避免将运算符定义为模板, 因为此时它们必须对任何模板参数都能够作用. 如果你定义了一个运算符, 请将其相关且有意义的运算符都进行定义, 并且保证这些定义的语义是一致的. 例如, 如果你重载了 <code class="docutils literal"><span class="pre">&lt;</span></code>, 那么请将所有的比较运算符都进行重载, 并且保证对于同一组参数, <code class="docutils literal"><span class="pre">&lt;</span></code> 和 <code class="docutils literal"><span class="pre">&gt;</span></code> 不会同时返回 <code class="docutils literal"><span class="pre">true</span></code>.</p>
<p>建议不要将不进行修改的二元运算符定义为成员函数. 如果一个二元运算符被定义为类成员, 这时隐式转换会作用域右侧的参数却不会作用于左侧. 这时会出现 <code class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code> 能够通过编译而 <code class="docutils literal"><span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">a</span></code> 不能的情况, 这是很让人迷惑的.</p>
<p>不要为了避免重载操作符而走极端. 比如说, 应当定义 <code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">=</span></code>, 和 <code class="docutils literal"><span class="pre">&lt;&lt;</span></code> 而不是 <code class="docutils literal"><span class="pre">Equals()</span></code>, <code class="docutils literal"><span class="pre">CopyFrom()</span></code> 和 <code class="docutils literal"><span class="pre">PrintTo()</span></code>. 反过来说, 不要只是为了满足函数库需要而去定义运算符重载. 比如说, 如果你的类型没有自然顺序, 而你要将它们存入 <code class="docutils literal"><span class="pre">std::set</span></code> 中, 最好还是定义一个自定义的比较运算符而不是重载 <code class="docutils literal"><span class="pre">&lt;</span></code>.</p>
<p>不要重载 <code class="docutils literal"><span class="pre">&amp;&amp;</span></code>, <code class="docutils literal"><span class="pre">||</span></code>, <code class="docutils literal"><span class="pre">,</span></code> 或一元运算符 <code class="docutils literal"><span class="pre">&amp;</span></code>. 不要重载 <code class="docutils literal"><span class="pre">operator&quot;&quot;</span></code>, 也就是说, 不要引入用户定义字面量.</p>
<p>类型转换运算符在 <a class="reference internal" href="#implicit-conversions"><span class="std std-ref">隐式类型转换</span></a> 一节有提及. <code class="docutils literal"><span class="pre">=</span></code> 运算符在 <a class="reference internal" href="#copyable-and-movable-types"><span class="std std-ref">可拷贝类型和可移动类型</span></a> 一节有提及. 运算符 <code class="docutils literal"><span class="pre">&lt;&lt;</span></code> 在 <a class="reference internal" href="contents.html#streams"><span class="std std-ref">流</span></a> 一节有提及. 同时请参见 <a class="reference internal" href="contents.html#function-overloading"><span class="std std-ref">函数重载</span></a> 一节, 其中提到的的规则对运算符重载同样适用.</p>
</div>
<div class="section" id="access-control">
<span id="id12"></span><h4>3.9. 存取控制</h4>
<p><strong>总述</strong></p>
<p>将 <em>所有</em> 数据成员声明为 <code class="docutils literal"><span class="pre">private</span></code>, 除非是 <code class="docutils literal"><span class="pre">static</span> <span class="pre">const</span></code> 类型成员 (遵循 <a class="reference internal" href="contents.html#constant-names"><span class="std std-ref">常量命名规则</span></a>). 处于技术上的原因, 在使用 <a class="reference external" href="https://github.com/google/googletest">Google Test</a> 时我们允许测试固件类中的数据成员为 <code class="docutils literal"><span class="pre">protected</span></code>.</p>
</div>
<div class="section" id="declaration-order">
<span id="id13"></span><h4>3.10. 声明顺序</h4>
<p><strong>总述</strong></p>
<p>将相似的声明放在一起, 将 <code class="docutils literal"><span class="pre">public</span></code> 部分放在最前.</p>
<p><strong>说明</strong></p>
<p>类定义一般应以 <code class="docutils literal"><span class="pre">public:</span></code> 开始, 后跟 <code class="docutils literal"><span class="pre">protected:</span></code>, 最后是 <code class="docutils literal"><span class="pre">private:</span></code>. 省略空部分.</p>
<p>在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 <code class="docutils literal"><span class="pre">typedef</span></code>, <code class="docutils literal"><span class="pre">using</span></code> 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员.</p>
<p>不要将大段的函数定义内联在类定义中. 只有那些普通的, 或非性能关键且短小的函数可以内联在函数定义中. 参见 <a class="reference internal" href="contents.html#inline-functions"><span class="std std-ref">内联函数</span></a> 一节.</p>
</div>
<div class="section" id="yulefox">
<h4>译者 (YuleFox) 笔记</h4>
<ol class="arabic simple">
<li>不在构造函数中做太多逻辑相关的初始化;</li>
<li>编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自行提供默认构造函数;</li>
<li>为避免隐式转换, 需将单参数构造函数声明为 <code class="docutils literal"><span class="pre">explicit</span></code>;</li>
<li>为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 <code class="docutils literal"><span class="pre">private</span></code> 且无需实现;</li>
<li>仅在作为数据集合时使用 <code class="docutils literal"><span class="pre">struct</span></code>;</li>
<li>组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承, 子类重载的虚函数也要声明 <code class="docutils literal"><span class="pre">virtual</span></code> 关键字, 虽然编译器允许不这样做;</li>
<li>避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口;</li>
<li>接口类类名以 <code class="docutils literal"><span class="pre">Interface</span></code> 为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非静态数据成员, 不提供构造函数, 提供的话, 声明为 <code class="docutils literal"><span class="pre">protected</span></code>;</li>
<li>为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明;</li>
<li>存取函数一般内联在头文件中;</li>
<li>声明次序: <code class="docutils literal"><span class="pre">public</span></code> -&gt; <code class="docutils literal"><span class="pre">protected</span></code> -&gt; <code class="docutils literal"><span class="pre">private</span></code>;</li>
<li>函数体尽量短小, 紧凑, 功能单一;</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/functions"></span><div class="section" id="id1">
<h3>4. 函数</h3>
<div class="section" id="id2">
<h4>4.1. 参数顺序</h4>
<p><strong>总述</strong></p>
<p>函数的参数顺序为: 输入参数在先, 后跟输出参数.</p>
<p><strong>说明</strong></p>
<p>C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之. 输入参数通常是值参或 <code class="docutils literal"><span class="pre">const</span></code> 引用, 输出参数或输入/输出参数则一般为非 <code class="docutils literal"><span class="pre">const</span></code> 指针. 在排列参数顺序时, 将所有的输入参数置于输出参数之前. 特别要注意, 在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前.</p>
<p>这并非一个硬性规定. 输入/输出参数 (通常是类或结构体) 让这个问题变得复杂. 并且, 有时候为了其他函数保持一致, 你可能不得不有所变通.</p>
</div>
<div class="section" id="id3">
<h4>4.2. 编写简短函数</h4>
<p><strong>总述</strong></p>
<p>我们倾向于编写简短, 凝练的函数.</p>
<p><strong>说明</strong></p>
<p>我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p>
<p>即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的 bug. 使函数尽量简短, 以便于他人阅读和修改代码.</p>
<p>在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用 / 调试起来很困难, 或者你只需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数.</p>
</div>
<div class="section" id="id4">
<h4>4.3. 引用参数</h4>
<p><strong>总述</strong></p>
<p>所有按引用传递的参数必须加上 <code class="docutils literal"><span class="pre">const</span></code>.</p>
<p><strong>定义</strong></p>
<p>在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 <code class="docutils literal"><span class="pre">int</span> <span class="pre">foo(int</span> <span class="pre">*pval)</span></code>. 在 C++ 中, 函数还可以声明为引用参数: <code class="docutils literal"><span class="pre">int</span> <span class="pre">foo(int</span> <span class="pre">&amp;val)</span></code>.</p>
<p><strong>优点</strong></p>
<p>定义引用参数可以防止出现 <code class="docutils literal"><span class="pre">(*pval)++</span></code> 这样丑陋的代码. 引用参数对于拷贝构造函数这样的应用也是必需的. 同时也更明确地不接受空指针.</p>
<p><strong>缺点</strong></p>
<p>容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</p>
<p><strong>结论</strong></p>
<p>函数参数列表中, 所有引用参数都必须是 <code class="docutils literal"><span class="pre">const</span></code>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="n">string</span> <span class="o">*</span><span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
<p>事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 <code class="docutils literal"><span class="pre">const</span></code> 引用, 输出参数为指针. 输入参数可以是 <code class="docutils literal"><span class="pre">const</span></code> 指针, 但决不能是非 <code class="docutils literal"><span class="pre">const</span></code> 的引用参数, 除非特殊要求, 比如 <code class="docutils literal"><span class="pre">swap()</span></code>.</p>
<p>有时候, 在输入形参中用 <code class="docutils literal"><span class="pre">const</span> <span class="pre">T*</span></code> 指针比 <code class="docutils literal"><span class="pre">const</span> <span class="pre">T&amp;</span></code> 更明智. 比如:</p>
<ul class="simple">
<li>可能会传递空指针.</li>
<li>函数要把指针或对地址的引用赋值给输入形参.</li>
</ul>
<p>总而言之, 大多时候输入形参往往是 <code class="docutils literal"><span class="pre">const</span> <span class="pre">T&amp;</span></code>. 若用 <code class="docutils literal"><span class="pre">const</span> <span class="pre">T*</span></code> 则说明输入另有处理. 所以若要使用 <code class="docutils literal"><span class="pre">const</span> <span class="pre">T*</span></code>, 则应给出相应的理由, 否则会使得读者感到迷惑.</p>
</div>
<div class="section" id="function-overloading">
<span id="id5"></span><h4>4.4. 函数重载</h4>
<p><strong>总述</strong></p>
<p>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</p>
<p><strong>定义</strong></p>
<p>你可以编写一个参数类型为 <code class="docutils literal"><span class="pre">const</span> <span class="pre">string&amp;</span></code> 的函数, 然后用另一个参数类型为 <code class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></code> 的函数对其进行重载:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Analyze</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">text</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Analyze</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">textlen</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p><strong>优点</strong></p>
<p>通过重载参数不同的同名函数, 可以令代码更加直观. 模板化代码需要重载, 这同时也能为使用者带来便利.</p>
<p><strong>缺点</strong></p>
<p>如果函数单靠不同的参数类型而重载 (acgtyrant 注：这意味着参数数量不变), 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何. 另外, 如果派生类只重载了某个函数的部分变体, 继承语义就容易令人困惑.</p>
<p><strong>结论</strong></p>
<p>如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用 <code class="docutils literal"><span class="pre">AppendString()</span></code> 和 <code class="docutils literal"><span class="pre">AppendInt()</span></code> 等, 而不是一口气重载多个 <code class="docutils literal"><span class="pre">Append()</span></code>. 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 <code class="docutils literal"><span class="pre">std::vector</span></code> 以便使用者可以用 <a class="reference internal" href="contents.html#braced-initializer-list"><span class="std std-ref">列表初始化</span></a> 指定参数.</p>
</div>
<div class="section" id="id6">
<h4>4.5. 缺省参数</h4>
<p><strong>总述</strong></p>
<p>只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 缺省参数与 <a class="reference internal" href="contents.html#function-overloading"><span class="std std-ref">函数重载</span></a> 遵循同样的规则. 一般情况下建议使用函数重载, 尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下.</p>
<p><strong>优点</strong></p>
<p>有些函数一般情况下使用默认参数, 但有时需要又使用非默认的参数. 缺省参数为这样的情形提供了便利, 使程序员不需要为了极少的例外情况编写大量的函数. 和函数重载相比, 缺省参数的语法更简洁明了, 减少了大量的样板代码, 也更好地区别了 &#8220;必要参数&#8221; 和 &#8220;可选参数&#8221;.</p>
<p><strong>缺点</strong></p>
<p>缺省参数实际上是函数重载语义的另一种实现方式, 因此所有 <a class="reference internal" href="contents.html#function-overloading"><span class="std std-ref">不应当使用函数重载的理由</span></a> 也都适用于缺省参数.</p>
<p>虚函数调用的缺省参数取决于目标对象的静态类型, 此时无法保证给定函数的所有重载声明的都是同样的缺省参数.</p>
<p>缺省参数是在每个调用点都要进行重新求值的, 这会造成生成的代码迅速膨胀. 作为读者, 一般来说也更希望缺省的参数在声明时就已经被固定了, 而不是在每次调用时都可能会有不同的取值.</p>
<p>缺省参数会干扰函数指针, 导致函数签名与调用点的签名不一致. 而函数重载不会导致这样的问题.</p>
<p><strong>结论</strong></p>
<p>对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作. 如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用. (例如, 不要写像 <code class="docutils literal"><span class="pre">void</span> <span class="pre">f(int</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">counter++);</span></code> 这样的代码.)</p>
<p>在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话, 可以使用缺省参数. 如果仍有疑惑, 就使用函数重载.</p>
</div>
<div class="section" id="id7">
<h4>4.6. 函数返回类型后置语法</h4>
<p><strong>总述</strong></p>
<p>只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法.</p>
<p><strong>定义</strong></p>
<p>C++ 现在允许两种不同的函数声明方式. 以往的写法是将返回类型置于函数名之前. 例如:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
<p>C++11 引入了这一新的形式. 现在可以在函数名前使用 <code class="docutils literal"><span class="pre">auto</span></code> 关键字, 在参数列表之后后置返回类型. 例如:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">;</span>
</pre></div>
</div>
<p>后置返回类型为函数作用域. 对于像 <code class="docutils literal"><span class="pre">int</span></code> 这样简单的类型, 两种写法没有区别. 但对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别.</p>
<p><strong>优点</strong></p>
<p>后置返回类型是显式地指定 <a class="reference internal" href="contents.html#lambda-expressions"><span class="std std-ref">Lambda 表达式</span></a> 的返回值的唯一方式. 某些情况下, 编译器可以自动推导出 Lambda 表达式的返回类型, 但并不是在所有的情况下都能实现. 即使编译器能够自动推导, 显式地指定返回类型也能让读者更明了.</p>
<p>有时在已经出现了的函数参数列表之后指定返回类型, 能够让书写更简单, 也更易读, 尤其是在返回类型依赖于模板参数时. 例如:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span> <span class="k">auto</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">);</span>
</pre></div>
</div>
<p>对比下面的例子:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&gt;</span><span class="p">()</span> <span class="o">+</span> <span class="n">declval</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&amp;&gt;</span><span class="p">())</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>缺点</strong></p>
<p>后置返回类型相对来说是非常新的语法, 而且在 C 和 Java 中都没有相似的写法, 因此可能对读者来说比较陌生.</p>
<p>在已有的代码中有大量的函数声明, 你不可能把它们都用新的语法重写一遍. 因此实际的做法只能是使用旧的语法或者新旧混用. 在这种情况下, 只使用一种版本是相对来说更规整的形式.</p>
<p><strong>结论</strong></p>
<p>在大部分情况下, 应当继续使用以往的函数声明写法, 即将返回类型置于函数名前. 只有在必需的时候 (如 Lambda 表达式) 或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法. 但是后一种情况一般来说是很少见的, 大部分时候都出现在相当复杂的模板代码中, 而多数情况下不鼓励写这样 <a class="reference internal" href="contents.html#template-metaprogramming"><span class="std std-ref">复杂的模板代码</span></a>.</p>
</div>
</div>
<span id="document-google-cpp-styleguide/magic"></span><div class="section" id="google">
<h3>5. 来自 Google 的奇技</h3>
<p>Google 用了很多自己实现的技巧 / 工具使 C++ 代码更加健壮, 我们使用 C++ 的方式可能和你在其它地方见到的有所不同.</p>
<div class="section" id="id1">
<h4>5.1. 所有权与智能指针</h4>
<p><strong>&gt; 总述</strong></p>
<p>动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.</p>
<p><strong>&gt; 定义</strong></p>
<p>所有权是一种登记／管理动态内存和其它资源的技术. 动态分配对象的所有主是一个对象或函数, 后者负责确保当前者无用时就自动销毁前者. 所有权有时可以共享, 此时就由最后一个所有主来负责销毁它. 甚至也可以不用共享, 在代码中直接把所有权传递给其它对象.</p>
<p>智能指针是一个通过重载 <code class="docutils literal"><span class="pre">*</span></code> 和 <code class="docutils literal"><span class="pre">-&gt;</span></code> 运算符以表现得如指针一样的类. 智能指针类型被用来自动化所有权的登记工作, 来确保执行销毁义务到位. <a class="reference external" href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a> 是 C++11 新推出的一种智能指针类型, 用来表示动态分配出的对象的独一无二的所有权; 当 <code class="docutils literal"><span class="pre">std::unique_ptr</span></code> 离开作用域时, 对象就会被销毁. <code class="docutils literal"><span class="pre">std::unique_ptr</span></code> 不能被复制, 但可以把它移动（move）给新所有主. <a class="reference external" href="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> 同样表示动态分配对象的所有权, 但可以被共享, 也可以被复制; 对象的所有权由所有复制者共同拥有, 最后一个复制者被销毁时, 对象也会随着被销毁.</p>
<p><strong>&gt; 优点</strong></p>
<ul class="simple">
<li>如果没有清晰、逻辑条理的所有权安排, 不可能管理好动态分配的内存.</li>
<li>传递对象的所有权, 开销比复制来得小, 如果可以复制的话.</li>
<li>传递所有权也比&#8221;借用&#8221;指针或引用来得简单, 毕竟它大大省去了两个用户一起协调对象生命周期的工作.</li>
<li>如果所有权逻辑条理, 有文档且不紊乱的话, 可读性会有很大提升.</li>
<li>可以不用手动完成所有权的登记工作, 大大简化了代码, 也免去了一大波错误之恼.</li>
<li>对于 const 对象来说, 智能指针简单易用, 也比深度复制高效.</li>
</ul>
<p><strong>&gt; 缺点</strong></p>
<ul class="simple">
<li>不得不用指针（不管是智能的还是原生的）来表示和传递所有权. 指针语义可要比值语义复杂得许多了, 特别是在 API 里：这时不光要操心所有权, 还要顾及别名, 生命周期, 可变性以及其它大大小小的问题.</li>
<li>其实值语义的开销经常被高估, 所以所有权传递带来的性能提升不一定能弥补可读性和复杂度的损失.</li>
<li>如果 API 依赖所有权的传递, 就会害得客户端不得不用单一的内存管理模型.</li>
<li>如果使用智能指针, 那么资源释放发生的位置就会变得不那么明显.</li>
<li><code class="docutils literal"><span class="pre">std::unique_ptr</span></code> 的所有权传递原理是 C++11 的 move 语法, 后者毕竟是刚刚推出的, 容易迷惑程序员.</li>
<li>如果原本的所有权设计已经够完善了, 那么若要引入所有权共享机制, 可能不得不重构整个系统.</li>
<li>所有权共享机制的登记工作在运行时进行, 开销可能相当大.</li>
<li>某些极端情况下 (例如循环引用), 所有权被共享的对象永远不会被销毁.</li>
<li>智能指针并不能够完全代替原生指针.</li>
</ul>
<p><strong>&gt; 结论</strong></p>
<p>如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中. 如果其他地方要使用这个对象, 最好传递它的拷贝, 或者传递一个不用改变所有权的指针或引用. 倾向于使用 <code class="docutils literal"><span class="pre">std::unique_ptr</span></code> 来明确所有权传递, 例如：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">FooFactory</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">FooConsumer</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">);</span>
</pre></div>
</div>
<p>如果没有很好的理由, 则不要使用共享所有权. 这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显, 并且操作的对象是不可变的（比如说 <code class="docutils literal"><span class="pre">std::shared_ptr&lt;const</span> <span class="pre">Foo&gt;</span></code> ）时候, 才能这么做. 如果确实要使用共享所有权, 建议于使用 <code class="docutils literal"><span class="pre">std::shared_ptr</span></code> .</p>
<p>不要使用 <code class="docutils literal"><span class="pre">std::auto_ptr</span></code>, 使用 <code class="docutils literal"><span class="pre">std::unique_ptr</span></code> 代替它.</p>
</div>
<div class="section" id="cpplint">
<h4>5.2. Cpplint</h4>
<p><strong>&gt; 总述</strong></p>
<p>使用 <code class="docutils literal"><span class="pre">cpplint.py</span></code> 检查风格错误.</p>
<p><strong>&gt; 说明</strong></p>
<p><code class="docutils literal"><span class="pre">cpplint.py</span></code> 是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍然是一个非常有用的工具. 在行尾加 <code class="docutils literal"><span class="pre">//</span> <span class="pre">NOLINT</span></code>, 或在上一行加 <code class="docutils literal"><span class="pre">//</span> <span class="pre">NOLINTNEXTLINE</span></code>, 可以忽略报错.</p>
<p>某些项目会指导你如何使用他们的项目工具运行 <code class="docutils literal"><span class="pre">cpplint.py</span></code>. 如果你参与的项目没有提供, 你可以单独下载 <a class="reference external" href="http://github.com/google/styleguide/blob/gh-pages/cpplint/cpplint.py">cpplint.py</a>.</p>
</div>
<div class="section" id="acgtyrant">
<h4>译者（acgtyrant）笔记</h4>
<ol class="arabic simple">
<li>把智能指针当成对象来看待的话, 就很好领会它与所指对象之间的关系了.</li>
<li>原来 Rust 的 Ownership 思想是受到了 C++ 智能指针的很大启发啊.</li>
<li><code class="docutils literal"><span class="pre">scoped_ptr</span></code> 和 <code class="docutils literal"><span class="pre">auto_ptr</span></code> 已过时.  现在是 <code class="docutils literal"><span class="pre">shared_ptr</span></code> 和 <code class="docutils literal"><span class="pre">uniqued_ptr</span></code> 的天下了.</li>
<li>按本文来说, 似乎除了智能指针, 还有其它所有权机制, 值得留意.</li>
<li>Arch Linux 用户注意了, AUR 有对 cpplint 打包.</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/others"></span><div class="section" id="c">
<h3>5. 其他 C++ 特性</h3>
<div class="section" id="id1">
<h4>5.1. 引用参数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">所有按引用传递的参数必须加上 <code class="docutils literal"><span class="pre">const</span></code>.</p>
</div>
<p>定义:</p>
<blockquote>
<div>在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 <code class="docutils literal"><span class="pre">int</span> <span class="pre">foo(int</span> <span class="pre">*pval)</span></code>. 在 C++ 中, 函数还可以声明引用参数: <code class="docutils literal"><span class="pre">int</span> <span class="pre">foo(int</span> <span class="pre">&amp;val)</span></code>.</div></blockquote>
<p>优点:</p>
<blockquote>
<div>定义引用参数防止出现 <code class="docutils literal"><span class="pre">(*pval)++</span></code> 这样丑陋的代码. 像拷贝构造函数这样的应用也是必需的. 而且更明确, 不接受 <code class="docutils literal"><span class="pre">NULL</span></code> 指针.</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p>函数参数列表中, 所有引用参数都必须是 <code class="docutils literal"><span class="pre">const</span></code>:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="n">string</span> <span class="o">*</span><span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 <code class="docutils literal"><span class="pre">const</span></code> 引用, 输出参数为指针. 输入参数可以是 <code class="docutils literal"><span class="pre">const</span></code> 指针, 但决不能是非 <code class="docutils literal"><span class="pre">const</span></code> 的引用参数，除非用于交换，比如 <code class="docutils literal"><span class="pre">swap()</span></code>.</p>
<p>有时候，在输入形参中用 <code class="docutils literal"><span class="pre">const</span> <span class="pre">T*</span></code> 指针比 <code class="docutils literal"><span class="pre">const</span> <span class="pre">T&amp;</span></code> 更明智。比如：</p>
<ul class="simple">
<li>您会传 null 指针。</li>
<li>函数要把指针或对地址的引用赋值给输入形参。</li>
</ul>
<p>总之大多时候输入形参往往是 <code class="docutils literal"><span class="pre">const</span> <span class="pre">T&amp;</span></code>. 若用 <code class="docutils literal"><span class="pre">const</span> <span class="pre">T*</span></code> 说明输入另有处理。所以若您要用 <code class="docutils literal"><span class="pre">const</span> <span class="pre">T*</span></code>, 则应有理有据，否则会害得读者误解。</p>
</div></blockquote>
</div>
<div class="section" id="id2">
<h4>5.2. 右值引用</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用 <code class="docutils literal"><span class="pre">std::forward</span></code>.</p>
</div>
<p>定义:</p>
<blockquote>
<div>右值引用是一种只能绑定到临时对象的引用的一种, 其语法与传统的引用语法相似. 例如, <code class="docutils literal"><span class="pre">void</span> <span class="pre">f(string&amp;&amp;</span> <span class="pre">s)</span></code>; 声明了一个其参数是一个字符串的右值引用的函数.</div></blockquote>
<p>优点:</p>
<blockquote>
<div><p>用于定义移动构造函数 (使用类的右值引用进行构造的函数) 使得移动一个值而非拷贝之成为可能. 例如, 如果 <code class="docutils literal"><span class="pre">v1</span></code> 是一个 <code class="docutils literal"><span class="pre">vector&lt;string&gt;</span></code>, 则 <code class="docutils literal"><span class="pre">auto</span> <span class="pre">v2(std::move(v1))</span></code> 将很可能不再进行大量的数据复制而只是简单地进行指针操作, 在某些情况下这将带来大幅度的性能提升.</p>
<p>右值引用使得编写通用的函数封装来转发其参数到另外一个函数成为可能, 无论其参数是否是临时对象都能正常工作.</p>
<p>右值引用能实现可移动但不可拷贝的类型, 这一特性对那些在拷贝方面没有实际需求, 但有时又需要将它们作为函数参数传递或塞入容器的类型很有用.</p>
<p>要高效率地使用某些标准库类型, 例如 <code class="docutils literal"><span class="pre">std::unique_ptr</span></code>, <code class="docutils literal"><span class="pre">std::move</span></code> 是必需的.</p>
</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>右值引用是一个相对比较新的特性 (由 C++11 引入), 它尚未被广泛理解. 类似引用崩溃, 移动构造函数的自动推导这样的规则都是很复杂的.</div></blockquote>
<p>结论:</p>
<blockquote>
<div>只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用 <code class="docutils literal"><span class="pre">std::forward</span></code> 功能函数. 你可能会使用 <code class="docutils literal"><span class="pre">std::move</span></code> 来表示将值从一个对象移动而不是复制到另一个对象.</div></blockquote>
</div>
<div class="section" id="function-overloading">
<span id="id3"></span><h4>5.3. 函数重载</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">若要用好函数重载，最好能让读者一看调用点（call site）就胸有成竹，不用花心思猜测调用的重载函数到底是哪一种。该规则适用于构造函数。</p>
</div>
<p>定义:</p>
<blockquote>
<div><p>你可以编写一个参数类型为 <code class="docutils literal"><span class="pre">const</span> <span class="pre">string&amp;</span></code> 的函数, 然后用另一个参数类型为 <code class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></code> 的函数重载它:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Analyze</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">text</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Analyze</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">textlen</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<p>优点:</p>
<blockquote>
<div>通过重载参数不同的同名函数, 令代码更加直观. 模板化代码需要重载, 同时为使用者带来便利.</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>如果函数单单靠不同的参数类型而重载（acgtyrant 注：这意味着参数数量不变），读者就得十分熟悉 C++ 五花八门的匹配规则，以了解匹配过程具体到底如何。另外，当派生类只重载了某个函数的部分变体，继承语义容易令人困惑。</div></blockquote>
<p>结论:</p>
<blockquote>
<div>如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用 <code class="docutils literal"><span class="pre">AppendString()</span></code> 和 <code class="docutils literal"><span class="pre">AppendInt()</span></code> 等， 而不是一口气重载多个 <code class="docutils literal"><span class="pre">Append()</span></code>.</div></blockquote>
</div>
<div class="section" id="id4">
<h4>5.4. 缺省参数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。</p>
</div>
<p>优点:</p>
<blockquote>
<div>当您有依赖缺省参数的函数时，您也许偶尔会修改修改这些缺省参数。通过缺省参数，不用再为个别情况而特意定义一大堆函数了。与函数重载相比，缺省参数语法更为清晰，代码少，也很好地区分了「必选参数」和「可选参数」。</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>缺省参数会干扰函数指针，害得后者的函数签名（function signature）往往对不上所实际要调用的函数签名。即在一个现有函数添加缺省参数，就会改变它的类型，那么调用其地址的代码可能会出错，不过函数重载就没这问题了。此外，缺省参数会造成臃肿的代码，毕竟它们在每一个调用点（call site）都有重复（acgtyrant 注：我猜可能是因为调用函数的代码表面上看来省去了不少参数，但编译器在编译时还是会在每一个调用代码里统统补上所有默认实参信息，造成大量的重复）。函数重载正好相反，毕竟它们所谓的「缺省参数」只会出现在函数定义里。</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p>由于缺点并不是很严重，有些人依旧偏爱缺省参数胜于函数重载。所以除了以下情况，我们要求必须显式提供所有参数（acgtyrant 注：即不能再通过缺省参数来省略参数了）。</p>
<p>其一，位于 <code class="docutils literal"><span class="pre">.cc</span></code> 文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了。</p>
<p>其二，可以在构造函数里用缺省参数，毕竟不可能取得它们的地址。</p>
<p>其三，可以用来模拟变长数组。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 通过空 AlphaNum 以支持四个形参</span>
<span class="n">string</span> <span class="nf">StrCat</span><span class="p">(</span><span class="k">const</span> <span class="n">AlphaNum</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">AlphaNum</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">gEmptyAlphaNum</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">AlphaNum</span> <span class="o">&amp;</span><span class="n">c</span> <span class="o">=</span> <span class="n">gEmptyAlphaNum</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">AlphaNum</span> <span class="o">&amp;</span><span class="n">d</span> <span class="o">=</span> <span class="n">gEmptyAlphaNum</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="alloca">
<h4>5.5. 变长数组和 alloca()</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们不允许使用变长数组和 <code class="docutils literal"><span class="pre">alloca()</span></code>.</p>
</div>
<p>优点:</p>
<blockquote>
<div>变长数组具有浑然天成的语法. 变长数组和 <code class="docutils literal"><span class="pre">alloca()</span></code> 也都很高效.</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>变长数组和 <code class="docutils literal"><span class="pre">alloca()</span></code> 不是标准 C++ 的组成部分. 更重要的是, 它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs: &#8220;在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了&#8221;.</div></blockquote>
<p>结论:</p>
<blockquote>
<div>改用更安全的分配器（allocator），就像 <code class="docutils literal"><span class="pre">std::vector</span></code> 或 <code class="docutils literal"><span class="pre">std::unique_ptr&lt;T[]&gt;</span></code>.</div></blockquote>
</div>
<div class="section" id="id5">
<h4>5.6. 友元</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们允许合理的使用友元类及友元函数.</p>
</div>
<p>通常友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类. 经常用到友元的一个地方是将 <code class="docutils literal"><span class="pre">FooBuilder</span></code> 声明为 <code class="docutils literal"><span class="pre">Foo</span></code> 的友元, 以便 <code class="docutils literal"><span class="pre">FooBuilder</span></code> 正确构造 <code class="docutils literal"><span class="pre">Foo</span></code> 的内部状态, 而无需将该状态暴露出来. 某些情况下, 将一个单元测试类声明成待测类的友元会很方便.</p>
<p>友元扩大了 (但没有打破) 类的封装边界. 某些情况下, 相对于将类成员声明为 <code class="docutils literal"><span class="pre">public</span></code>, 使用友元是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时. 当然, 大多数类都只应该通过其提供的公有成员进行互操作.</p>
</div>
<div class="section" id="exceptions">
<span id="id6"></span><h4>5.7. 异常</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们不使用 C++ 异常.</p>
</div>
<p>优点:</p>
<blockquote>
<div><ul class="simple">
<li>异常允许应用高层决定如何处理在底层嵌套函数中「不可能发生」的失败（failures），不用管那些含糊且容易出错的错误代码（acgtyrant 注：error code, 我猜是Ｃ语言函数返回的非零 int 值）。</li>
<li>很多现代语言都用异常。引入异常使得 C++ 与 Python, Java 以及其它类 C++ 的语言更一脉相承。</li>
<li>有些第三方 C++ 库依赖异常，禁用异常就不好用了。</li>
<li>异常是处理构造函数失败的唯一途径。虽然可以用工厂函数（acgtyrant 注：factory function, 出自 C++ 的一种设计模式，即「简单工厂模式」）或 <code class="docutils literal"><span class="pre">Init()</span></code> 方法代替异常, 但是前者要求在堆栈分配内存，后者会导致刚创建的实例处于 ”无效“ 状态。</li>
<li>在测试框架里很好用。</li>
</ul>
</div></blockquote>
<p>缺点:</p>
<blockquote>
<div><ul class="simple">
<li>在现有函数中添加 <code class="docutils literal"><span class="pre">throw</span></code> 语句时，您必须检查所有调用点。要么让所有调用点统统具备最低限度的异常安全保证，要么眼睁睁地看异常一路欢快地往上跑，最终中断掉整个程序。举例，<code class="docutils literal"><span class="pre">f()</span></code> 调用 <code class="docutils literal"><span class="pre">g()</span></code>, <code class="docutils literal"><span class="pre">g()</span></code> 又调用 <code class="docutils literal"><span class="pre">h()</span></code>, 且 <code class="docutils literal"><span class="pre">h</span></code> 抛出的异常被 <code class="docutils literal"><span class="pre">f</span></code> 捕获。当心 <code class="docutils literal"><span class="pre">g</span></code>, 否则会没妥善清理好。</li>
<li>还有更常见的，异常会彻底扰乱程序的执行流程并难以判断，函数也许会在您意料不到的地方返回。您或许会加一大堆何时何处处理异常的规定来降低风险，然而开发者的记忆负担更重了。</li>
<li>异常安全需要RAII和不同的编码实践. 要轻松编写出正确的异常安全代码需要大量的支持机制. 更进一步地说, 为了避免读者理解整个调用表, 异常安全必须隔绝从持续状态写到 &#8220;提交&#8221; 状态的逻辑. 这一点有利有弊 (因为你也许不得不为了隔离提交而混淆代码). 如果允许使用异常, 我们就不得不时刻关注这样的弊端, 即使有时它们并不值得.</li>
<li>启用异常会增加二进制文件数据，延长编译时间（或许影响小），还可能加大地址空间的压力。</li>
<li>滥用异常会变相鼓励开发者去捕捉不合时宜，或本来就已经没法恢复的「伪异常」。比如，用户的输入不符合格式要求时，也用不着抛异常。如此之类的伪异常列都列不完。</li>
</ul>
</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p>从表面上看来，使用异常利大于弊, 尤其是在新项目中. 但是对于现有代码, 引入异常会牵连到所有相关代码. 如果新项目允许异常向外扩散, 在跟以前未使用异常的代码整合时也将是个麻烦. 因为 Google 现有的大多数 C++ 代码都没有异常处理, 引入带有异常处理的新代码相当困难.</p>
<p>鉴于 Google 现有代码不接受异常, 在现有代码中使用异常比在新项目中使用的代价多少要大一些. 迁移过程比较慢, 也容易出错. 我们不相信异常的使用有效替代方案, 如错误代码, 断言等会造成严重负担.</p>
<p>我们并不是基于哲学或道德层面反对使用异常, 而是在实践的基础上. 我们希望在 Google 使用我们自己的开源项目, 但项目中使用异常会为此带来不便, 因此我们也建议不要在 Google 的开源项目中使用异常. 如果我们需要把这些项目推倒重来显然不太现实.</p>
<p>对于 Windows 代码来说, 有个 <a class="reference internal" href="contents.html#windows-code"><span class="std std-ref">特例</span></a>.</p>
</div></blockquote>
<p>(YuleFox 注: 对于异常处理, 显然不是短短几句话能够说清楚的, 以构造函数为例, 很多 C++ 书籍上都提到当构造失败时只有异常可以处理, Google 禁止使用异常这一点, 仅仅是为了自身的方便, 说大了, 无非是基于软件管理成本上, 实际使用中还是自己决定)</p>
</div>
<div class="section" id="rtti">
<span id="id7"></span><h4>5.8. 运行时类型识别</h4>
<blockquote>
<div>TODO</div></blockquote>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们禁止使用 RTTI.</p>
</div>
<p>定义:</p>
<blockquote>
<div>RTTI 允许程序员在运行时识别 C++ 类对象的类型. 它通过使用 <code class="docutils literal"><span class="pre">typeid</span></code> 或者 <code class="docutils literal"><span class="pre">dynamic_cast</span></code> 完成.</div></blockquote>
<p>优点:</p>
<blockquote>
<div><p>RTTI 的标准替代 (下面将描述) 需要对有问题的类层级进行修改或重构. 有时这样的修改并不是我们所想要的, 甚至是不可取的, 尤其是在一个已经广泛使用的或者成熟的代码中.</p>
<p>RTTI 在某些单元测试中非常有用. 比如进行工厂类测试时, 用来验证一个新建对象是否为期望的动态类型. RTTI 对于管理对象和派生对象的关系也很有用.</p>
<p>在考虑多个抽象对象时 RTTI 也很好用. 例如:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">Base</span><span class="o">::</span><span class="n">Equal</span><span class="p">(</span><span class="n">Base</span><span class="o">*</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">Derived</span><span class="o">::</span><span class="n">Equal</span><span class="p">(</span><span class="n">Base</span><span class="o">*</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Derived</span><span class="o">*</span> <span class="n">that</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">that</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>缺点:</p>
<blockquote>
<div><p>在运行时判断类型通常意味着设计问题. 如果你需要在运行期间确定一个对象的类型, 这通常说明你需要考虑重新设计你的类.</p>
<p>随意地使用 RTTI 会使你的代码难以维护. 它使得基于类型的判断树或者 switch 语句散布在代码各处. 如果以后要进行修改, 你就必须检查它们.</p>
</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p>RTTI 有合理的用途但是容易被滥用, 因此在使用时请务必注意. 在单元测试中可以使用 RTTI, 但是在其他代码中请尽量避免. 尤其是在新代码中, 使用 RTTI 前务必三思. 如果你的代码需要根据不同的对象类型执行不同的行为的话, 请考虑用以下的两种替代方案之一查询类型:</p>
<p>虚函数可以根据子类类型的不同而执行不同代码. 这是把工作交给了对象本身去处理.</p>
<p>如果这一工作需要在对象之外完成, 可以考虑使用双重分发的方案, 例如使用访问者设计模式. 这就能够在对象之外进行类型判断.</p>
<p>如果程序能够保证给定的基类实例实际上都是某个派生类的实例, 那么就可以自由使用 dynamic_cast. 在这种情况下, 使用 dynamic_cast 也是一种替代方案.</p>
<p>基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了. 不要像下面这样:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="n">D1</span><span class="p">))</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="n">D2</span><span class="p">))</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="n">D3</span><span class="p">))</span> <span class="p">{</span>
<span class="p">...</span>
</pre></div>
</div>
<p>一旦在类层级中加入新的子类, 像这样的代码往往会崩溃. 而且, 一旦某个子类的属性改变了, 你很难找到并修改所有受影响的代码块.</p>
<p>不要去手工实现一个类似 RTTI 的方案. 反对 RTTI 的理由同样适用于这些方案, 比如带类型标签的类继承体系. 而且, 这些方案会掩盖你的真实意图.</p>
</div></blockquote>
</div>
<div class="section" id="id8">
<h4>5.9. 类型转换</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 C++ 的类型转换, 如 <code class="docutils literal"><span class="pre">static_cast&lt;&gt;()</span></code>. 不要使用 <code class="docutils literal"><span class="pre">int</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">(int)x</span></code> 或 <code class="docutils literal"><span class="pre">int</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">int(x)</span></code> 等转换方式;</p>
</div>
<p>定义:</p>
<blockquote>
<div>C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类.</div></blockquote>
<p>优点:</p>
<blockquote>
<div>C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如 <code class="docutils literal"><span class="pre">(int)3.5</span></code>), 有时是在做类型转换 (如 <code class="docutils literal"><span class="pre">(int)&quot;hello&quot;</span></code>). 另外, C++ 的类型转换在查找时更醒目.</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>恶心的语法.</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p>不要使用 C 风格类型转换. 而应该使用 C++ 风格.</p>
<blockquote>
<div><ul class="simple">
<li>用 <code class="docutils literal"><span class="pre">static_cast</span></code> 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时.</li>
<li>用 <code class="docutils literal"><span class="pre">const_cast</span></code> 去掉 <code class="docutils literal"><span class="pre">const</span></code> 限定符.</li>
<li>用 <code class="docutils literal"><span class="pre">reinterpret_cast</span></code> 指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用.</li>
</ul>
</div></blockquote>
<p>至于 <code class="docutils literal"><span class="pre">dynamic_cast</span></code> 参见 <a class="reference internal" href="#rtti"><span class="std std-ref">5.8. 运行时类型识别</span></a>.</p>
</div></blockquote>
</div>
<div class="section" id="streams">
<span id="id9"></span><h4>5.10. 流</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只在记录日志时使用流.</p>
</div>
<p>定义:</p>
<blockquote>
<div>流用来替代 <code class="docutils literal"><span class="pre">printf()</span></code> 和 <code class="docutils literal"><span class="pre">scanf()</span></code>.</div></blockquote>
<p>优点:</p>
<blockquote>
<div>有了流, 在打印时不需要关心对象的类型. 不用担心格式化字符串与参数列表不匹配 (虽然在 gcc 中使用 <code class="docutils literal"><span class="pre">printf</span></code> 也不存在这个问题). 流的构造和析构函数会自动打开和关闭对应的文件.</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>流使得 <code class="docutils literal"><span class="pre">pread()</span></code> 等功能函数很难执行. 如果不使用 <code class="docutils literal"><span class="pre">printf</span></code> 风格的格式化字符串, 某些格式化操作 (尤其是常用的格式字符串 <code class="docutils literal"><span class="pre">%.*s</span></code>) 用流处理性能是很低的. 流不支持字符串操作符重新排序 (%1s), 而这一点对于软件国际化很有用.</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p>不要使用流, 除非是日志接口需要. 使用 <code class="docutils literal"><span class="pre">printf</span></code> 之类的代替.</p>
<p>使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流.</p>
</div></blockquote>
<p>拓展讨论:</p>
<blockquote>
<div><p>对这一条规则存在一些争论, 这儿给出点深层次原因. 回想一下唯一性原则 (Only One Way): 我们希望在任何时候都只使用一种确定的 I/O 类型, 使代码在所有 I/O 处都保持一致. 因此, 我们不希望用户来决定是使用流还是 <code class="docutils literal"><span class="pre">printf</span> <span class="pre">+</span> <span class="pre">read/write</span></code>. 相反, 我们应该决定到底用哪一种方式. 把日志作为特例是因为日志是一个非常独特的应用, 还有一些是历史原因.</p>
<p>流的支持者们主张流是不二之选, 但观点并不是那么清晰有力. 他们指出的流的每个优势也都是其劣势. 流最大的优势是在输出时不需要关心打印对象的类型. 这是一个亮点. 同时, 也是一个不足: 你很容易用错类型, 而编译器不会报警. 使用流时容易造成的这类错误:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="p">;</span>   <span class="c1">// 输出地址</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>  <span class="c1">// 输出值</span>
</pre></div>
</div>
</div></blockquote>
<p>由于 <code class="docutils literal"><span class="pre">&lt;&lt;</span></code> 被重载, 编译器不会报错. 就因为这一点我们反对使用操作符重载.</p>
<p>有人说 <code class="docutils literal"><span class="pre">printf</span></code> 的格式化丑陋不堪, 易读性差, 但流也好不到哪儿去. 看看下面两段代码吧, 实现相同的功能, 哪个更清晰?</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error connecting to &#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">.</span><span class="n">first</span>
     <span class="o">&lt;&lt;</span> <span class="s">&quot;:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">);</span>

<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error connecting to &#39;%s:%u: %s&quot;</span><span class="p">,</span>
        <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">.</span><span class="n">second</span><span class="p">,</span>
        <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</pre></div>
</div>
</div></blockquote>
<p>你可能会说, &#8220;把流封装一下就会比较好了&#8221;, 这儿可以, 其他地方呢? 而且不要忘了, 我们的目标是使语言更紧凑, 而不是添加一些别人需要学习的新装备.</p>
<p>每一种方式都是各有利弊, &#8220;没有最好, 只有更适合&#8221;. 简单性原则告诫我们必须从中选择其一, 最后大多数决定采用 <code class="docutils literal"><span class="pre">printf</span> <span class="pre">+</span> <span class="pre">read/write</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="id10">
<h4>5.11. 前置自增和自减</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">对于迭代器和其他模板对象使用前缀形式 (<code class="docutils literal"><span class="pre">++i</span></code>) 的自增, 自减运算符.</p>
</div>
<p>定义:</p>
<blockquote>
<div>对于变量在自增 (<code class="docutils literal"><span class="pre">++i</span></code> 或 <code class="docutils literal"><span class="pre">i++</span></code>) 或自减 (<code class="docutils literal"><span class="pre">--i</span></code> 或 <code class="docutils literal"><span class="pre">i--</span></code>) 后表达式的值又没有没用到的情况下, 需要确定到底是使用前置还是后置的自增 (自减).</div></blockquote>
<p>优点:</p>
<blockquote>
<div>不考虑返回值的话, 前置自增 (<code class="docutils literal"><span class="pre">++i</span></code>) 通常要比后置自增 (<code class="docutils literal"><span class="pre">i++</span></code>) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 <code class="docutils literal"><span class="pre">i</span></code> 进行一次拷贝. 如果 <code class="docutils literal"><span class="pre">i</span></code> 是迭代器或其他非数值类型, 拷贝的代价是比较大的. 既然两种自增方式实现的功能一样, 为什么不总是使用前置自增呢?</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>在 C 开发中, 当表达式的值未被使用时, 传统的做法是使用后置自增, 特别是在 <code class="docutils literal"><span class="pre">for</span></code> 循环中. 有些人觉得后置自增更加易懂, 因为这很像自然语言, 主语 (<code class="docutils literal"><span class="pre">i</span></code>) 在谓语动词 (<code class="docutils literal"><span class="pre">++</span></code>) 前.</div></blockquote>
<p>结论:</p>
<blockquote>
<div>对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).</div></blockquote>
</div>
<div class="section" id="const">
<h4>5.12. <code class="docutils literal"><span class="pre">const</span></code> 用法</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们强烈建议你在任何可能的情况下都要使用 <code class="docutils literal"><span class="pre">const</span></code>. 此外有时改用 C++11 推出的 constexpr 更好。</p>
</div>
<p>定义:</p>
<blockquote>
<div>在声明的变量或参数前加上关键字 <code class="docutils literal"><span class="pre">const</span></code> 用于指明变量值不可被篡改 (如 <code class="docutils literal"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">foo</span></code> ). 为类中的函数加上 <code class="docutils literal"><span class="pre">const</span></code> 限定符表明该函数不会修改类成员变量的状态 (如 <code class="docutils literal"><span class="pre">class</span> <span class="pre">Foo</span> <span class="pre">{</span> <span class="pre">int</span> <span class="pre">Bar(char</span> <span class="pre">c)</span> <span class="pre">const;</span> <span class="pre">};</span></code>).</div></blockquote>
<p>优点:</p>
<blockquote>
<div>大家更容易理解如何使用变量. 编译器可以更好地进行类型检测, 相应地, 也能生成更好的代码. 人们对编写正确的代码更加自信, 因为他们知道所调用的函数被限定了能或不能修改变量值. 即使是在无锁的多线程编程中, 人们也知道什么样的函数是安全的.</div></blockquote>
<p>缺点:</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">const</span></code> 是入侵性的: 如果你向一个函数传入 <code class="docutils literal"><span class="pre">const</span></code> 变量, 函数原型声明中也必须对应 <code class="docutils literal"><span class="pre">const</span></code> 参数 (否则变量需要 <code class="docutils literal"><span class="pre">const_cast</span></code> 类型转换), 在调用库函数时显得尤其麻烦.</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">const</span></code> 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. 因此, 我们强烈建议在任何可能的情况下使用 <code class="docutils literal"><span class="pre">const</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li>如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 <code class="docutils literal"><span class="pre">const</span></code>.</li>
<li>尽可能将函数声明为 <code class="docutils literal"><span class="pre">const</span></code>. 访问函数应该总是 <code class="docutils literal"><span class="pre">const</span></code>. 其他不会修改任何数据成员, 未调用非 <code class="docutils literal"><span class="pre">const</span></code> 函数, 不会返回数据成员非 <code class="docutils literal"><span class="pre">const</span></code> 指针或引用的函数也应该声明成 <code class="docutils literal"><span class="pre">const</span></code>.</li>
<li>如果数据成员在对象构造之后不再发生变化, 可将其定义为 <code class="docutils literal"><span class="pre">const</span></code>.</li>
</ul>
</div></blockquote>
<p>然而, 也不要发了疯似的使用 <code class="docutils literal"><span class="pre">const</span></code>. 像 <code class="docutils literal"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">x;</span></code> 就有些过了, 虽然它非常精确的描述了常量 <code class="docutils literal"><span class="pre">x</span></code>. 关注真正有帮助意义的信息: 前面的例子写成 <code class="docutils literal"><span class="pre">const</span> <span class="pre">int**</span> <span class="pre">x</span></code> 就够了.</p>
<p>关键字 <code class="docutils literal"><span class="pre">mutable</span></code> 可以使用, 但是在多线程中是不安全的, 使用时首先要考虑线程安全.</p>
</div></blockquote>
<p><code class="docutils literal"><span class="pre">const</span></code> 的位置:</p>
<blockquote>
<div><p>有人喜欢 <code class="docutils literal"><span class="pre">int</span> <span class="pre">const</span> <span class="pre">*foo</span></code> 形式, 不喜欢 <code class="docutils literal"><span class="pre">const</span> <span class="pre">int*</span> <span class="pre">foo</span></code>, 他们认为前者更一致因此可读性也更好: 遵循了 <code class="docutils literal"><span class="pre">const</span></code> 总位于其描述的对象之后的原则. 但是一致性原则不适用于此, &#8220;不要过度使用&#8221; 的声明可以取消大部分你原本想保持的一致性. 将 <code class="docutils literal"><span class="pre">const</span></code> 放在前面才更易读, 因为在自然语言中形容词 (<code class="docutils literal"><span class="pre">const</span></code>) 是在名词 (<code class="docutils literal"><span class="pre">int</span></code>) 之前.</p>
<p>这是说, 我们提倡但不强制 <code class="docutils literal"><span class="pre">const</span></code> 在前. 但要保持代码的一致性! (Yang.Y 注: 也就是不要在一些地方把 <code class="docutils literal"><span class="pre">const</span></code> 写在类型前面, 在其他地方又写在后面, 确定一种写法, 然后保持一致.)</p>
</div></blockquote>
</div>
<div class="section" id="constexpr">
<h4>5.13. <code class="docutils literal"><span class="pre">constexpr</span></code> 用法</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p>
</div>
<p>定义:</p>
<blockquote>
<div>变量可以被声明成 constexpr 以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成 constexpr, 以用来定义 constexpr 变量。</div></blockquote>
<p>优点:</p>
<blockquote>
<div>如今 constexpr 就可以定义浮点式的真・常量，不用再依赖字面值了；也可以定义用户自定义类型上的常量；甚至也可以定义函数调用所返回的常量。</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>若过早把变量优化成 constexpr 变量，将来又要把它改为常规变量时，挺麻烦的；当前对constexpr函数和构造函数中允许的限制可能会导致这些定义中解决的方法模糊。</div></blockquote>
<p>结论:</p>
<blockquote>
<div>靠 constexpr 特性，方才实现了 C++ 在接口上打造真正常量机制的可能。好好用 constexpr 来定义真・常量以及支持常量的函数。避免复杂的函数定义，以使其能够与constexpr一起使用。 千万别痴心妄想地想靠 constexpr 来强制代码「内联」。</div></blockquote>
</div>
<div class="section" id="id11">
<h4>5.14. 整型</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">C++ 内建整型中, 仅使用 <code class="docutils literal"><span class="pre">int</span></code>. 如果程序中需要不同大小的变量, 可以使用 <code class="docutils literal"><span class="pre">&lt;stdint.h&gt;</span></code> 中长度精确的整型, 如 <code class="docutils literal"><span class="pre">int16_t</span></code>.如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如 <code class="docutils literal"><span class="pre">int64_t</span></code>. 此外要留意，哪怕您的值并不会超出 int 所能够表示的范围，在计算过程中也可能会溢出。所以拿不准时，干脆用更大的类型。</p>
</div>
<p>定义:</p>
<blockquote>
<div>C++ 没有指定整型的大小. 通常人们假定 <code class="docutils literal"><span class="pre">short</span></code> 是 16 位, <code class="docutils literal"><span class="pre">int</span></code> 是 32 位, <code class="docutils literal"><span class="pre">long</span></code> 是 32 位, <code class="docutils literal"><span class="pre">long</span> <span class="pre">long</span></code> 是 64 位.</div></blockquote>
<p>优点:</p>
<blockquote>
<div>保持声明统一.</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>C++ 中整型大小因编译器和体系结构的不同而不同.</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">&lt;stdint.h&gt;</span></code> 定义了 <code class="docutils literal"><span class="pre">int16_t</span></code>, <code class="docutils literal"><span class="pre">uint32_t</span></code>, <code class="docutils literal"><span class="pre">int64_t</span></code> 等整型, 在需要确保整型大小时可以使用它们代替 <code class="docutils literal"><span class="pre">short</span></code>, <code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> 等. 在 C 整型中, 只使用 <code class="docutils literal"><span class="pre">int</span></code>. 在合适的情况下, 推荐使用标准类型如 <code class="docutils literal"><span class="pre">size_t</span></code> 和 <code class="docutils literal"><span class="pre">ptrdiff_t</span></code>.</p>
<p>如果已知整数不会太大, 我们常常会使用 <code class="docutils literal"><span class="pre">int</span></code>, 如循环计数. 在类似的情况下使用原生类型 <code class="docutils literal"><span class="pre">int</span></code>. 你可以认为 <code class="docutils literal"><span class="pre">int</span></code> 至少为 32 位, 但不要认为它会多于 <code class="docutils literal"><span class="pre">32</span></code> 位. 如果需要 64 位整型, 用 <code class="docutils literal"><span class="pre">int64_t</span></code> 或 <code class="docutils literal"><span class="pre">uint64_t</span></code>.</p>
<p>对于大整数, 使用 <code class="docutils literal"><span class="pre">int64_t</span></code>.</p>
<p>不要使用 <code class="docutils literal"><span class="pre">uint32_t</span></code> 等无符号整型, 除非你是在表示一个位组而不是一个数值, 或是你需要定义二进制补码溢出. 尤其是不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据.</p>
<p>如果您的代码涉及容器返回的大小（size），确保其类型足以应付容器各种可能的用法。拿不准时，类型越大越好。</p>
<p>小心整型类型转换和整型提升（acgtyrant 注：integer promotions, 比如 <code class="docutils literal"><span class="pre">int</span></code> 与 <code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></code> 运算时，前者被提升为 <code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></code> 而有可能溢出），总有意想不到的后果。</p>
</div></blockquote>
<p>关于无符号整数:</p>
<blockquote>
<div><p>有些人, 包括一些教科书作者, 推荐使用无符号类型表示非负数. 这种做法试图达到自我文档化. 但是, 在 C 语言中, 这一优点被由其导致的 bug 所淹没. 看看下面的例子:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">foo</span><span class="p">.</span><span class="n">Length</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">...</span>
</pre></div>
</div>
</div></blockquote>
<p>上述循环永远不会退出! 有时 gcc 会发现该 bug 并报警, 但大部分情况下都不会. 类似的 bug 还会出现在比较有符合变量和无符号变量时. 主要是 C 的类型提升机制会致使无符号类型的行为出乎你的意料.</p>
<p>因此, 使用断言来指出变量为非负数, 而不是使用无符号型!</p>
</div></blockquote>
</div>
<div class="section" id="id12">
<h4>5.15. 64 位下的可移植性</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记:</p>
</div>
<ul>
<li><p class="first">对于某些类型, <code class="docutils literal"><span class="pre">printf()</span></code> 的指示符在 32 位和 64 位系统上可移植性不是很好. C99 标准定义了一些可移植的格式化指示符. 不幸的是, MSVC 7.1 并非全部支持, 而且标准中也有所遗漏, 所以有时我们不得不自己定义一个丑陋的版本 (头文件 <code class="docutils literal"><span class="pre">inttypes.h</span></code> 仿标准风格):</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// printf macros for size_t, in the style of inttypes.h</span>
<span class="cp">#ifdef _LP64</span>
<span class="cp">#define __PRIS_PREFIX &quot;z&quot;</span>
<span class="cp">#else</span>
<span class="cp">#define __PRIS_PREFIX</span>
<span class="cp">#endif</span>

<span class="c1">// Use these macros after a % in a printf format string</span>
<span class="c1">// to get correct 32/64 bit behavior, like this:</span>
<span class="c1">// size_t size = records.size();</span>
<span class="c1">// printf(&quot;%&quot;PRIuS&quot;\n&quot;, size);</span>
<span class="cp">#define PRIdS __PRIS_PREFIX &quot;d&quot;</span>
<span class="cp">#define PRIxS __PRIS_PREFIX &quot;x&quot;</span>
<span class="cp">#define PRIuS __PRIS_PREFIX &quot;u&quot;</span>
<span class="cp">#define PRIXS __PRIS_PREFIX &quot;X&quot;</span>
<span class="cp">#define PRIoS __PRIS_PREFIX &quot;o&quot;</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="25%" />
<col width="31%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">类型</th>
<th class="head">不要使用</th>
<th class="head">使用</th>
<th class="head">备注</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span></code>
(或其他指针类型)</td>
<td><code class="docutils literal"><span class="pre">%lx</span></code></td>
<td><code class="docutils literal"><span class="pre">%p</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">int64_t</span></code></td>
<td><code class="docutils literal"><span class="pre">%qd,</span> <span class="pre">%lld</span></code></td>
<td><code class="docutils literal"><span class="pre">%&quot;PRId64&quot;</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">uint64_t</span></code></td>
<td><code class="docutils literal"><span class="pre">%qu,</span> <span class="pre">%llu,</span> <span class="pre">%llx</span></code></td>
<td><code class="docutils literal"><span class="pre">%&quot;PRIu64&quot;,</span> <span class="pre">%&quot;PRIx64&quot;</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">size_t</span></code></td>
<td><code class="docutils literal"><span class="pre">%u</span></code></td>
<td><code class="docutils literal"><span class="pre">%&quot;PRIuS&quot;,</span> <span class="pre">%&quot;PRIxS&quot;</span></code></td>
<td>C99 规定 <code class="docutils literal"><span class="pre">%zu</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">ptrdiff_t</span></code></td>
<td><code class="docutils literal"><span class="pre">%d</span></code></td>
<td><code class="docutils literal"><span class="pre">%&quot;PRIdS&quot;</span></code></td>
<td>C99 规定 <code class="docutils literal"><span class="pre">%zd</span></code></td>
</tr>
</tbody>
</table>
<p>注意 <code class="docutils literal"><span class="pre">PRI*</span></code> 宏会被编译器扩展为独立字符串. 因此如果使用非常量的格式化字符串, 需要将宏的值而不是宏名插入格式中. 使用 <code class="docutils literal"><span class="pre">PRI*</span></code> 宏同样可以在 <code class="docutils literal"><span class="pre">%</span></code> 后包含长度指示符. 例如, <code class="docutils literal"><span class="pre">printf(&quot;x</span> <span class="pre">=</span> <span class="pre">%30&quot;PRIuS&quot;\n&quot;,</span> <span class="pre">x)</span></code> 在 32 位 Linux 上将被展开为 <code class="docutils literal"><span class="pre">printf(&quot;x</span> <span class="pre">=</span> <span class="pre">%30&quot;</span> <span class="pre">&quot;u&quot;</span> <span class="pre">&quot;\n&quot;,</span> <span class="pre">x)</span></code>, 编译器当成 <code class="docutils literal"><span class="pre">printf(&quot;x</span> <span class="pre">=</span> <span class="pre">%30u\n&quot;,</span> <span class="pre">x)</span></code> 处理 (Yang.Y 注: 这在 MSVC 6.0 上行不通, VC 6 编译器不会自动把引号间隔的多个字符串连接一个长字符串).</p>
</div></blockquote>
</li>
<li><p class="first">记住 <code class="docutils literal"><span class="pre">sizeof(void</span> <span class="pre">*)</span> <span class="pre">!=</span> <span class="pre">sizeof(int)</span></code>. 如果需要一个指针大小的整数要用 <code class="docutils literal"><span class="pre">intptr_t</span></code>.</p>
</li>
<li><p class="first">你要非常小心的对待结构体对齐, 尤其是要持久化到磁盘上的结构体 (Yang.Y 注: 持久化 - 将数据按字节流顺序保存在磁盘文件或数据库中). 在 64 位系统中, 任何含有 <code class="docutils literal"><span class="pre">int64_t</span></code>/<code class="docutils literal"><span class="pre">uint64_t</span></code> 成员的类/结构体, 缺省都以 8 字节在结尾对齐. 如果 32 位和 64 位代码要共用持久化的结构体, 需要确保两种体系结构下的结构体对齐一致. 大多数编译器都允许调整结构体对齐. gcc 中可使用 <code class="docutils literal"><span class="pre">__attribute__((packed))</span></code>. MSVC 则提供了 <code class="docutils literal"><span class="pre">#pragma</span> <span class="pre">pack()</span></code> 和 <code class="docutils literal"><span class="pre">__declspec(align())</span></code> (YuleFox 注, 解决方案的项目属性里也可以直接设置).</p>
</li>
<li><p class="first">创建 64 位常量时使用 LL 或 ULL 作为后缀, 如:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int64_t</span> <span class="n">my_value</span> <span class="o">=</span> <span class="mh">0x123456789LL</span><span class="p">;</span>
<span class="kt">uint64_t</span> <span class="n">my_mask</span> <span class="o">=</span> <span class="mi">3ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">48</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">如果你确实需要 32 位和 64 位系统具有不同代码, 可以使用 <code class="docutils literal"><span class="pre">#ifdef</span> <span class="pre">_LP64</span></code> 指令来切分 32/64 位代码. (尽量不要这么做, 如果非用不可, 尽量使修改局部化)</p>
</li>
</ul>
</div>
<div class="section" id="preprocessor-macros">
<span id="id13"></span><h4>5.16. 预处理宏</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.</p>
</div>
<p>宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为, 尤其因为宏具有全局作用域.</p>
<p>值得庆幸的是, C++ 中, 宏不像在 C 中那么必不可少. 以往用宏展开性能关键的代码, 现在可以用内联函数替代. 用宏表示常量可被 <code class="docutils literal"><span class="pre">const</span></code> 变量代替. 用宏 &#8220;缩写&#8221; 长变量名可被引用代替. 用宏进行条件编译... 这个, 千万别这么做, 会令测试更加痛苦 (<code class="docutils literal"><span class="pre">#define</span></code> 防止头文件重包含当然是个特例).</p>
<p>宏可以做一些其他技术无法实现的事情, 在一些代码库 (尤其是底层库中) 可以看到宏的某些特性 (如用 <code class="docutils literal"><span class="pre">#</span></code> 字符串化, 用 <code class="docutils literal"><span class="pre">##</span></code> 连接等等). 但在使用前, 仔细考虑一下能不能不使用宏达到同样的目的.</p>
<p>下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏, 尽可能遵守:</p>
<blockquote>
<div><ul class="simple">
<li>不要在 <code class="docutils literal"><span class="pre">.h</span></code> 文件中定义宏.</li>
<li>在马上要使用时才进行 <code class="docutils literal"><span class="pre">#define</span></code>, 使用后要立即 <code class="docutils literal"><span class="pre">#undef</span></code>.</li>
<li>不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；</li>
<li>不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.</li>
<li>不要用 <code class="docutils literal"><span class="pre">##</span></code> 处理函数，类和变量的名字。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="nullptr-null">
<h4>5.17. 0, <code class="docutils literal"><span class="pre">nullptr</span></code> 和 <code class="docutils literal"><span class="pre">NULL</span></code></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>整数用 <code class="docutils literal"><span class="pre">0</span></code>, 实数用 <code class="docutils literal"><span class="pre">0.0</span></code>, 指针用 <code class="docutils literal"><span class="pre">nullptr</span></code> 或 <code class="docutils literal"><span class="pre">NULL</span></code>, 字符 (串) 用 <code class="docutils literal"><span class="pre">'\0'</span></code>.</p>
<p>整数用 <code class="docutils literal"><span class="pre">0</span></code>, 实数用 <code class="docutils literal"><span class="pre">0.0</span></code>, 这一点是毫无争议的.</p>
<p>对于指针 (地址值), 到底是用 <code class="docutils literal"><span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">NULL</span></code> 还是 <code class="docutils literal"><span class="pre">nullptr</span></code>. C++11 项目用 <code class="docutils literal"><span class="pre">nullptr</span></code>; C++03 项目则用 <code class="docutils literal"><span class="pre">NULL</span></code>, 毕竟它看起来像指针。实际上，一些 C++ 编译器对 <code class="docutils literal"><span class="pre">NULL</span></code> 的定义比较特殊，可以输出有用的警告，特别是 <code class="docutils literal"><span class="pre">sizeof(NULL)</span></code> 就和 <code class="docutils literal"><span class="pre">sizeof(0)</span></code> 不一样。</p>
<p class="last">字符 (串) 用 <code class="docutils literal"><span class="pre">'\0'</span></code>, 不仅类型正确而且可读性好.</p>
</div>
</div>
<div class="section" id="sizeof">
<h4>5.18. sizeof</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>尽可能用 <code class="docutils literal"><span class="pre">sizeof(varname)</span></code> 代替 <code class="docutils literal"><span class="pre">sizeof(type)</span></code>.</p>
<p>使用 <code class="docutils literal"><span class="pre">sizeof(varname)</span></code> 是因为当代码中变量类型改变时会自动更新. 您或许会用 <code class="docutils literal"><span class="pre">sizeof(type)</span></code> 处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Struct</span> <span class="n">data</span><span class="p">;</span>
<span class="n">Struct</span> <span class="n">data</span><span class="p">;</span> <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++"><div class="highlight"><pre><span></span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Struct</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="last highlight-c++"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">raw_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;compressed record not big enough for count: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">raw_size</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="auto">
<h4>5.19. auto</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">用 <code class="docutils literal"><span class="pre">auto</span></code> 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。</p>
</div>
<p>定义：</p>
<blockquote>
<div><p>C++11 中，若变量被声明成 <code class="docutils literal"><span class="pre">auto</span></code>, 那它的类型就会被自动匹配成初始化表达式的类型。您可以用 <code class="docutils literal"><span class="pre">auto</span></code> 来复制初始化或绑定引用。</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">auto</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// 创建一份 v[0] 的拷贝。</span>
<span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// s2 是 v[0] 的一个引用。</span>
</pre></div>
</div>
</div></blockquote>
<p>优点：</p>
<blockquote>
<div><p>C++ 类型名有时又长又臭，特别是涉及模板或命名空间的时候。就像：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">sparse_hash_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
</pre></div>
</div>
<p>返回类型好难读，代码目的也不够一目了然。重构其：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
</pre></div>
</div>
<p>好多了。</p>
<p>没有 <code class="docutils literal"><span class="pre">auto</span></code> 的话，我们不得不在同一个表达式里写同一个类型名两次，无谓的重复，就像：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">diagnostics</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">*</span> <span class="n">status</span> <span class="o">=</span> <span class="k">new</span> <span class="n">diagnostics</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="p">(</span><span class="s">&quot;xyz&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>有了 auto, 可以更方便地用中间变量，显式编写它们的类型轻松点。</p>
</div></blockquote>
<p>缺点：</p>
<blockquote>
<div><p>类型够明显时，特别是初始化变量时，代码才会够一目了然。但以下就不一样了：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">Lookup</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</pre></div>
</div>
<p>看不出其类型是啥，x 的类型声明恐怕远在几百行之外了。</p>
<p>程序员必须会区分 <code class="docutils literal"><span class="pre">auto</span></code> 和 <code class="docutils literal"><span class="pre">const</span> <span class="pre">auto&amp;</span></code> 的不同之处，否则会复制错东西。</p>
<p>auto 和 C++11 列表初始化的合体令人摸不着头脑：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="nf">x</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>  <span class="c1">// 圆括号。</span>
<span class="k">auto</span> <span class="n">y</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span>  <span class="c1">// 大括号。</span>
</pre></div>
</div>
<p>它们不是同一回事——<code class="docutils literal"><span class="pre">x</span></code> 是 <code class="docutils literal"><span class="pre">int</span></code>, <code class="docutils literal"><span class="pre">y</span></code> 则是 <code class="docutils literal"><span class="pre">std::initializer_list&lt;int&gt;</span></code>. 其它一般不可见的代理类型（acgtyrant 注：normally-invisible proxy types, 它涉及到 C++ 鲜为人知的坑：<a class="reference external" href="http://stackoverflow.com/a/17794965/1546088">Why is vector&lt;bool&gt; not a STL container?</a>）也有大同小异的陷阱。</p>
<p>如果在接口里用 <code class="docutils literal"><span class="pre">auto</span></code>, 比如声明头文件里的一个常量，那么只要仅仅因为程序员一时修改其值而导致类型变化的话——API 要翻天覆地了。</p>
</div></blockquote>
<p>结论：</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">auto</span></code> 只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化 <code class="docutils literal"><span class="pre">auto</span></code> 变量。</p>
<p><code class="docutils literal"><span class="pre">auto</span></code> 还可以和 C++11 特性「尾置返回类型（trailing return type）」一起用，不过后者只能用在 lambda 表达式里。</p>
</div></blockquote>
</div>
<div class="section" id="braced-initializer-list">
<span id="id14"></span><h4>5.20. 列表初始化</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>你可以用列表初始化。</p>
<p>早在 C++03 里，聚合类型（aggregate types）就已经可以被列表初始化了，比如数组和不自带构造函数的结构体：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>
<span class="n">Point</span> <span class="n">p</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
</pre></div>
</div>
<p>C++11 中，该特性得到进一步的推广，任何对象类型都可以被列表初始化。示范如下：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// Vector 接收了一个初始化列表。</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">};</span>

<span class="c1">// 不考虑细节上的微妙差别，大致上相同。</span>
<span class="c1">// 您可以任选其一。</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">};</span>

<span class="c1">// 可以配合 new 一起用。</span>
<span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">{</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">};</span>

<span class="c1">// map 接收了一些 pair, 列表初始化大显神威。</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;one&quot;</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">}};</span>

<span class="c1">// 初始化列表也可以用在返回类型上的隐式转换。</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">test_function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span> <span class="p">}</span>

<span class="c1">// 初始化列表可迭代。</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">})</span> <span class="p">{}</span>

<span class="c1">// 在函数调用里用列表初始化。</span>
<span class="kt">void</span> <span class="n">TestFunction2</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
<span class="n">TestFunction2</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span>
</pre></div>
</div>
<p>用户自定义类型也可以定义接收 <code class="docutils literal"><span class="pre">std::initializer_list&lt;T&gt;</span></code> 的构造函数和赋值运算符，以自动列表初始化：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyType</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// std::initializer_list 专门接收 init 列表。</span>
  <span class="c1">// 得以值传递。</span>
  <span class="n">MyType</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">init_list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">init_list</span><span class="p">)</span> <span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">MyType</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">init_list</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">clear</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">init_list</span><span class="p">)</span> <span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="n">MyType</span> <span class="n">m</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">};</span>
</pre></div>
</div>
<p>最后，列表初始化也适用于常规数据类型的构造，哪怕没有接收 <code class="docutils literal"><span class="pre">std::initializer_list&lt;T&gt;</span></code> 的构造函数。</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">d</span><span class="p">{</span><span class="mf">1.23</span><span class="p">};</span>
<span class="c1">// MyOtherType 没有 std::initializer_list 构造函数，</span>
 <span class="c1">// 直接上接收常规类型的构造函数。</span>
<span class="k">class</span> <span class="nc">MyOtherType</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">MyOtherType</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
  <span class="n">MyOtherType</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>
<span class="p">};</span>
<span class="n">MyOtherType</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">};</span>
<span class="c1">// 不过如果构造函数是显式的（explict），您就不能用 `= {}` 了。</span>
<span class="n">MyOtherType</span> <span class="n">m</span><span class="p">{</span><span class="s">&quot;b&quot;</span><span class="p">};</span>
</pre></div>
</div>
<p>千万别直接列表初始化 auto 变量，看下一句，估计没人看得懂：</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.23</span><span class="p">};</span>        <span class="c1">// d 即是 std::initializer_list&lt;double&gt;</span>
</pre></div>
</div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="kt">double</span><span class="p">{</span><span class="mf">1.23</span><span class="p">};</span>  <span class="c1">// 善哉 -- d 即为 double, 并非 std::initializer_list.</span>
</pre></div>
</div>
<p class="last">至于格式化，参见 <a class="reference internal" href="contents.html#braced-initializer-list-format"><span class="std std-ref">9.7. 列表初始化格式</span></a>.</p>
</div>
</div>
<div class="section" id="lambda">
<span id="lambda-expressions"></span><h4>5.21. Lambda 表达式</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。</p>
</div>
<p>定义：</p>
<blockquote>
<div><p>Lambda 表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传，例如：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Weight</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Weight</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>C++11 首次提出 Lambdas, 还提供了一系列处理函数对象的工具，比如多态包装器（polymorphic wrapper） <code class="docutils literal"><span class="pre">std::function</span></code>.</p>
</div></blockquote>
<p>优点：</p>
<blockquote>
<div><ul class="simple">
<li>传函数对象给 STL 算法，Lambdas 最简易，可读性也好。</li>
<li>Lambdas, <code class="docutils literal"><span class="pre">std::functions</span></code> 和 <code class="docutils literal"><span class="pre">std::bind</span></code> 可以搭配成通用回调机制（general purpose callback mechanism）；写接收有界函数为参数的函数也很容易了。</li>
</ul>
</div></blockquote>
<p>缺点：</p>
<blockquote>
<div><ul class="simple">
<li>Lambdas 的变量捕获略旁门左道，可能会造成悬空指针。</li>
<li>Lambdas 可能会失控；层层嵌套的匿名函数难以阅读。</li>
</ul>
</div></blockquote>
<p>结论：</p>
<blockquote>
<div><ul class="simple">
<li>按 format 小用 lambda 表达式怡情。</li>
<li>禁用默认捕获，捕获都要显式写出来。打比方，比起 <code class="docutils literal"><span class="pre">[=](int</span> <span class="pre">x)</span> <span class="pre">{return</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">n;}</span></code>, 您该写成 <code class="docutils literal"><span class="pre">[n](int</span> <span class="pre">x)</span> <span class="pre">{return</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">n;}</span></code> 才对，这样读者也好一眼看出 <code class="docutils literal"><span class="pre">n</span></code> 是被捕获的值。</li>
<li>匿名函数始终要简短，如果函数体超过了五行，那么还不如起名（acgtyrant 注：即把 lambda 表达式赋值给对象），或改用函数。</li>
<li>如果可读性更好，就显式写出 lambd 的尾置返回类型，就像auto.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="template-metaprogramming">
<span id="id15"></span><h4>5.22. 模板编程</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要使用复杂的模板编程</p>
</div>
<p>定义:</p>
<blockquote>
<div>模板编程指的是利用c++ 模板实例化机制是图灵完备性, 可以被用来实现编译时刻的类型判断的一系列编程技巧</div></blockquote>
<p>优点:</p>
<blockquote>
<div>模板编程能够实现非常灵活的类型安全的接口和极好的性能, 一些常见的工具比如Google Test, std::tuple, std::function 和 Boost.Spirit. 这些工具如果没有模板是实现不了的</div></blockquote>
<p>缺点:</p>
<blockquote>
<div><ul class="simple">
<li>模板编程所使用的技巧对于使用c++不是很熟练的人是比较晦涩, 难懂的. 在复杂的地方使用模板的代码让人更不容易读懂, 并且debug 和 维护起来都很麻烦</li>
<li>模板编程经常会导致编译出错的信息非常不友好: 在代码出错的时候, 即使这个接口非常的简单, 模板内部复杂的实现细节也会在出错信息显示. 导致这个编译出错信息看起来非常难以理解.</li>
<li>大量的使用模板编程接口会让重构工具(Visual Assist X, Refactor for C++等等)更难发挥用途. 首先模板的代码会在很多上下文里面扩展开来, 所以很难确认重构对所有的这些展开的代码有用, 其次有些重构工具只对已经做过模板类型替换的代码的AST 有用. 因此重构工具对这些模板实现的原始代码并不有效, 很难找出哪些需要重构.</li>
</ul>
</div></blockquote>
<p>结论:</p>
<blockquote>
<div><ul class="simple">
<li>模板编程有时候能够实现更简洁更易用的接口, 但是更多的时候却适得其反. 因此模板编程最好只用在少量的基础组件, 基础数据结构上, 因为模板带来的额外的维护成本会被大量的使用给分担掉</li>
<li>在使用模板编程或者其他复杂的模板技巧的时候, 你一定要再三考虑一下. 考虑一下你们团队成员的平均水平是否能够读懂并且能够维护你写的模板代码.或者一个非c++ 程序员和一些只是在出错的时候偶尔看一下代码的人能够读懂这些错误信息或者能够跟踪函数的调用流程. 如果你使用递归的模板实例化, 或者类型列表, 或者元函数, 又或者表达式模板, 或者依赖SFINAE, 或者sizeof 的trick 手段来检查函数是否重载, 那么这说明你模板用的太多了, 这些模板太复杂了, 我们不推荐使用</li>
<li>如果你使用模板编程, 你必须考虑尽可能的把复杂度最小化, 并且尽量不要让模板对外暴漏. 你最好只在实现里面使用模板, 然后给用户暴露的接口里面并不使用模板, 这样能提高你的接口的可读性. 并且你应该在这些使用模板的代码上写尽可能详细的注释. 你的注释里面应该详细的包含这些代码是怎么用的, 这些模板生成出来的代码大概是什么样子的. 还需要额外注意在用户错误使用你的模板代码的时候需要输出更人性化的出错信息. 因为这些出错信息也是你的接口的一部分, 所以你的代码必须调整到这些错误信息在用户看起来应该是非常容易理解, 并且用户很容易知道如何修改这些错误</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="boost">
<span id="id16"></span><h4>5.23. Boost 库</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只使用 Boost 中被认可的库.</p>
</div>
<p>定义:</p>
<blockquote>
<div><a class="reference external" href="http://www.boost.org/">Boost 库集</a> 是一个广受欢迎, 经过同行鉴定, 免费开源的 C++ 库集.</div></blockquote>
<p>优点:</p>
<blockquote>
<div>Boost代码质量普遍较高, 可移植性好, 填补了 C++ 标准库很多空白, 如型别的特性, 更完善的绑定器, 更好的智能指针。</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>某些 Boost 库提倡的编程实践可读性差, 比如元编程和其他高级模板技术, 以及过度 &#8220;函数化&#8221; 的编程风格.</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p>为了向阅读和维护代码的人员提供更好的可读性, 我们只允许使用 Boost 一部分经认可的特性子集. 目前允许使用以下库:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://www.boost.org/doc/libs/1_58_0/libs/utility/call_traits.htm">Call Traits</a> : <code class="docutils literal"><span class="pre">boost/call_traits.hpp</span></code></li>
<li><a class="reference external" href="http://www.boost.org/libs/utility/compressed_pair.htm">Compressed Pair</a> : <code class="docutils literal"><span class="pre">boost/compressed_pair.hpp</span></code></li>
<li><a class="reference external" href="http://www.boost.org/doc/libs/1_58_0/libs/graph/doc/index.html">&lt;The Boost Graph Library (BGL)</a> : <code class="docutils literal"><span class="pre">boost/graph</span></code>, except serialization (<code class="docutils literal"><span class="pre">adj_list_serialize.hpp</span></code>) and parallel/distributed algorithms and data structures(<code class="docutils literal"><span class="pre">boost/graph/parallel/*</span></code> and <code class="docutils literal"><span class="pre">boost/graph/distributed/*</span></code>)</li>
<li><a class="reference external" href="http://www.boost.org/libs/property_map/">Property Map</a> : <code class="docutils literal"><span class="pre">boost/property_map.hpp</span></code></li>
<li>The part of <a class="reference external" href="http://www.boost.org/libs/iterator/">Iterator</a> that deals with defining iterators: <code class="docutils literal"><span class="pre">boost/iterator/iterator_adaptor.hpp</span></code>, <code class="docutils literal"><span class="pre">boost/iterator/iterator_facade.hpp</span></code>, and <code class="docutils literal"><span class="pre">boost/function_output_iterator.hpp</span></code></li>
<li>The part of <a class="reference external" href="http://www.boost.org/libs/polygon/">Polygon</a> that deals with Voronoi diagram construction and doesn&#8217;t depend on the rest of Polygon: <code class="docutils literal"><span class="pre">boost/polygon/voronoi_builder.hpp</span></code>, <code class="docutils literal"><span class="pre">boost/polygon/voronoi_diagram.hpp</span></code>, and <code class="docutils literal"><span class="pre">boost/polygon/voronoi_geometry_type.hpp</span></code></li>
<li><a class="reference external" href="http://www.boost.org/libs/bimap/">Bimap</a> : <code class="docutils literal"><span class="pre">boost/bimap</span></code></li>
<li><a class="reference external" href="http://www.boost.org/libs/math/doc/html/dist.html">Statistical Distributions and Functions</a> : <code class="docutils literal"><span class="pre">boost/math/distributions</span></code></li>
<li><a class="reference external" href="http://www.boost.org/libs/multi_index/">Multi-index</a> : <code class="docutils literal"><span class="pre">boost/multi_index</span></code></li>
<li><a class="reference external" href="http://www.boost.org/libs/heap/">Heap</a> : <code class="docutils literal"><span class="pre">boost/heap</span></code></li>
<li>The flat containers from <a class="reference external" href="http://www.boost.org/libs/container/">Container</a>: <code class="docutils literal"><span class="pre">boost/container/flat_map</span></code>, and <code class="docutils literal"><span class="pre">boost/container/flat_set</span></code></li>
</ul>
</div></blockquote>
<p>我们正在积极考虑增加其它 Boost 特性, 所以列表中的规则将不断变化.</p>
<p>以下库可以用，但由于如今已经被 C++ 11 标准库取代，不再鼓励：</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://www.boost.org/libs/ptr_container/">Pointer Container</a> : <code class="docutils literal"><span class="pre">boost/ptr_container</span></code>, 改用 <a class="reference external" href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a></li>
<li><a class="reference external" href="http://www.boost.org/libs/array/">Array</a> : <code class="docutils literal"><span class="pre">boost/array.hpp</span></code>, 改用 <a class="reference external" href="http://en.cppreference.com/w/cpp/container/array">std::array</a></li>
</ul>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="c-11">
<h4>5.24. C++11</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">适当用 C++11（前身是 C++0x）的库和语言扩展，在贵项目用 C++11 特性前三思可移植性。</p>
</div>
<p>定义：</p>
<blockquote>
<div>C++11 有众多语言和库上的`变革 &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/C%2B%2B11">https://en.wikipedia.org/wiki/C%2B%2B11</a>&gt;`_ 。</div></blockquote>
<p>优点：</p>
<blockquote>
<div>在二〇一四年八月之前，C++11 一度是官方标准，被大多 C++ 编译器支持。它标准化很多我们早先就在用的 C++ 扩展，简化了不少操作，大大改善了性能和安全。</div></blockquote>
<p>缺点：</p>
<blockquote>
<div><p>C++11 相对于前身，复杂极了：1300 页 vs 800 页！很多开发者也不怎么熟悉它。于是从长远来看，前者特性对代码可读性以及维护代价难以预估。我们说不准什么时候采纳其特性，特别是在被迫依赖老实工具的项目上。</p>
<p>和 <a class="reference internal" href="#boost"><span class="std std-ref">5.23. Boost 库</span></a> 一样，有些 C++11 扩展提倡实则对可读性有害的编程实践——就像去除冗余检查（比如类型名）以帮助读者，或是鼓励模板元编程等等。有些扩展在功能上与原有机制冲突，容易招致困惑以及迁移代价。</p>
</div></blockquote>
<p>缺点：</p>
<blockquote>
<div><p>C++11 特性除了个别情况下，可以用一用。除了本指南会有不少章节会加以讨若干 C++11 特性之外，以下特性最好不要用：</p>
<ul class="simple">
<li>尾置返回类型，比如用 <code class="docutils literal"><span class="pre">auto</span> <span class="pre">foo()</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code> 代替 <code class="docutils literal"><span class="pre">int</span> <span class="pre">foo()</span></code>. 为了兼容于现有代码的声明风格。</li>
<li>编译时合数 <code class="docutils literal"><span class="pre">&lt;ratio&gt;</span></code>, 因为它涉及一个重模板的接口风格。</li>
<li><code class="docutils literal"><span class="pre">&lt;cfenv&gt;</span></code> 和 <code class="docutils literal"><span class="pre">&lt;fenv.h&gt;</span></code> 头文件，因为编译器尚不支持。</li>
<li>默认 lambda 捕获。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="acgtyrant">
<h4>译者（acgtyrant）笔记</h4>
<ol class="arabic simple">
<li>实际上，<a class="reference external" href="http://www.zhihu.com/question/24439516/answer/27858964">缺省参数会改变函数签名的前提是改变了它接收的参数数量</a>，比如把 <code class="docutils literal"><span class="pre">void</span> <span class="pre">a()</span></code> 改成 <code class="docutils literal"><span class="pre">void</span> <span class="pre">a(int</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">0)</span></code>, 开发者改变其代码的初衷也许是，在不改变「代码兼容性」的同时，又提供了可选 int 参数的余地，然而这终究会破坏函数指针上的兼容性，毕竟函数签名确实变了。</li>
<li>此外把自带缺省参数的函数地址赋值给指针时，会丢失缺省参数信息。</li>
<li>我还发现 <a class="reference external" href="http://www.zhihu.com/question/24439516/answer/27896004">滥用缺省参数会害得读者光只看调用代码的话，会误以为其函数接受的参数数量比实际上还要少。</a></li>
<li><code class="docutils literal"><span class="pre">friend</span></code> 实际上只对函数／类赋予了对其所在类的访问权限，并不是有效的声明语句。所以除了在头文件类内部写 friend 函数／类，还要在类作用域之外正式地声明一遍，最后在对应的 <code class="docutils literal"><span class="pre">.cc</span></code> 文件加以定义。</li>
<li>本风格指南都强调了「友元应该定义在同一文件内，避免代码读者跑到其它文件查找使用该私有成员的类」。那么可以把其声明放在类声明所在的头文件，定义也放在类定义所在的文件。</li>
<li>由于友元函数／类并不是类的一部分，自然也不会是类可调用的公有接口，于是我主张全集中放在类的尾部，即的数据成员之后，参考 <a class="reference internal" href="contents.html#declaration-order"><span class="std std-ref">声明顺序</span></a> 。</li>
<li><a class="reference external" href="http://www.zhihu.com/question/22889420">对使用 C++ 异常处理应具有怎样的态度？</a> 非常值得一读。</li>
<li>注意初始化 const 对象时，必须在初始化的同时值初始化。</li>
<li>用断言代替无符号整型类型，深有启发。</li>
<li>auto 在涉及迭代器的循环语句里挺常用。</li>
<li><a class="reference external" href="http://stackoverflow.com/questions/11215227/should-the-trailing-return-type-syntax-style-become-the-default-for-new-c11-pr">Should the trailing return type syntax style become the default for new C++11 programs?</a> 讨论了 auto 与尾置返回类型一起用的全新编码风格，值得一看。</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/naming"></span><div class="section" id="id1">
<h3>7. 命名约定</h3>
<p>最重要的一致性规则是命名管理. 命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义: 类型, 变量, 函数, 常量, 宏, 等等, 甚至. 我们大脑中的模式匹配引擎非常依赖这些命名规则.</p>
<p>命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重要, 所以无论你认为它们是否重要, 规则总归是规则.</p>
<div class="section" id="general-naming-rules">
<span id="id2"></span><h4>7.1. 通用命名规则</h4>
<p><strong>总述</strong></p>
<p>函数命名, 变量命名, 文件命名要有描述性; 少用缩写.</p>
<p><strong>说明</strong></p>
<p>尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">price_count_reader</span><span class="p">;</span>    <span class="c1">// 无缩写</span>
<span class="kt">int</span> <span class="n">num_errors</span><span class="p">;</span>            <span class="c1">// &quot;num&quot; 是一个常见的写法</span>
<span class="kt">int</span> <span class="n">num_dns_connections</span><span class="p">;</span>   <span class="c1">// 人人都知道 &quot;DNS&quot; 是什么</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>                     <span class="c1">// 毫无意义.</span>
<span class="kt">int</span> <span class="n">nerr</span><span class="p">;</span>                  <span class="c1">// 含糊不清的缩写.</span>
<span class="kt">int</span> <span class="n">n_comp_conns</span><span class="p">;</span>          <span class="c1">// 含糊不清的缩写.</span>
<span class="kt">int</span> <span class="n">wgc_connections</span><span class="p">;</span>       <span class="c1">// 只有贵团队知道是什么意思.</span>
<span class="kt">int</span> <span class="n">pc_reader</span><span class="p">;</span>             <span class="c1">// &quot;pc&quot; 有太多可能的解释了.</span>
<span class="kt">int</span> <span class="n">cstmr_id</span><span class="p">;</span>              <span class="c1">// 删减了若干字母.</span>
</pre></div>
</div>
<p>注意, 一些特定的广为人知的缩写是允许的, 例如用 <code class="docutils literal"><span class="pre">i</span></code> 表示迭代变量和用 <code class="docutils literal"><span class="pre">T</span></code> 表示模板参数.</p>
<p>模板参数的命名应当遵循对应的分类: 类型模板参数应当遵循 <a class="reference internal" href="#type-names"><span class="std std-ref">类型命名</span></a> 的规则, 而非类型模板应当遵循 <a class="reference internal" href="#variable-names"><span class="std std-ref">变量命名</span></a> 的规则.</p>
</div>
<div class="section" id="id3">
<h4>7.2. 文件命名</h4>
<p><strong>总述</strong></p>
<p>文件名要全部小写, 可以包含下划线 (<code class="docutils literal"><span class="pre">_</span></code>) 或连字符 (<code class="docutils literal"><span class="pre">-</span></code>), 依照项目的约定. 如果没有约定, 那么 &#8220;<code class="docutils literal"><span class="pre">_</span></code>&#8221; 更好.</p>
<p><strong>说明</strong></p>
<p>可接受的文件命名示例:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">my_useful_class.cc</span></code></li>
<li><code class="docutils literal"><span class="pre">my-useful-class.cc</span></code></li>
<li><code class="docutils literal"><span class="pre">myusefulclass.cc</span></code></li>
<li><code class="docutils literal"><span class="pre">myusefulclass_test.cc</span></code> // <code class="docutils literal"><span class="pre">_unittest</span></code> 和 <code class="docutils literal"><span class="pre">_regtest</span></code> 已弃用.</li>
</ul>
<p>C++ 文件要以 <code class="docutils literal"><span class="pre">.cc</span></code> 结尾, 头文件以 <code class="docutils literal"><span class="pre">.h</span></code> 结尾. 专门插入文本的文件则以 <code class="docutils literal"><span class="pre">.inc</span></code> 结尾, 参见 <a class="reference internal" href="contents.html#self-contained-headers"><span class="std std-ref">头文件自足</span></a>.</p>
<p>不要使用已经存在于 <code class="docutils literal"><span class="pre">/usr/include</span></code> 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如 <code class="docutils literal"><span class="pre">db.h</span></code>.</p>
<p>通常应尽量让文件名更加明确. <code class="docutils literal"><span class="pre">http_server_logs.h</span></code> 就比 <code class="docutils literal"><span class="pre">logs.h</span></code> 要好. 定义类时文件名一般成对出现, 如 <code class="docutils literal"><span class="pre">foo_bar.h</span></code> 和 <code class="docutils literal"><span class="pre">foo_bar.cc</span></code>, 对应于类 <code class="docutils literal"><span class="pre">FooBar</span></code>.</p>
<p>内联函数必须放在 <code class="docutils literal"><span class="pre">.h</span></code> 文件中. 如果内联函数比较短, 就直接放在 <code class="docutils literal"><span class="pre">.h</span></code> 中.</p>
</div>
<div class="section" id="type-names">
<span id="id4"></span><h4>7.3. 类型命名</h4>
<p><strong>总述</strong></p>
<p>类型名称的每个单词首字母均大写, 不包含下划线: <code class="docutils literal"><span class="pre">MyExcitingClass</span></code>, <code class="docutils literal"><span class="pre">MyExcitingEnum</span></code>.</p>
<p><strong>说明</strong></p>
<p>所有类型命名 —— 类, 结构体, 类型定义 (<code class="docutils literal"><span class="pre">typedef</span></code>), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. 例如:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 类和结构体</span>
<span class="k">class</span> <span class="nc">UrlTable</span> <span class="p">{</span> <span class="p">...</span>
<span class="k">class</span> <span class="nc">UrlTableTester</span> <span class="p">{</span> <span class="p">...</span>
<span class="k">struct</span> <span class="n">UrlTableProperties</span> <span class="p">{</span> <span class="p">...</span>

<span class="c1">// 类型定义</span>
<span class="k">typedef</span> <span class="n">hash_map</span><span class="o">&lt;</span><span class="n">UrlTableProperties</span> <span class="o">*</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">PropertiesMap</span><span class="p">;</span>

<span class="c1">// using 别名</span>
<span class="k">using</span> <span class="n">PropertiesMap</span> <span class="o">=</span> <span class="n">hash_map</span><span class="o">&lt;</span><span class="n">UrlTableProperties</span> <span class="o">*</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// 枚举</span>
<span class="k">enum</span> <span class="n">UrlTableErrors</span> <span class="p">{</span> <span class="p">...</span>
</pre></div>
</div>
</div>
<div class="section" id="variable-names">
<span id="id5"></span><h4>7.4. 变量命名</h4>
<p><strong>总述</strong></p>
<p>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: <code class="docutils literal"><span class="pre">a_local_variable</span></code>, <code class="docutils literal"><span class="pre">a_struct_data_member</span></code>, <code class="docutils literal"><span class="pre">a_class_data_member_</span></code>.</p>
<p><strong>说明</strong></p>
<div class="section" id="id6">
<h5>普通变量命名</h5>
<p>举例:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">string</span> <span class="n">table_name</span><span class="p">;</span>  <span class="c1">// 好 - 用下划线.</span>
<span class="n">string</span> <span class="n">tablename</span><span class="p">;</span>   <span class="c1">// 好 - 全小写.</span>

<span class="n">string</span> <span class="n">tableName</span><span class="p">;</span>  <span class="c1">// 差 - 混合大小写</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h5>类数据成员</h5>
<p>不管是静态的还是非静态的, 类数据成员都可以和普通变量一样, 但要接下划线.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TableInfo</span> <span class="p">{</span>
  <span class="p">...</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="n">string</span> <span class="n">table_name_</span><span class="p">;</span>  <span class="c1">// 好 - 后加下划线.</span>
  <span class="n">string</span> <span class="n">tablename_</span><span class="p">;</span>   <span class="c1">// 好.</span>
  <span class="k">static</span> <span class="n">Pool</span><span class="o">&lt;</span><span class="n">TableInfo</span><span class="o">&gt;*</span> <span class="n">pool_</span><span class="p">;</span>  <span class="c1">// 好.</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h5>结构体变量</h5>
<p>不管是静态的还是非静态的, 结构体数据成员都可以和普通变量一样, 不用像类那样接下划线:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">UrlTableProperties</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">num_entries</span><span class="p">;</span>
  <span class="k">static</span> <span class="n">Pool</span><span class="o">&lt;</span><span class="n">UrlTableProperties</span><span class="o">&gt;*</span> <span class="n">pool</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>结构体与类的使用讨论, 参考 <a class="reference internal" href="contents.html#structs-vs-classes"><span class="std std-ref">结构体 vs. 类</span></a>.</p>
</div>
</div>
<div class="section" id="constant-names">
<span id="id9"></span><h4>7.5. 常量命名</h4>
<p><strong>总述</strong></p>
<p>声明为 <code class="docutils literal"><span class="pre">constexpr</span></code> 或 <code class="docutils literal"><span class="pre">const</span></code> 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 &#8220;k&#8221; 开头, 大小写混合. 例如:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">kDaysInAWeek</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
</pre></div>
</div>
<p><strong>说明</strong></p>
<p>所有具有静态存储类型的变量 (例如静态变量或全局变量, 参见 <a class="reference external" href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">存储类型</a>) 都应当以此方式命名. 对于其他存储类型的变量, 如自动变量等, 这条规则是可选的. 如果不采用这条规则, 就按照一般的变量命名规则.</p>
</div>
<div class="section" id="function-names">
<span id="id11"></span><h4>7.7. 函数命名</h4>
<p><strong>总述</strong></p>
<p>常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: <code class="docutils literal"><span class="pre">MyExcitingFunction()</span></code>, <code class="docutils literal"><span class="pre">MyExcitingMethod()</span></code>, <code class="docutils literal"><span class="pre">my_exciting_member_variable()</span></code>, <code class="docutils literal"><span class="pre">set_my_exciting_member_variable()</span></code>.</p>
<p><strong>说明</strong></p>
<p>一般来说, 函数名的每个单词首字母大写 (即 &#8220;驼峰变量名&#8221; 或 &#8220;帕斯卡变量名&#8221;), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 <code class="docutils literal"><span class="pre">StartRpc()</span></code> 而非 <code class="docutils literal"><span class="pre">StartRPC()</span></code>).</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">AddTableEntry</span><span class="p">()</span>
<span class="n">DeleteUrl</span><span class="p">()</span>
<span class="n">OpenFileOrDie</span><span class="p">()</span>
</pre></div>
</div>
<p>(同样的命名规则同时适用于类作用域与命名空间作用域的常量, 因为它们是作为 API 的一部分暴露对外的, 因此应当让它们看起来像是一个函数, 因为在这时, 它们实际上是一个对象而非函数的这一事实对外不过是一个无关紧要的实现细节.)</p>
<p>取值和设值函数的命名与变量一致. 一般来说它们的名称与实际的成员变量对应, 但并不强制要求. 例如 <code class="docutils literal"><span class="pre">int</span> <span class="pre">count()</span></code> 与 <code class="docutils literal"><span class="pre">void</span> <span class="pre">set_count(int</span> <span class="pre">count)</span></code>.</p>
</div>
<div class="section" id="id12">
<h4>7.7. 命名空间命名</h4>
<p><strong>总述</strong></p>
<p>命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.</p>
<p>顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中.</p>
<p>注意 <a class="reference internal" href="#general-naming-rules"><span class="std std-ref">不使用缩写作为名称</span></a> 的规则同样适用于命名空间. 命名空间中的代码极少需要涉及命名空间的名称, 因此没有必要在命名空间中使用缩写.</p>
<p>要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突. 由于名称查找规则的存在, 命名空间之间的冲突完全有可能导致编译失败. 尤其是, 不要创建嵌套的 <code class="docutils literal"><span class="pre">std</span></code> 命名空间. 建议使用更独特的项目标识符 (<code class="docutils literal"><span class="pre">websearch::index</span></code>, <code class="docutils literal"><span class="pre">websearch::index_util</span></code>) 而非常见的极易发生冲突的名称 (比如 <code class="docutils literal"><span class="pre">websearch::util</span></code>).</p>
<p>对于 <code class="docutils literal"><span class="pre">internal</span></code> 命名空间, 要当心加入到同一 <code class="docutils literal"><span class="pre">internal</span></code> 命名空间的代码之间发生冲突 (由于内部维护人员通常来自同一团队, 因此常有可能导致冲突). 在这种情况下, 请使用文件名以使得内部名称独一无二 (例如对于 <code class="docutils literal"><span class="pre">frobber.h</span></code>, 使用 <code class="docutils literal"><span class="pre">websearch::index::frobber_internal</span></code>).</p>
</div>
<div class="section" id="id13">
<h4>7.8. 枚举命名</h4>
<p><strong>总述</strong></p>
<p>枚举的命名应当和 <a class="reference internal" href="#constant-names"><span class="std std-ref">常量</span></a> 或 <a class="reference internal" href="#macro-names"><span class="std std-ref">宏</span></a> 一致: <code class="docutils literal"><span class="pre">kEnumName</span></code> 或是 <code class="docutils literal"><span class="pre">ENUM_NAME</span></code>.</p>
<p><strong>说明</strong></p>
<p>单独的枚举值应该优先采用 <a class="reference internal" href="#constant-names"><span class="std std-ref">常量</span></a> 的命名方式. 但 <a class="reference internal" href="#macro-names"><span class="std std-ref">宏</span></a> 方式的命名也可以接受. 枚举名 <code class="docutils literal"><span class="pre">UrlTableErrors</span></code> (以及 <code class="docutils literal"><span class="pre">AlternateUrlTableErrors</span></code>) 是类型, 所以要用大小写混合的方式.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">UrlTableErrors</span> <span class="p">{</span>
    <span class="n">kOK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">kErrorOutOfMemory</span><span class="p">,</span>
    <span class="n">kErrorMalformedInput</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">enum</span> <span class="n">AlternateUrlTableErrors</span> <span class="p">{</span>
    <span class="n">OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">OUT_OF_MEMORY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">MALFORMED_INPUT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>2009 年 1 月之前, 我们一直建议采用 <a class="reference internal" href="#macro-names"><span class="std std-ref">宏</span></a> 的方式命名枚举值. 由于枚举值和宏之间的命名冲突, 直接导致了很多问题. 由此, 这里改为优先选择常量风格的命名方式. 新代码应该尽可能优先使用常量风格. 但是老代码没必要切换到常量风格, 除非宏风格确实会产生编译期问题.</p>
</div>
<div class="section" id="macro-names">
<span id="id14"></span><h4>7.9. 宏命名</h4>
<p><strong>总述</strong></p>
<p>你并不打算 <a class="reference internal" href="contents.html#preprocessor-macros"><span class="std std-ref">使用宏</span></a>, 对吧? 如果你一定要用, 像这样命名: <code class="docutils literal"><span class="pre">MY_MACRO_THAT_SCARES_SMALL_CHILDREN</span></code>.</p>
<p><strong>说明</strong></p>
<p>参考 <a class="reference internal" href="contents.html#preprocessor-macros"><span class="std std-ref">预处理宏</span></a>; 通常 <em>不应该</em> 使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#define ROUND(x) ...</span>
<span class="cp">#define PI_ROUNDED 3.0</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h4>7.10. 命名规则的特例</h4>
<p><strong>总述</strong></p>
<p>如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略.</p>
<p><code class="docutils literal"><span class="pre">bigopen()</span></code>: 函数名, 参照 <code class="docutils literal"><span class="pre">open()</span></code> 的形式</p>
<p><code class="docutils literal"><span class="pre">uint</span></code>: <code class="docutils literal"><span class="pre">typedef</span></code></p>
<p><code class="docutils literal"><span class="pre">bigpos</span></code>: <code class="docutils literal"><span class="pre">struct</span></code> 或 <code class="docutils literal"><span class="pre">class</span></code>, 参照 <code class="docutils literal"><span class="pre">pos</span></code> 的形式</p>
<p><code class="docutils literal"><span class="pre">sparse_hash_map</span></code>: STL 型实体; 参照 STL 命名约定</p>
<p><code class="docutils literal"><span class="pre">LONGLONG_MAX</span></code>: 常量, 如同 <code class="docutils literal"><span class="pre">INT_MAX</span></code></p>
</div>
<div class="section" id="acgtyrant">
<h4>译者（acgtyrant）笔记</h4>
<ol class="arabic simple">
<li>感觉 Google 的命名约定很高明, 比如写了简单的类 QueryResult, 接着又可以直接定义一个变量 query_result, 区分度很好; 再次, 类内变量以下划线结尾, 那么就可以直接传入同名的形参, 比如 <code class="docutils literal"><span class="pre">TextQuery::TextQuery(std::string</span> <span class="pre">word)</span> <span class="pre">:</span> <span class="pre">word_(word)</span> <span class="pre">{}</span></code> , 其中 <code class="docutils literal"><span class="pre">word_</span></code> 自然是类内私有成员.</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/comments"></span><div class="section" id="id1">
<h3>8. 注释</h3>
<p>注释虽然写起来很痛苦, 但对保证代码可读性至关重要. 下面的规则描述了如何注释以及在哪儿注释. 当然也要记住: 注释固然很重要, 但最好的代码应当本身就是文档. 有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字.</p>
<p>你写的注释是给代码读者看的, 也就是下一个需要理解你的代码的人. 所以慷慨些吧, 下一个读者可能就是你!</p>
<div class="section" id="id2">
<h4>8.1. 注释风格</h4>
<p><strong>总述</strong></p>
<p>使用 <code class="docutils literal"><span class="pre">//</span></code> 或 <code class="docutils literal"><span class="pre">/*</span> <span class="pre">*/</span></code>, 统一就好.</p>
<p><strong>说明</strong></p>
<p><code class="docutils literal"><span class="pre">//</span></code> 或 <code class="docutils literal"><span class="pre">/*</span> <span class="pre">*/</span></code> 都可以; 但 <code class="docutils literal"><span class="pre">//</span></code> <em>更</em> 常用. 要在如何注释及注释风格上确保统一.</p>
</div>
<div class="section" id="id3">
<h4>8.2. 文件注释</h4>
<p><strong>总述</strong></p>
<p>在每一个文件开头加入版权公告.</p>
<p>文件注释描述了该文件的内容. 如果一个文件只声明, 或实现, 或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么就没必要再加上文件注释. 除此之外的其他文件都需要文件注释.</p>
<p><strong>说明</strong></p>
<div class="section" id="id4">
<h5>法律公告和作者信息</h5>
<p>每个文件都应该包含许可证引用. 为项目选择合适的许可证版本.(比如, Apache 2.0, BSD, LGPL, GPL)</p>
<p>如果你对原始作者的文件做了重大修改, 请考虑删除原作者信息.</p>
</div>
<div class="section" id="id5">
<h5>文件内容</h5>
<p>如果一个 <code class="docutils literal"><span class="pre">.h</span></code> 文件声明了多个概念, 则文件注释应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系. 一个一到两行的文件注释就足够了, 对于每个概念的详细文档应当放在各个概念中, 而不是文件注释中.</p>
<p>不要在 <code class="docutils literal"><span class="pre">.h</span></code> 和 <code class="docutils literal"><span class="pre">.cc</span></code> 之间复制注释, 这样的注释偏离了注释的实际意义.</p>
</div>
</div>
<div class="section" id="class-comments">
<span id="id6"></span><h4>8.3. 类注释</h4>
<p><strong>总述</strong></p>
<p>每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// Iterates over the contents of a GargantuanTable.</span>
<span class="c1">// Example:</span>
<span class="c1">//    GargantuanTableIterator* iter = table-&gt;NewIterator();</span>
<span class="c1">//    for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) {</span>
<span class="c1">//      process(iter-&gt;key(), iter-&gt;value());</span>
<span class="c1">//    }</span>
<span class="c1">//    delete iter;</span>
<span class="k">class</span> <span class="nc">GargantuanTableIterator</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p><strong>说明</strong></p>
<p>类注释应当为读者理解如何使用与何时使用类提供足够的信息, 同时应当提醒读者在正确使用此类时应当考虑的因素. 如果类有任何同步前提, 请用文档说明. 如果该类的实例可被多线程访问, 要特别注意文档说明多线程环境下相关的规则和常量使用.</p>
<p>如果你想用一小段代码演示这个类的基本用法或通常用法, 放在类注释里也非常合适.</p>
<p>如果类的声明和定义分开了(例如分别放在了 <code class="docutils literal"><span class="pre">.h</span></code> 和 <code class="docutils literal"><span class="pre">.cc</span></code> 文件中), 此时, 描述类用法的注释应当和接口定义放在一起, 描述类的操作和实现的注释应当和实现放在一起.</p>
</div>
<div class="section" id="id7">
<h4>8.4. 函数注释</h4>
<p><strong>总述</strong></p>
<p>函数声明处的注释描述函数功能; 定义处的注释描述函数实现.</p>
<p><strong>说明</strong></p>
<div class="section" id="id8">
<h5>函数声明</h5>
<p>基本上每个函数声明处前都应当加上注释, 描述函数的功能和用途. 只有在函数的功能简单而明显时才能省略这些注释(例如, 简单的取值和设值函数). 注释使用叙述式 (&#8220;Opens the file&#8221;) 而非指令式 (&#8220;Open the file&#8221;); 注释只是为了描述函数, 而不是命令函数做什么. 通常, 注释不会描述函数如何工作. 那是函数定义部分的事情.</p>
<p>函数声明处注释的内容:</p>
<ul class="simple">
<li>函数的输入输出.</li>
<li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.</li>
<li>函数是否分配了必须由调用者释放的空间.</li>
<li>参数是否可以为空指针.</li>
<li>是否存在函数使用上的性能隐患.</li>
<li>如果函数是可重入的, 其同步前提是什么?</li>
</ul>
<p>举例如下:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// Returns an iterator for this table.  It is the client&#39;s</span>
<span class="c1">// responsibility to delete the iterator when it is done with it,</span>
<span class="c1">// and it must not use the iterator once the GargantuanTable object</span>
<span class="c1">// on which the iterator was created has been deleted.</span>
<span class="c1">//</span>
<span class="c1">// The iterator is initially positioned at the beginning of the table.</span>
<span class="c1">//</span>
<span class="c1">// This method is equivalent to:</span>
<span class="c1">//    Iterator* iter = table-&gt;NewIterator();</span>
<span class="c1">//    iter-&gt;Seek(&quot;&quot;);</span>
<span class="c1">//    return iter;</span>
<span class="c1">// If you are going to immediately seek to another place in the</span>
<span class="c1">// returned iterator, it will be faster to use NewIterator()</span>
<span class="c1">// and avoid the extra seek.</span>
<span class="n">Iterator</span><span class="o">*</span> <span class="nf">GetIterator</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>但也要避免罗罗嗦嗦, 或者对显而易见的内容进行说明. 下面的注释就没有必要加上 &#8220;否则返回 false&#8221;, 因为已经暗含其中了:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// Returns true if the table cannot hold any more entries.</span>
<span class="kt">bool</span> <span class="nf">IsTableFull</span><span class="p">();</span>
</pre></div>
</div>
<p>注释函数重载时, 注释的重点应该是函数中被重载的部分, 而不是简单的重复被重载的函数的注释. 多数情况下, 函数重载不需要额外的文档, 因此也没有必要加上注释.</p>
<p>注释构造/析构函数时, 切记读代码的人知道构造/析构函数的功能, 所以 &#8220;销毁这一对象&#8221; 这样的注释是没有意义的. 你应当注明的是注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的.</p>
</div>
<div class="section" id="id9">
<h5>函数定义</h5>
<p>如果函数的实现过程中用到了很巧妙的方式, 那么在函数定义处应当加上解释性的注释. 例如, 你所使用的编程技巧, 实现的大致步骤, 或解释如此实现的理由. 举个例子, 你可以说明为什么函数的前半部分要加锁而后半部分不需要.</p>
<p><em>不要</em> 从 <code class="docutils literal"><span class="pre">.h</span></code> 文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的, 但注释重点要放在如何实现上.</p>
</div>
</div>
<div class="section" id="id10">
<h4>8.5. 变量注释</h4>
<p><strong>总述</strong></p>
<p>通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p>
<p><strong>说明</strong></p>
<div class="section" id="id11">
<h5>类数据成员</h5>
<p>每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果有非变量的参数(例如特殊值, 数据成员之间的关系, 生命周期等)不能够用类型与变量名明确表达, 则应当加上注释. 然而, 如果变量类型与变量名已经足以描述一个变量, 那么就不再需要加上注释.</p>
<p>特别地, 如果变量可以接受 <code class="docutils literal"><span class="pre">NULL</span></code> 或 <code class="docutils literal"><span class="pre">-1</span></code> 等警戒值, 须加以说明. 比如:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">private</span><span class="o">:</span>
 <span class="c1">// Used to bounds-check table accesses. -1 means</span>
 <span class="c1">// that we don&#39;t yet know how many entries the table has.</span>
 <span class="kt">int</span> <span class="n">num_total_entries_</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h5>全局变量</h5>
<p>和数据成员一样, 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因. 比如:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// The total number of tests cases that we run through in this regression test.</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">kNumTestCases</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id13">
<h4>8.6. 实现注释</h4>
<p><strong>总述</strong></p>
<p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</p>
<p><strong>说明</strong></p>
<div class="section" id="id14">
<h5>代码前注释</h5>
<p>巧妙或复杂的代码段前要加注释. 比如:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// Divide result by two, taking into account that x</span>
<span class="c1">// contains the carry from the add.</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">x</span> <span class="o">&amp;=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h5>行注释</h5>
<p>比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// If we have enough memory, mmap the data portion too.</span>
<span class="n">mmap_budget</span> <span class="o">=</span> <span class="n">max</span><span class="o">&lt;</span><span class="n">int64</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mmap_budget</span> <span class="o">-</span> <span class="n">index_</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">());</span>
<span class="k">if</span> <span class="p">(</span><span class="n">mmap_budget</span> <span class="o">&gt;=</span> <span class="n">data_size_</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">MmapData</span><span class="p">(</span><span class="n">mmap_chunk_bytes</span><span class="p">,</span> <span class="n">mlock</span><span class="p">))</span>
  <span class="k">return</span><span class="p">;</span>  <span class="c1">// Error already logged.</span>
</pre></div>
</div>
<p>注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志.</p>
<p>如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">DoSomething</span><span class="p">();</span>                  <span class="c1">// Comment here so the comments line up.</span>
<span class="n">DoSomethingElseThatIsLonger</span><span class="p">();</span>  <span class="c1">// Two spaces between the code and the comment.</span>
<span class="p">{</span> <span class="c1">// One space before comment when opening a new scope is allowed,</span>
  <span class="c1">// thus the comment lines up with the following comments and code.</span>
  <span class="n">DoSomethingElse</span><span class="p">();</span>  <span class="c1">// Two spaces before line comments normally.</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">{</span>
                    <span class="c1">// Comments in braced lists describe the next element...</span>
                    <span class="s">&quot;First item&quot;</span><span class="p">,</span>
                    <span class="c1">// .. and should be aligned appropriately.</span>
<span class="s">&quot;Second item&quot;</span><span class="p">};</span>
<span class="n">DoSomething</span><span class="p">();</span> <span class="cm">/* For trailing block comments, one space is fine. */</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h5>函数参数注释</h5>
<p>如果函数参数的意义不明显, 考虑用下面的方式进行弥补:</p>
<ul class="simple">
<li>如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用, 用以推断它们一致, 你应当用一个常量名让这一约定变得更明显, 并且保证这一约定不会被打破.</li>
<li>考虑更改函数的签名, 让某个 <code class="docutils literal"><span class="pre">bool</span></code> 类型的参数变为 <code class="docutils literal"><span class="pre">enum</span></code> 类型, 这样可以让这个参数的值表达其意义.</li>
<li>如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例. 这样的方法有许多优点, 例如这样的选项可以在调用处用变量名引用, 这样就能清晰地表明其意义. 同时也减少了函数参数的数量, 使得函数调用更易读也易写. 除此之外, 以这样的方式, 如果你使用其他的选项, 就无需对调用点进行更改.</li>
<li>用具名变量代替大段而复杂的嵌套表达式.</li>
<li>万不得已时, 才考虑在调用点用注释阐明参数的意义.</li>
</ul>
<p>比如下面的示例的对比:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// What are these arguments?</span>
<span class="k">const</span> <span class="n">DecimalNumber</span> <span class="n">product</span> <span class="o">=</span> <span class="n">CalculateProduct</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
</pre></div>
</div>
<p>和</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">ProductOptions</span> <span class="n">options</span><span class="p">;</span>
<span class="n">options</span><span class="p">.</span><span class="n">set_precision_decimals</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
<span class="n">options</span><span class="p">.</span><span class="n">set_use_cache</span><span class="p">(</span><span class="n">ProductOptions</span><span class="o">::</span><span class="n">kDontUseCache</span><span class="p">);</span>
<span class="k">const</span> <span class="n">DecimalNumber</span> <span class="n">product</span> <span class="o">=</span>
    <span class="n">CalculateProduct</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="cm">/*completion_callback=*/</span><span class="k">nullptr</span><span class="p">);</span>
</pre></div>
</div>
<p>哪个更清晰一目了然.</p>
</div>
<div class="section" id="id17">
<h5>不允许的行为</h5>
<p>不要描述显而易见的现象, <em>永远不要</em> 用自然语言翻译代码作为注释, 除非即使对深入理解 C++ 的读者来说代码的行为都是不明显的. 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意:</p>
<p>你所提供的注释应当解释代码 <em>为什么</em> 要这么做和代码的目的, 或者最好是让代码自文档化.</p>
<p>比较这样的注释:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// Find the element in the vector.  &lt;-- 差: 这太明显了!</span>
<span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">element</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">Process</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>和这样的注释:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// Process &quot;element&quot; unless it was already processed.</span>
<span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">element</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">Process</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>自文档化的代码根本就不需要注释. 上面例子中的注释对下面的代码来说就是毫无必要的:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsAlreadyProcessed</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">Process</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id18">
<h4>8.8. 标点, 拼写和语法</h4>
<p><strong>总述</strong></p>
<p>注意标点, 拼写和语法; 写的好的注释比差的要易读的多.</p>
<p><strong>说明</strong></p>
<p>注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句. 大多数情况下, 完整的句子比句子片段可读性更高. 短一点的注释, 比如代码行尾注释, 可以随意点, 但依然要注意风格的一致性.</p>
<p>虽然被别人指出该用分号时却用了逗号多少有些尴尬, 但清晰易读的代码还是很重要的. 正确的标点, 拼写和语法对此会有很大帮助.</p>
</div>
<div class="section" id="todo">
<h4>8.8. TODO 注释</h4>
<p><strong>总述</strong></p>
<p>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 <code class="docutils literal"><span class="pre">TODO</span></code> 注释.</p>
<p><code class="docutils literal"><span class="pre">TODO</span></code> 注释要使用全大写的字符串 <code class="docutils literal"><span class="pre">TODO</span></code>, 在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一 <code class="docutils literal"><span class="pre">TODO</span></code> 相关的 issue. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 <code class="docutils literal"><span class="pre">TODO</span></code> 格式进行查找. 添加 <code class="docutils literal"><span class="pre">TODO</span></code> 注释并不意味着你要自己来修正, 因此当你加上带有姓名的 <code class="docutils literal"><span class="pre">TODO</span></code> 时, 一般都是写上自己的名字.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.</span>
<span class="c1">// TODO(Zeke) change this to use relations.</span>
<span class="c1">// TODO(bug 12345): remove the &quot;Last visitors&quot; feature</span>
</pre></div>
</div>
<p>如果加 <code class="docutils literal"><span class="pre">TODO</span></code> 是为了在 &#8220;将来某一天做某事&#8221;, 可以附上一个非常明确的时间 &#8220;Fix by November 2005&#8221;), 或者一个明确的事项 (&#8220;Remove this code when all clients can handle XML responses.&#8221;).</p>
</div>
<div class="section" id="id19">
<h4>8.9. 弃用注释</h4>
<p><strong>总述</strong></p>
<p>通过弃用注释（<code class="docutils literal"><span class="pre">DEPRECATED</span></code> comments）以标记某接口点已弃用.</p>
<p>您可以写上包含全大写的 <code class="docutils literal"><span class="pre">DEPRECATED</span></code> 的注释, 以标记某接口为弃用状态. 注释可以放在接口声明前, 或者同一行.</p>
<p>在 <code class="docutils literal"><span class="pre">DEPRECATED</span></code> 一词后, 在括号中留下您的名字, 邮箱地址以及其他身份标识.</p>
<p>弃用注释应当包涵简短而清晰的指引, 以帮助其他人修复其调用点. 在 C++ 中, 你可以将一个弃用函数改造成一个内联函数, 这一函数将调用新的接口.</p>
<p>仅仅标记接口为 <code class="docutils literal"><span class="pre">DEPRECATED</span></code> 并不会让大家不约而同地弃用, 您还得亲自主动修正调用点（callsites）, 或是找个帮手.</p>
<p>修正好的代码应该不会再涉及弃用接口点了, 着实改用新接口点. 如果您不知从何下手, 可以找标记弃用注释的当事人一起商量.</p>
</div>
<div class="section" id="yulefox">
<h4>译者 (YuleFox) 笔记</h4>
<ol class="arabic simple">
<li>关于注释风格, 很多 C++ 的 coders 更喜欢行注释, C coders 或许对块注释依然情有独钟, 或者在文件头大段大段的注释时使用块注释;</li>
<li>文件注释可以炫耀你的成就, 也是为了捅了篓子别人可以找你;</li>
<li>注释要言简意赅, 不要拖沓冗余, 复杂的东西简单化和简单的东西复杂化都是要被鄙视的;</li>
<li>对于 Chinese coders 来说, 用英文注释还是用中文注释, it is a problem, 但不管怎样, 注释是为了让别人看懂, 难道是为了炫耀编程语言之外的你的母语或外语水平吗；</li>
<li>注释不要太乱, 适当的缩进才会让人乐意看. 但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢这样), UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space;</li>
<li>TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了.</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/formatting"></span><div class="section" id="id1">
<h3>9. 格式</h3>
<p>每个人都可能有自己的代码风格和格式, 但如果一个项目中的所有人都遵循同一风格的话, 这个项目就能更顺利地进行. 每个人未必能同意下述的每一处格式规则, 而且其中的不少规则需要一定时间的适应, 但整个项目服从统一的编程风格是很重要的, 只有这样才能让所有人轻松地阅读和理解代码.</p>
<p>为了帮助你正确的格式化代码, 我们写了一个 <a class="reference external" href="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">emacs 配置文件</a>.</p>
<div class="section" id="line-length">
<span id="id2"></span><h4>9.1. 行长度</h4>
<p><strong>总述</strong></p>
<p>每一行代码字符数不超过 80.</p>
<p>我们也认识到这条规则是有争议的, 但很多已有代码都遵照这一规则, 因此我们感觉一致性更重要.</p>
<p><strong>优点</strong></p>
<p>提倡该原则的人认为强迫他们调整编辑器窗口大小是很野蛮的行为. 很多人同时并排开几个代码窗口, 根本没有多余的空间拉伸窗口. 大家都把窗口最大尺寸加以限定, 并且 80 列宽是传统标准. 那么为什么要改变呢?</p>
<p><strong>缺点</strong></p>
<p>反对该原则的人则认为更宽的代码行更易阅读. 80 列的限制是上个世纪 60 年代的大型机的古板缺陷; 现代设备具有更宽的显示屏, 可以很轻松地显示更多代码.</p>
<p><strong>结论</strong></p>
<p>80 个字符是最大值.</p>
<p>如果无法在不伤害易读性的条件下进行断行, 那么注释行可以超过 80 个字符, 这样可以方便复制粘贴. 例如, 带有命令示例或 URL 的行可以超过 80 个字符.</p>
<p>包含长路径的 <code class="docutils literal"><span class="pre">#include</span></code> 语句可以超出80列.</p>
<p><a class="reference internal" href="contents.html#define-guard"><span class="std std-ref">头文件保护</span></a> 可以无视该原则.</p>
</div>
<div class="section" id="ascii">
<h4>9.2. 非 ASCII 字符</h4>
<p><strong>总述</strong></p>
<p>尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</p>
<p><strong>说明</strong></p>
<p>即使是英文, 也不应将用户界面的文本硬编码到源代码中, 因此非 ASCII 字符应当很少被用到. 特殊情况下可以适当包含此类字符. 例如, 代码分析外部数据文件时, 可以适当硬编码数据文件中作为分隔符的非 ASCII 字符串; 更常见的是 (不需要本地化的) 单元测试代码可能包含非 ASCII 字符串. 此类情况下, 应使用 UTF-8 编码, 因为很多工具都可以理解和处理 UTF-8 编码.</p>
<p>十六进制编码也可以, 能增强可读性的情况下尤其鼓励 —— 比如 <code class="docutils literal"><span class="pre">&quot;\xEF\xBB\xBF&quot;</span></code>, 或者更简洁地写作 <code class="docutils literal"><span class="pre">u8&quot;\uFEFF&quot;</span></code>, 在 Unicode 中是 <em>零宽度 无间断</em> 的间隔符号, 如果不用十六进制直接放在 UTF-8 格式的源文件中, 是看不到的.</p>
<p>(Yang.Y 注: <code class="docutils literal"><span class="pre">&quot;\xEF\xBB\xBF&quot;</span></code> 通常用作 UTF-8 with BOM 编码标记)</p>
<p>使用 <code class="docutils literal"><span class="pre">u8</span></code> 前缀把带 <code class="docutils literal"><span class="pre">uXXXX</span></code> 转义序列的字符串字面值编码成 UTF-8. 不要用在本身就带 UTF-8 字符的字符串字面值上, 因为如果编译器不把源代码识别成 UTF-8, 输出就会出错.</p>
<p>别用 C++11 的 <code class="docutils literal"><span class="pre">char16_t</span></code> 和 <code class="docutils literal"><span class="pre">char32_t</span></code>, 它们和 UTF-8 文本没有关系, <code class="docutils literal"><span class="pre">wchar_t</span></code> 同理, 除非你写的代码要调用 Windows API, 后者广泛使用了 <code class="docutils literal"><span class="pre">wchar_t</span></code>.</p>
</div>
<div class="section" id="id3">
<h4>9.3. 空格还是制表位</h4>
<p><strong>总述</strong></p>
<p>只使用空格, 每次缩进 2 个空格.</p>
<p><strong>说明</strong></p>
<p>我们使用空格缩进. 不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格.</p>
</div>
<div class="section" id="id4">
<h4>9.4. 函数声明与定义</h4>
<p><strong>总述</strong></p>
<p>返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 <a class="reference internal" href="#function-calls"><span class="std std-ref">函数调用</span></a> 一致.</p>
<p><strong>说明</strong></p>
<p>函数看上去像这样:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">ReturnType</span> <span class="n">ClassName</span><span class="o">::</span><span class="n">FunctionName</span><span class="p">(</span><span class="n">Type</span> <span class="n">par_name1</span><span class="p">,</span> <span class="n">Type</span> <span class="n">par_name2</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomething</span><span class="p">();</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果同一行文本太多, 放不下所有参数:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">ReturnType</span> <span class="n">ClassName</span><span class="o">::</span><span class="n">ReallyLongFunctionName</span><span class="p">(</span><span class="n">Type</span> <span class="n">par_name1</span><span class="p">,</span> <span class="n">Type</span> <span class="n">par_name2</span><span class="p">,</span>
                                             <span class="n">Type</span> <span class="n">par_name3</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomething</span><span class="p">();</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>甚至连第一个参数都放不下:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">ReturnType</span> <span class="n">LongClassName</span><span class="o">::</span><span class="n">ReallyReallyReallyLongFunctionName</span><span class="p">(</span>
    <span class="n">Type</span> <span class="n">par_name1</span><span class="p">,</span>  <span class="c1">// 4 space indent</span>
    <span class="n">Type</span> <span class="n">par_name2</span><span class="p">,</span>
    <span class="n">Type</span> <span class="n">par_name3</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomething</span><span class="p">();</span>  <span class="c1">// 2 space indent</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意以下几点:</p>
<ul class="simple">
<li>使用好的参数名.</li>
<li>只有在参数未被使用或者其用途非常明显时, 才能省略参数名.</li>
<li>如果返回类型和函数名在一行放不下, 分行.</li>
<li>如果返回类型与函数声明或定义分行了, 不要缩进.</li>
<li>左圆括号总是和函数名在同一行.</li>
<li>函数名和左圆括号间永远没有空格.</li>
<li>圆括号与参数间没有空格.</li>
<li>左大括号总在最后一个参数同一行的末尾处, 不另起新行.</li>
<li>右大括号总是单独位于函数最后一行, 或者与左大括号同一行.</li>
<li>右圆括号和左大括号间总是有一个空格.</li>
<li>所有形参应尽可能对齐.</li>
<li>缺省缩进为 2 个空格.</li>
<li>换行后的参数保持 4 个空格的缩进.</li>
</ul>
<p>未被使用的参数, 或者根据上下文很容易看出其用途的参数, 可以省略参数名:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">Foo</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;&amp;</span><span class="p">);</span>
  <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="n">Foo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;&amp;</span><span class="p">);</span>
  <span class="n">Foo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>未被使用的参数如果其用途不明显的话, 在函数定义处将参数名注释起来:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Rotate</span><span class="p">(</span><span class="kt">double</span> <span class="n">radians</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">Rotate</span><span class="p">(</span><span class="kt">double</span> <span class="n">radians</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">Circle</span><span class="o">::</span><span class="n">Rotate</span><span class="p">(</span><span class="kt">double</span> <span class="cm">/*radians*/</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 差 - 如果将来有人要实现, 很难猜出变量的作用.</span>
<span class="kt">void</span> <span class="n">Circle</span><span class="o">::</span><span class="n">Rotate</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
<p>属性, 和展开为属性的宏, 写在函数声明或定义的最前面, 即返回类型之前:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">MUST_USE_RESULT</span> <span class="kt">bool</span> <span class="nf">IsOK</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="lambda">
<h4>9.5. Lambda 表达式</h4>
<p><strong>总述</strong></p>
<p>Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开.</p>
<p><strong>说明</strong></p>
<p>若用引用捕获, 在变量名和 <code class="docutils literal"><span class="pre">&amp;</span></code> 之间不留空格.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">add_to_x</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">x</span><span class="p">](</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span> <span class="p">};</span>
</pre></div>
</div>
<p>短 lambda 就写得和内联函数一样.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">blacklist</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">digits</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
<span class="n">digits</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove_if</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">digits</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">blacklist</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
               <span class="k">return</span> <span class="n">blacklist</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="n">blacklist</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
             <span class="p">}),</span>
             <span class="n">digits</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="function-calls">
<span id="id5"></span><h4>9.6. 函数调用</h4>
<p><strong>总述</strong></p>
<p>要么一行写完函数调用, 要么在圆括号里对参数分行, 要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里.</p>
<p><strong>说明</strong></p>
<p>函数调用遵循如下形式：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">argument1</span><span class="p">,</span> <span class="n">argument2</span><span class="p">,</span> <span class="n">argument3</span><span class="p">);</span>
</pre></div>
</div>
<p>如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐, 左圆括号后和右圆括号前不要留空格：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">averyveryveryverylongargument1</span><span class="p">,</span>
                          <span class="n">argument2</span><span class="p">,</span> <span class="n">argument3</span><span class="p">);</span>
</pre></div>
</div>
<p>参数也可以放在次行, 缩进四格：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="p">...</span>
  <span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="n">DoSomething</span><span class="p">(</span>
        <span class="n">argument1</span><span class="p">,</span> <span class="n">argument2</span><span class="p">,</span>  <span class="c1">// 4 空格缩进</span>
        <span class="n">argument3</span><span class="p">,</span> <span class="n">argument4</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>把多个参数放在同一行以减少函数调用所需的行数, 除非影响到可读性. 有人认为把每个参数都独立成行, 不仅更好读, 而且方便编辑参数. 不过, 比起所谓的参数编辑, 我们更看重可读性, 且后者比较好办：</p>
<p>如果一些参数本身就是略复杂的表达式, 且降低了可读性, 那么可以直接创建临时变量描述该表达式, 并传递给函数：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">my_heuristic</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">bases</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">my_heuristic</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</div>
<p>或者放着不管, 补充上注释：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">scores</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">bases</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>  <span class="c1">// Score heuristic.</span>
                          <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</div>
<p>如果某参数独立成行, 对可读性更有帮助的话, 那也可以如此做. 参数的格式处理应当以可读性而非其他作为最重要的原则.</p>
<p>此外, 如果一系列参数本身就有一定的结构, 可以酌情地按其结构来决定参数格式：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 通过 3x3 矩阵转换 widget.</span>
<span class="n">my_widget</span><span class="p">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span>
                    <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y3</span><span class="p">,</span>
                    <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">,</span> <span class="n">z3</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="braced-initializer-list-format">
<span id="id6"></span><h4>9.7. 列表初始化格式</h4>
<p><strong>总述</strong></p>
<p>您平时怎么格式化函数调用, 就怎么格式化 <a class="reference internal" href="contents.html#braced-initializer-list"><span class="std std-ref">列表初始化</span></a>.</p>
<p><strong>说明</strong></p>
<p>如果列表初始化伴随着名字, 比如类型或变量名, 格式化时将将名字视作函数调用名, <cite>{}</cite> 视作函数调用的括号. 如果没有名字, 就视作名字长度为零.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 一行列表初始化示范.</span>
<span class="k">return</span> <span class="p">{</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="p">};</span>
<span class="n">functioncall</span><span class="p">({</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="p">});</span>
<span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">{</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="p">};</span>

<span class="c1">// 当不得不断行时.</span>
<span class="n">SomeFunction</span><span class="p">(</span>
    <span class="p">{</span><span class="s">&quot;assume a zero-length name before {&quot;</span><span class="p">},</span>  <span class="c1">// 假设在 { 前有长度为零的名字.</span>
    <span class="n">some_other_function_parameter</span><span class="p">);</span>
<span class="n">SomeType</span> <span class="n">variable</span><span class="p">{</span>
    <span class="n">some</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
    <span class="p">{</span><span class="s">&quot;assume a zero-length name before {&quot;</span><span class="p">},</span>  <span class="c1">// 假设在 { 前有长度为零的名字.</span>
    <span class="n">SomeOtherType</span><span class="p">{</span>
        <span class="s">&quot;Very long string requiring the surrounding breaks.&quot;</span><span class="p">,</span>  <span class="c1">// 非常长的字符串, 前后都需要断行.</span>
        <span class="n">some</span><span class="p">,</span> <span class="n">other</span> <span class="n">values</span><span class="p">},</span>
    <span class="n">SomeOtherType</span><span class="p">{</span><span class="s">&quot;Slightly shorter string&quot;</span><span class="p">,</span>  <span class="c1">// 稍短的字符串.</span>
                  <span class="n">some</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">values</span><span class="p">}};</span>
<span class="n">SomeType</span> <span class="n">variable</span><span class="p">{</span>
    <span class="s">&quot;This is too long to fit all in one line&quot;</span><span class="p">};</span>  <span class="c1">// 字符串过长, 因此无法放在同一行.</span>
<span class="n">MyType</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{</span>  <span class="c1">// 注意了, 您可以在 { 前断行.</span>
    <span class="n">superlongvariablename1</span><span class="p">,</span>
    <span class="n">superlongvariablename2</span><span class="p">,</span>
    <span class="p">{</span><span class="kt">short</span><span class="p">,</span> <span class="n">interior</span><span class="p">,</span> <span class="n">list</span><span class="p">},</span>
    <span class="p">{</span><span class="n">interiorwrappinglist</span><span class="p">,</span>
     <span class="n">interiorwrappinglist2</span><span class="p">}};</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h4>9.9. 条件语句</h4>
<p><strong>总述</strong></p>
<p>倾向于不在圆括号内使用空格. 关键字 <code class="docutils literal"><span class="pre">if</span></code> 和 <code class="docutils literal"><span class="pre">else</span></code> 另起一行.</p>
<p><strong>说明</strong></p>
<p>对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有.</p>
<p>最常见的是没有空格的格式. 哪一种都可以, 最重要的是 <em>保持一致</em>. 如果你是在修改一个文件, 参考当前已有格式. 如果是写新的代码, 参考目录下或项目中其它文件. 还在犹豫的话, 就不要加空格了.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 圆括号里没有空格.</span>
  <span class="p">...</span>  <span class="c1">// 2 空格缩进.</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>  <span class="c1">// else 与 if 的右括号同一行.</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果你更喜欢在圆括号内部加空格:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span> <span class="n">condition</span> <span class="p">)</span> <span class="p">{</span>  <span class="c1">// 圆括号与空格紧邻 - 不常见</span>
  <span class="p">...</span>  <span class="c1">// 2 空格缩进.</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// else 与 if 的右括号同一行.</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意所有情况下 <code class="docutils literal"><span class="pre">if</span></code> 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span>     <span class="c1">// 差 - IF 后面没空格.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">){</span>   <span class="c1">// 差 - { 前面没空格.</span>
<span class="k">if</span><span class="p">(</span><span class="n">condition</span><span class="p">){</span>    <span class="c1">// 变本加厉地差.</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 好 - IF 和 { 都与空格紧邻.</span>
</pre></div>
</div>
<p>如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 <code class="docutils literal"><span class="pre">else</span></code> 子句时使用:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">kFoo</span><span class="p">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">kBar</span><span class="p">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Bar</span><span class="p">();</span>
</pre></div>
</div>
<p>如果语句有 <code class="docutils literal"><span class="pre">else</span></code> 分支则不允许:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 不允许 - 当有 ELSE 分支时 IF 块却写在同一行</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">DoThis</span><span class="p">();</span>
<span class="k">else</span> <span class="nf">DoThat</span><span class="p">();</span>
</pre></div>
</div>
<p>通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求 <code class="docutils literal"><span class="pre">if</span></code> 必须总是使用大括号:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
  <span class="n">DoSomething</span><span class="p">();</span>  <span class="c1">// 2 空格缩进.</span>

<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomething</span><span class="p">();</span>  <span class="c1">// 2 空格缩进.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>但如果语句中某个 <code class="docutils literal"><span class="pre">if-else</span></code> 分支使用了大括号的话, 其它分支也必须使用:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 不可以这样子 - IF 有大括号 ELSE 却没有.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span>
  <span class="n">bar</span><span class="p">;</span>

<span class="c1">// 不可以这样子 - ELSE 有大括号 IF 却没有.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
  <span class="n">foo</span><span class="p">;</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 只要其中一个分支用了大括号, 两个分支都要用上大括号.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h4>9.9. 循环和开关选择语句</h4>
<p><strong>总述</strong></p>
<p><code class="docutils literal"><span class="pre">switch</span></code> 语句可以使用大括号分段, 以表明 cases 之间不是连在一起的. 在单语句循环里, 括号可用可不用. 空循环体应使用 <code class="docutils literal"><span class="pre">{}</span></code> 或 <code class="docutils literal"><span class="pre">continue</span></code>.</p>
<p><strong>说明</strong></p>
<p><code class="docutils literal"><span class="pre">switch</span></code> 语句中的 <code class="docutils literal"><span class="pre">case</span></code> 块可以使用大括号也可以不用, 取决于你的个人喜好. 如果用的话, 要按照下文所述的方法.</p>
<p>如果有不满足 <code class="docutils literal"><span class="pre">case</span></code> 条件的枚举值, <code class="docutils literal"><span class="pre">switch</span></code> 应该总是包含一个 <code class="docutils literal"><span class="pre">default</span></code> 匹配 (如果有输入值没有 case 去处理, 编译器将给出 warning). 如果 <code class="docutils literal"><span class="pre">default</span></code> 应该永远执行不到, 简单的加条 <code class="docutils literal"><span class="pre">assert</span></code>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">switch</span> <span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="p">{</span>  <span class="c1">// 2 空格缩进</span>
    <span class="p">...</span>      <span class="c1">// 4 空格缩进</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">default</span><span class="o">:</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在单语句循环里, 括号可用可不用：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kSomeNumber</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;I love you</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kSomeNumber</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;I take it back</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>空循环体应使用 <code class="docutils literal"><span class="pre">{}</span></code> 或 <code class="docutils literal"><span class="pre">continue</span></code>, 而不是一个简单的分号.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 反复循环直到条件失效.</span>
<span class="p">}</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kSomeNumber</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// 可 - 空循环体.</span>
<span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>  <span class="c1">// 可 - contunue 表明没有逻辑.</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">);</span>  <span class="c1">// 差 - 看起来仅仅只是 while/loop 的部分之一.</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h4>9.10. 指针和引用表达式</h4>
<p><strong>总述</strong></p>
<p>句点或箭头前后不要有空格. 指针/地址操作符 (<code class="docutils literal"><span class="pre">*,</span> <span class="pre">&amp;</span></code>) 之后不能有空格.</p>
<p><strong>说明</strong></p>
<p>下面是指针和引用表达式的正确使用范例:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">;</span>
</pre></div>
</div>
<p>注意:</p>
<ul class="simple">
<li>在访问成员时, 句点或箭头前后没有空格.</li>
<li>指针操作符 <code class="docutils literal"><span class="pre">*</span></code> 或 <code class="docutils literal"><span class="pre">&amp;</span></code> 后没有空格.</li>
</ul>
<p>在声明指针变量或参数时, 星号与类型或变量名紧挨都可以:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 好, 空格前置.</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
<span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">;</span>

<span class="c1">// 好, 空格后置.</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">c</span><span class="p">;</span>
<span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">;</span>  <span class="c1">// 不允许 - 在多重声明中不能使用 &amp; 或 *</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">c</span><span class="p">;</span>  <span class="c1">// 差 - * 两边都有空格</span>
<span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span> <span class="n">str</span><span class="p">;</span>  <span class="c1">// 差 - &amp; 两边都有空格.</span>
</pre></div>
</div>
<p>在单个文件内要保持风格一致, 所以, 如果是修改现有文件, 要遵照该文件的风格.</p>
</div>
<div class="section" id="id10">
<h4>9.11. 布尔表达式</h4>
<p><strong>总述</strong></p>
<p>如果一个布尔表达式超过 <a class="reference internal" href="#line-length"><span class="std std-ref">标准行宽</span></a>, 断行方式要统一一下.</p>
<p><strong>说明</strong></p>
<p>下例中, 逻辑与 (<code class="docutils literal"><span class="pre">&amp;&amp;</span></code>) 操作符总位于行尾:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">this_one_thing</span> <span class="o">&gt;</span> <span class="n">this_other_thing</span> <span class="o">&amp;&amp;</span>
    <span class="n">a_third_thing</span> <span class="o">==</span> <span class="n">a_fourth_thing</span> <span class="o">&amp;&amp;</span>
    <span class="n">yet_another</span> <span class="o">&amp;&amp;</span> <span class="n">last_one</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意, 上例的逻辑与 (<code class="docutils literal"><span class="pre">&amp;&amp;</span></code>) 操作符均位于行尾. 这个格式在 Google 里很常见, 虽然把所有操作符放在开头也可以. 可以考虑额外插入圆括号, 合理使用的话对增强可读性是很有帮助的. 此外, 直接用符号形式的操作符, 比如 <code class="docutils literal"><span class="pre">&amp;&amp;</span></code> 和 <code class="docutils literal"><span class="pre">~</span></code>, 不要用词语形式的 <code class="docutils literal"><span class="pre">and</span></code> 和 <code class="docutils literal"><span class="pre">compl</span></code>.</p>
</div>
<div class="section" id="id11">
<h4>9.12. 函数返回值</h4>
<p><strong>总述</strong></p>
<p>不要在 <code class="docutils literal"><span class="pre">return</span></code> 表达式里加上非必须的圆括号.</p>
<p><strong>说明</strong></p>
<p>只有在写 <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">expr</span></code> 要加上括号的时候才在 <code class="docutils literal"><span class="pre">return</span> <span class="pre">expr;</span></code> 里使用括号.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">result</span><span class="p">;</span>                  <span class="c1">// 返回值很简单, 没有圆括号.</span>
<span class="c1">// 可以用圆括号把复杂表达式圈起来, 改善可读性.</span>
<span class="k">return</span> <span class="p">(</span><span class="n">some_long_condition</span> <span class="o">&amp;&amp;</span>
        <span class="n">another_condition</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="p">(</span><span class="n">value</span><span class="p">);</span>                <span class="c1">// 毕竟您从来不会写 var = (value);</span>
<span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>                <span class="c1">// return 可不是函数！</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h4>9.13. 变量及数组初始化</h4>
<p><strong>总述</strong></p>
<p>用 <code class="docutils literal"><span class="pre">=</span></code>, <code class="docutils literal"><span class="pre">()</span></code> 和 <code class="docutils literal"><span class="pre">{}</span></code> 均可.</p>
<p><strong>说明</strong></p>
<p>您可以用 <code class="docutils literal"><span class="pre">=</span></code>, <code class="docutils literal"><span class="pre">()</span></code> 和 <code class="docutils literal"><span class="pre">{}</span></code>, 以下的例子都是正确的：</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">x</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span>
<span class="n">string</span> <span class="nf">name</span><span class="p">(</span><span class="s">&quot;Some Name&quot;</span><span class="p">);</span>
<span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Some Name&quot;</span><span class="p">;</span>
<span class="n">string</span> <span class="n">name</span><span class="p">{</span><span class="s">&quot;Some Name&quot;</span><span class="p">};</span>
</pre></div>
</div>
<p>请务必小心列表初始化 <code class="docutils literal"><span class="pre">{...}</span></code> 用 <code class="docutils literal"><span class="pre">std::initializer_list</span></code> 构造函数初始化出的类型. 非空列表初始化就会优先调用 <code class="docutils literal"><span class="pre">std::initializer_list</span></code>, 不过空列表初始化除外, 后者原则上会调用默认构造函数. 为了强制禁用 <code class="docutils literal"><span class="pre">std::initializer_list</span></code> 构造函数, 请改用括号.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 内容为 100 个 1 的向量.</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>  <span class="c1">// 内容为 100 和 1 的向量.</span>
</pre></div>
</div>
<p>此外, 列表初始化不允许整型类型的四舍五入, 这可以用来避免一些类型上的编程失误.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">pi</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span>  <span class="c1">// 好 - pi == 3.</span>
<span class="kt">int</span> <span class="n">pi</span><span class="p">{</span><span class="mf">3.14</span><span class="p">};</span>  <span class="c1">// 编译错误: 缩窄转换.</span>
</pre></div>
</div>
</div>
<div class="section" id="id13">
<h4>9.14. 预处理指令</h4>
<p><strong>总述</strong></p>
<p>预处理指令不要缩进, 从行首开始.</p>
<p><strong>说明</strong></p>
<p>即使预处理指令位于缩进代码块中, 指令也应从行首开始.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 好 - 指令从行首开始</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lopsided_score</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if DISASTER_PENDING      </span><span class="c1">// 正确 - 从行首开始</span>
    <span class="n">DropEverything</span><span class="p">();</span>
<span class="cp"># if NOTIFY               </span><span class="c1">// 非必要 - # 后跟空格</span>
    <span class="n">NotifyClient</span><span class="p">();</span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>
    <span class="n">BackToNormal</span><span class="p">();</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 差 - 指令缩进</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lopsided_score</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if DISASTER_PENDING  </span><span class="c1">// 差 - &quot;#if&quot; 应该放在行开头</span>
    <span class="n">DropEverything</span><span class="p">();</span>
    <span class="cp">#endif                </span><span class="c1">// 差 - &quot;#endif&quot; 不要缩进</span>
    <span class="n">BackToNormal</span><span class="p">();</span>
  <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h4>9.15. 类格式</h4>
<p><strong>总述</strong></p>
<p>访问控制块的声明依次序是 <code class="docutils literal"><span class="pre">public:</span></code>, <code class="docutils literal"><span class="pre">protected:</span></code>, <code class="docutils literal"><span class="pre">private:</span></code>, 每个都缩进 1 个空格.</p>
<p><strong>说明</strong></p>
<p>类声明 (下面的代码中缺少注释, 参考 <a class="reference internal" href="contents.html#class-comments"><span class="std std-ref">类注释</span></a>) 的基本格式如下:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span> <span class="o">:</span> <span class="k">public</span> <span class="n">OtherClass</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>      <span class="c1">// 注意有一个空格的缩进</span>
  <span class="n">MyClass</span><span class="p">();</span>  <span class="c1">// 标准的两空格缩进</span>
  <span class="k">explicit</span> <span class="nf">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">);</span>
  <span class="o">~</span><span class="n">MyClass</span><span class="p">()</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">SomeFunction</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">SomeFunctionThatDoesNothing</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">set_some_var</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span> <span class="p">{</span> <span class="n">some_var_</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="nf">some_var</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">some_var_</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">SomeInternalFunction</span><span class="p">();</span>

  <span class="kt">int</span> <span class="n">some_var_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">some_other_var_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>注意事项:</p>
<ul class="simple">
<li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li>
<li>关键词 <code class="docutils literal"><span class="pre">public:</span></code>, <code class="docutils literal"><span class="pre">protected:</span></code>, <code class="docutils literal"><span class="pre">private:</span></code> 要缩进 1 个空格.</li>
<li>除第一个关键词 (一般是 <code class="docutils literal"><span class="pre">public</span></code>) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.</li>
<li>这些关键词后不要保留空行.</li>
<li><code class="docutils literal"><span class="pre">public</span></code> 放在最前面, 然后是 <code class="docutils literal"><span class="pre">protected</span></code>, 最后是 <code class="docutils literal"><span class="pre">private</span></code>.</li>
<li>关于声明顺序的规则请参考 <a class="reference internal" href="contents.html#declaration-order"><span class="std std-ref">声明顺序</span></a> 一节.</li>
</ul>
</div>
<div class="section" id="id15">
<h4>9.16. 构造函数初始值列表</h4>
<p><strong>总述</strong></p>
<p>构造函数初始化列表放在同一行或按四格缩进并排多行.</p>
<p><strong>说明</strong></p>
<p>下面两种初始值列表方式都可以接受:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 如果所有变量能放在同一行:</span>
<span class="n">MyClass</span><span class="o">::</span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span> <span class="o">:</span> <span class="n">some_var_</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 如果不能放在同一行,</span>
<span class="c1">// 必须置于冒号后, 并缩进 4 个空格</span>
<span class="n">MyClass</span><span class="o">::</span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">some_var_</span><span class="p">(</span><span class="n">var</span><span class="p">),</span> <span class="n">some_other_var_</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行</span>
<span class="c1">// 并逐行对齐</span>
<span class="n">MyClass</span><span class="o">::</span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">some_var_</span><span class="p">(</span><span class="n">var</span><span class="p">),</span>             <span class="c1">// 4 space indent</span>
      <span class="n">some_other_var_</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// lined up</span>
  <span class="n">DoSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 右大括号 } 可以和左大括号 { 放在同一行</span>
<span class="c1">// 如果这样做合适的话</span>
<span class="n">MyClass</span><span class="o">::</span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">some_var_</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h4>9.17. 命名空间格式化</h4>
<p><strong>总述</strong></p>
<p>命名空间内容不缩进.</p>
<p><strong>说明</strong></p>
<p><a class="reference internal" href="contents.html#namespaces"><span class="std std-ref">命名空间</span></a> 不要增加额外的缩进层次, 例如:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="p">{</span>

<span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// 正确. 命名空间内没有额外的缩进.</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="p">}</span>  <span class="c1">// namespace</span>
</pre></div>
</div>
<p>不要在命名空间内缩进:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="p">{</span>

  <span class="c1">// 错, 缩进多余了.</span>
  <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>

<span class="p">}</span>  <span class="c1">// namespace</span>
</pre></div>
</div>
<p>声明嵌套命名空间时, 每个命名空间都独立成行.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">foo</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">bar</span> <span class="p">{</span>
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h4>9.19. 水平留白</h4>
<p><strong>总述</strong></p>
<p>水平留白的使用根据在代码中的位置决定. 永远不要在行尾添加没意义的留白.</p>
<p><strong>说明</strong></p>
<div class="section" id="id18">
<h5>通用</h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">bool</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 左大括号前总是有空格.</span>
  <span class="p">...</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 分号前不加空格.</span>
<span class="c1">// 列表初始化中大括号内的空格是可选的.</span>
<span class="c1">// 如果加了空格, 那么两边都要加上.</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="c1">// 继承与初始化列表中的冒号前后恒有空格.</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Bar</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 对于单行函数的实现, 在大括号内加上空格</span>
  <span class="c1">// 然后是函数实现</span>
  <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">Bar</span><span class="p">(),</span> <span class="n">baz_</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// 大括号里面是空的话, 不加空格.</span>
  <span class="kt">void</span> <span class="n">Reset</span><span class="p">()</span> <span class="p">{</span> <span class="n">baz_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// 用括号把大括号与实现分开.</span>
  <span class="p">...</span>
</pre></div>
</div>
<p>添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格. 如果确定一行代码已经修改完毕, 将多余的空格去掉; 或者在专门清理空格时去掉（尤其是在没有其他人在处理这件事的时候). (Yang.Y 注: 现在大部分代码编辑器稍加设置后, 都支持自动删除行首/行尾空格, 如果不支持, 考虑换一款编辑器或 IDE)</p>
</div>
<div class="section" id="id19">
<h5>循环和条件语句</h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>          <span class="c1">// if 条件语句和循环语句关键字后均有空格.</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>          <span class="c1">// else 前后有空格.</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="p">{}</span>   <span class="c1">// 圆括号内部不紧邻空格.</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="k">switch</span> <span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="p">{</span>    <span class="c1">// 循环和条件语句的圆括号里可以与空格紧邻.</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">test</span> <span class="p">)</span> <span class="p">{</span>     <span class="c1">// 圆括号, 但这很少见. 总之要一致.</span>
<span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 循环里内 ; 后恒有空格, ;  前可以加个空格.</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>         <span class="c1">// switch case 的冒号前无空格.</span>
    <span class="p">...</span>
  <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// 如果冒号有代码, 加个空格.</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h5>操作符</h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 赋值运算符前后总是有空格.</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.</span>
<span class="c1">// 圆括号内部没有紧邻空格.</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">/</span> <span class="n">z</span><span class="p">;</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">/</span><span class="n">z</span><span class="p">;</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">);</span>

<span class="c1">// 在参数和一元操作符之间不加空格.</span>
<span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">;</span>
<span class="o">++</span><span class="n">x</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">y</span><span class="p">)</span>
  <span class="p">...</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h5>模板和转换</h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
<span class="n">y</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="c1">// 在类型与指针操作符之间留空格也可以, 但要保持一致.</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span> <span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id22">
<h4>9.19. 垂直留白</h4>
<p><strong>总述</strong></p>
<p>垂直留白越少越好.</p>
<p><strong>说明</strong></p>
<p>这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行.</p>
<p>基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然, 过于密集的代码块和过于疏松的代码块同样难看, 这取决于你的判断. 但通常是垂直留白越少越好.</p>
<p>下面的规则可以让加入的空行更有效:</p>
<ul class="simple">
<li>函数体内开头或结尾的空行可读性微乎其微.</li>
<li>在多重 if-else 块里加空行或许有点可读性.</li>
</ul>
</div>
<div class="section" id="yulefox">
<h4>译者 (YuleFox) 笔记</h4>
<ol class="arabic simple">
<li>对于代码格式, 因人, 系统而异各有优缺点, 但同一个项目中遵循同一标准还是有必要的;</li>
<li>行宽原则上不超过 80 列, 把 22 寸的显示屏都占完, 怎么也说不过去;</li>
<li>尽量不使用非 ASCII 字符, 如果使用的话, 参考 UTF-8 格式 (尤其是 UNIX/Linux 下, Windows 下可以考虑宽字符), 尽量不将字符串常量耦合到代码中, 比如独立出资源文件, 这不仅仅是风格问题了;</li>
<li>UNIX/Linux 下无条件使用空格, MSVC 的话使用 Tab 也无可厚非;</li>
<li>函数参数, 逻辑条件, 初始化列表: 要么所有参数和函数名放在同一行, 要么所有参数并排分行;</li>
<li>除函数定义的左大括号可以置于行首外, 包括函数/类/结构体/枚举声明, 各种语句的左大括号置于行尾, 所有右大括号独立成行;</li>
<li><code class="docutils literal"><span class="pre">.</span></code>/<code class="docutils literal"><span class="pre">-&gt;</span></code> 操作符前后不留空格, <code class="docutils literal"><span class="pre">*</span></code>/<code class="docutils literal"><span class="pre">&amp;</span></code> 不要前后都留, 一个就可, 靠左靠右依各人喜好;</li>
<li>预处理指令/命名空间不使用额外缩进, 类/结构体/枚举/函数/语句使用缩进;</li>
<li>初始化用 <code class="docutils literal"><span class="pre">=</span></code> 还是 <code class="docutils literal"><span class="pre">()</span></code> 依个人喜好, 统一就好;</li>
<li><code class="docutils literal"><span class="pre">return</span></code> 不要加 <code class="docutils literal"><span class="pre">()</span></code>;</li>
<li>水平/垂直留白不要滥用, 怎么易读怎么来.</li>
<li>关于 UNIX/Linux 风格为什么要把左大括号置于行尾 (<code class="docutils literal"><span class="pre">.cc</span></code> 文件的函数实现处, 左大括号位于行首), 我的理解是代码看上去比较简约, 想想行首除了函数体被一对大括号封在一起之外, 只有右大括号的代码看上去确实也舒服; Windows 风格将左大括号置于行首的优点是匹配情况一目了然.</li>
</ol>
</div>
<div class="section" id="acgtyrant">
<h4>译者（acgtyrant）笔记</h4>
<ol class="arabic simple">
<li>80 行限制事实上有助于避免代码可读性失控, 比如超多重嵌套块, 超多重函数调用等等.</li>
<li>Linux 上设置好了 Locale 就几乎一劳永逸设置好所有开发环境的编码, 不像奇葩的 Windows.</li>
<li>Google 强调有一对 if-else 时, 不论有没有嵌套, 都要有大括号. Apple 正好 <a class="reference external" href="http://coolshell.cn/articles/11112.html">有栽过跟头</a> .</li>
<li>其实我主张指针／地址操作符与变量名紧邻, <code class="docutils literal"><span class="pre">int*</span> <span class="pre">a,</span> <span class="pre">b</span></code> vs <code class="docutils literal"><span class="pre">int</span> <span class="pre">*a,</span> <span class="pre">b</span></code>, 新手会误以为前者的 <code class="docutils literal"><span class="pre">b</span></code> 是 <code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span></code> 变量, 但后者就不一样了, 高下立判.</li>
<li>在这风格指南里我才刚知道 C++ 原来还有所谓的 <a class="reference external" href="http://en.cppreference.com/w/cpp/language/operator_alternative">Alternative operator representations</a>, 大概没人用吧.</li>
<li>注意构造函数初始值列表（Constructer Initializer List）与列表初始化（Initializer List）是两码事, 我就差点混淆了它们的翻译.</li>
<li>事实上, 如果您熟悉英语本身的书写规则, 就会发现该风格指南在格式上的规定与英语语法相当一脉相承. 比如普通标点符号和单词后面还有文本的话, 总会留一个空格; 特殊符号与单词之间就不用留了, 比如 <code class="docutils literal"><span class="pre">if</span> <span class="pre">(true)</span></code> 中的圆括号与 <code class="docutils literal"><span class="pre">true</span></code>.</li>
<li>本风格指南没有明确规定 void 函数里要不要用 return 语句, 不过就 Google 开源项目 leveldb 并没有写; 此外从 <a class="reference external" href="http://stackoverflow.com/questions/9316717/is-a-blank-return-statement-at-the-end-of-a-function-whos-return-type-is-void-ne">Is a blank return statement at the end of a function whos return type is void necessary?</a> 来看, <code class="docutils literal"><span class="pre">return;</span></code> 比 <code class="docutils literal"><span class="pre">return</span> <span class="pre">;</span></code> 更约定俗成（事实上 cpplint 会对后者报错, 指出分号前有多余的空格）, 且可用来提前跳出函数栈.</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/exceptions"></span><div class="section" id="id1">
<h3>10. 规则特例</h3>
<p>前面说明的编程习惯基本都是强制性的. 但所有优秀的规则都允许例外, 这里就是探讨这些特例.</p>
<div class="section" id="id2">
<h4>10.1. 现有不合规范的代码</h4>
<p><strong>总述</strong></p>
<p>对于现有不符合既定编程风格的代码可以网开一面.</p>
<p><strong>说明</strong></p>
<p>当你修改使用其他风格的代码时, 为了与代码原有风格保持一致可以不使用本指南约定. 如果不放心, 可以与代码原作者或现在的负责人员商讨. 记住, <em>一致性</em> 也包括原有的一致性.</p>
</div>
<div class="section" id="windows">
<span id="windows-code"></span><h4>10.2. Windows 代码</h4>
<p><strong>总述</strong></p>
<p>Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它 Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的 C++ 编程只给出一个单独的指南.</p>
<p><strong>说明</strong></p>
<p>如果你习惯使用 Windows 编码风格, 这儿有必要重申一下某些你可能会忘记的指南:</p>
<ul class="simple">
<li>不要使用匈牙利命名法 (比如把整型变量命名成 <code class="docutils literal"><span class="pre">iNum</span></code>). 使用 Google 命名约定, 包括对源文件使用 <code class="docutils literal"><span class="pre">.cc</span></code> 扩展名.</li>
<li>Windows 定义了很多原生类型的同义词 (YuleFox 注: 这一点, 我也很反感), 如 <code class="docutils literal"><span class="pre">DWORD</span></code>, <code class="docutils literal"><span class="pre">HANDLE</span></code> 等等. 在调用 Windows API 时这是完全可以接受甚至鼓励的. 即使如此, 还是尽量使用原有的 C++ 类型, 例如使用 <code class="docutils literal"><span class="pre">const</span> <span class="pre">TCHAR</span> <span class="pre">*</span></code> 而不是 <code class="docutils literal"><span class="pre">LPCTSTR</span></code>.</li>
<li>使用 Microsoft Visual C++ 进行编译时, 将警告级别设置为 3 或更高, 并将所有警告(warnings)当作错误(errors)处理.</li>
<li>不要使用 <code class="docutils literal"><span class="pre">#pragma</span> <span class="pre">once</span></code>; 而应该使用 Google 的头文件保护规则. 头文件保护的路径应该相对于项目根目录 (Yang.Y 注: 如 <code class="docutils literal"><span class="pre">#ifndef</span> <span class="pre">SRC_DIR_BAR_H_</span></code>, 参考 <a class="reference internal" href="contents.html#define-guard"><span class="std std-ref">#define 保护</span></a> 一节).</li>
<li>除非万不得已, 不要使用任何非标准的扩展, 如 <code class="docutils literal"><span class="pre">#pragma</span></code> 和 <code class="docutils literal"><span class="pre">__declspec</span></code>. 使用 <code class="docutils literal"><span class="pre">__declspec(dllimport)</span></code> 和 <code class="docutils literal"><span class="pre">__declspec(dllexport)</span></code> 是允许的, 但必须通过宏来使用, 比如 <code class="docutils literal"><span class="pre">DLLIMPORT</span></code> 和 <code class="docutils literal"><span class="pre">DLLEXPORT</span></code>, 这样其他人在分享使用这些代码时可以很容易地禁用这些扩展.</li>
</ul>
<p>然而, 在 Windows 上仍然有一些我们偶尔需要违反的规则:</p>
<ul class="simple">
<li>通常我们 <a class="reference internal" href="contents.html#multiple-inheritance"><span class="std std-ref">禁止使用多重继承</span></a>, 但在使用 COM 和 ATL/WTL 类时可以使用多重继承. 为了实现 COM 或 ATL/WTL 类/接口, 你可能不得不使用多重实现继承.</li>
<li>虽然代码中不应该使用异常, 但是在 ATL 和部分 STL（包括 Visual C++ 的 STL) 中异常被广泛使用. 使用 ATL 时, 应定义 <code class="docutils literal"><span class="pre">_ATL_NO_EXCEPTIONS</span></code> 以禁用异常. 你需要研究一下是否能够禁用 STL 的异常, 如果无法禁用, 可以启用编译器异常. (注意这只是为了编译 STL, 自己的代码里仍然不应当包含异常处理).</li>
<li>通常为了利用头文件预编译, 每个每个源文件的开头都会包含一个名为 <code class="docutils literal"><span class="pre">StdAfx.h</span></code> 或 <code class="docutils literal"><span class="pre">precompile.h</span></code> 的文件. 为了使代码方便与其他项目共享, 请避免显式包含此文件 (除了在 <code class="docutils literal"><span class="pre">precompile.cc</span></code> 中), 使用 <code class="docutils literal"><span class="pre">/FI</span></code> 编译器选项以自动包含该文件.</li>
<li>资源头文件通常命名为 <code class="docutils literal"><span class="pre">resource.h</span></code> 且只包含宏, 这一文件不需要遵守本风格指南.</li>
</ul>
</div>
</div>
<span id="document-google-cpp-styleguide/end"></span><div class="section" id="id1">
<h3>11. 结束语</h3>
<p>运用常识和判断力, 并且 <em>保持一致</em>.</p>
<p>编辑代码时, 花点时间看看项目中的其它代码, 并熟悉其风格. 如果其它代码中 <code class="docutils literal"><span class="pre">if</span></code> 语句使用空格, 那么你也要使用. 如果其中的注释用星号 (*) 围成一个盒子状, 那么你同样要这么做.</p>
<p>风格指南的重点在于提供一个通用的编程规范, 这样大家可以把精力集中在实现内容而不是表现形式上. 我们展示的是一个总体的的风格规范, 但局部风格也很重要, 如果你在一个文件中新加的代码和原有代码风格相去甚远, 这就破坏了文件本身的整体美观, 也让打乱读者在阅读代码时的节奏, 所以要尽量避免.</p>
<p>好了, 关于编码风格写的够多了; 代码本身才更有趣. 尽情享受吧!</p>
</div>
</div>
</div>
<span id="document-google-objc-styleguide/contents"></span><div class="section" id="objective-c">
<span id="objc-contents"></span><h2>Objective-C 风格指南 - 内容目录</h2>
<div class="toctree-wrapper compound">
<span id="document-google-objc-styleguide/index"></span><div class="section" id="google-objective-c-style-guide">
<h3>Google Objective-C Style Guide 中文版</h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">版本:</th><td class="field-body"><p class="first">2.36</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">原作者:</th><td class="field-body"><div class="first line-block">
<div class="line">Mike Pinkerton</div>
<div class="line">Greg Miller</div>
<div class="line">Dave MacLachlan</div>
</div>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">翻译:</th><td class="field-body"><div class="first line-block">
<div class="line"><a class="reference external" href="http://ke.indiebros.com/">ewangke</a></div>
<div class="line"><a class="reference external" href="https://github.com/yangyubo">Yang.Y</a></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">项目主页:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference external" href="http://google-styleguide.googlecode.com">Google Style Guide</a></li>
<li><a class="reference external" href="http://github.com/zh-google-styleguide/zh-google-styleguide">Google 开源项目风格指南 - 中文版</a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="section" id="id1">
<h4>译者的话</h4>
<div class="section" id="ewanke">
<h5>ewanke</h5>
<p>一直想翻译这个 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/objcguide.xml">style guide</a> ，终于在周末花了7个小时的时间用vim敲出了HTML。很多术语的翻译很难，平时看的中文技术类书籍有限，对很多术语的中文译法不是很清楚，难免有不恰当之处，请读者指出并帮我改进：王轲 ”ewangke at gmail.com” 2011.03.27</p>
</div>
<div class="section" id="id2">
<h5>Yang.Y</h5>
<p>对 Objective-C 的了解有限，凭着感觉和 C/C++ 方面的理解：</p>
<ul class="simple">
<li>把指南更新到 2.36 版本</li>
<li>调整了一些术语和句子</li>
</ul>
</div>
</div>
<div class="section" id="id3">
<h4>背景介绍</h4>
<p>Objective-C 是 C 语言的扩展，增加了动态类型和面对对象的特性。它被设计成具有易读易用的，支持复杂的面向对象设计的编程语言。它是 Mac OS X 以及 iPhone 的主要开发语言。</p>
<p>Cocoa 是 Mac OS X 上主要的应用程序框架之一。它由一组 Objective-C 类组成，为快速开发出功能齐全的 Mac OS X 应用程序提供支持。</p>
<p>苹果公司已经有一份非常全面的 Objective-C 编码指南。Google 为 C++ 也写了一份类似的编码指南。而这份 Objective-C 指南则是苹果和 Google 常规建议的最佳结合。因此，在阅读本指南之前，请确定你已经阅读过：</p>
<ul class="simple">
<li><a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/CodingGuidelines/index.html">Apple’s Cocoa Coding Guidelines</a></li>
<li><a class="reference external" href="http://codinn.com/projects/google-cpp-styleguide/">Google’s Open Source C++ Style Guide</a></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">所有在 Google 的 C++ 风格指南中所禁止的事情，如未明确说明，也同样不能在Objective-C++ 中使用。</p>
</div>
<p>本文档的目的在于为所有的 Mac OS X 的代码提供编码指南及实践。许多准则是在实际的项目和小组中经过长期的演化、验证的。Google 开发的开源项目遵从本指南的要求。</p>
<p>Google 已经发布了遵守本指南开源代码，它们属于 <a class="reference external" href="http://code.google.com/p/google-toolbox-for-mac/">Google Toolbox for Mac project</a> 项目（本文以缩写 GTM 指代）。GTM 代码库中的代码通常为了可以在不同项目中复用。</p>
<p>注意，本指南不是 Objective-C 教程。我们假定读者对 Objective-C 非常熟悉。如果你刚刚接触 Objective-C 或者需要温习，请阅读 <a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/index.html">The Objective-C Programming Language</a> 。</p>
</div>
<div class="section" id="id4">
<h4>例子</h4>
<p>都说一个例子顶上一千句话，我们就从一个例子开始，来感受一下编码的风格、留白以及命名等等。</p>
<p>一个头文件的例子，展示了在 <code class="docutils literal"><span class="pre">&#64;interface</span></code> 声明中如何进行正确的注释以及留白。</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="c1">//  Foo.h</span>
<span class="c1">//  AwesomeProject</span>
<span class="c1">//</span>
<span class="c1">//  Created by Greg Miller on 6/13/08.</span>
<span class="c1">//  Copyright 2008 Google, Inc. All rights reserved.</span>
<span class="c1">//</span>

<span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>

<span class="c1">// A sample class demonstrating good Objective-C style. All interfaces,</span>
<span class="c1">// categories, and protocols (read: all top-level declarations in a header)</span>
<span class="c1">// MUST be commented. Comments must also be adjacent to the object they&#39;re</span>
<span class="c1">// documenting.</span>
<span class="c1">//</span>
<span class="c1">// (no blank line between this comment and the interface)</span>
<span class="k">@interface</span> <span class="nc">Foo</span> : <span class="bp">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="bp">NSString</span> <span class="o">*</span><span class="n">bar_</span><span class="p">;</span>
  <span class="bp">NSString</span> <span class="o">*</span><span class="n">bam_</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Returns an autoreleased instance of Foo. See -initWithBar: for details</span>
<span class="c1">// about |bar|.</span>
<span class="p">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">fooWithBar:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span><span class="p">;</span>

<span class="c1">// Designated initializer. |bar| is a thing that represents a thing that</span>
<span class="c1">// does a thing.</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithBar:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span><span class="p">;</span>

<span class="c1">// Gets and sets |bar_|.</span>
<span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">bar</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setBar:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span><span class="p">;</span>

<span class="c1">// Does some work with |blah| and returns YES if the work was completed</span>
<span class="c1">// successfully, and NO otherwise.</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">doWorkWithBlah:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">blah</span><span class="p">;</span>

<span class="k">@end</span>
</pre></div>
</div>
<p>一个源文件的例子，展示了 <code class="docutils literal"><span class="pre">&#64;implementation</span></code> 部分如何进行正确的注释、留白。同时也包括了基于引用实现的一些重要方法，如 <code class="docutils literal"><span class="pre">getters</span></code> 、 <code class="docutils literal"><span class="pre">setters</span></code> 、 <code class="docutils literal"><span class="pre">init</span></code> 以及 <code class="docutils literal"><span class="pre">dealloc</span></code> 。</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">//  Foo.m</span>
<span class="c1">//  AwesomeProject</span>
<span class="c1">//</span>
<span class="c1">//  Created by Greg Miller on 6/13/08.</span>
<span class="c1">//  Copyright 2008 Google, Inc. All rights reserved.</span>
<span class="c1">//</span>

<span class="cp">#import &quot;Foo.h&quot;</span>


<span class="k">@implementation</span> <span class="nc">Foo</span>

<span class="p">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">fooWithBar:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithBar</span><span class="p">:</span><span class="n">bar</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// Must always override super&#39;s designated initializer.</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">initWithBar</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithBar:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">]))</span> <span class="p">{</span>
    <span class="n">bar_</span> <span class="o">=</span> <span class="p">[</span><span class="n">bar</span> <span class="k">copy</span><span class="p">];</span>
    <span class="n">bam_</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat</span><span class="p">:</span><span class="s">@&quot;hi %d&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">bar_</span> <span class="k">release</span><span class="p">];</span>
  <span class="p">[</span><span class="n">bam_</span> <span class="k">release</span><span class="p">];</span>
  <span class="p">[</span><span class="nb">super</span> <span class="n">dealloc</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">bar</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">bar_</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setBar:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">bar_</span> <span class="n">autorelease</span><span class="p">];</span>
  <span class="n">bar_</span> <span class="o">=</span> <span class="p">[</span><span class="n">bar</span> <span class="k">copy</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">doWorkWithBlah:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">blah</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@end</span>
</pre></div>
</div>
<p>不要求在 <code class="docutils literal"><span class="pre">&#64;interface</span></code>、<code class="docutils literal"><span class="pre">&#64;implementation</span></code> 和 <code class="docutils literal"><span class="pre">&#64;end</span></code> 前后空行。如果你在 <code class="docutils literal"><span class="pre">&#64;interface</span></code> 声明了实例变量，则须在关括号 <code class="docutils literal"><span class="pre">}</span></code> 之后空一行。</p>
<p>除非接口和实现非常短，比如少量的私有方法或桥接类，空行方有助于可读性。</p>
</div>
</div>
<span id="document-google-objc-styleguide/spacing"></span><div class="section" id="id1">
<h3>留白和格式</h3>
<div class="section" id="vs">
<h4>空格 vs. 制表符</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只使用空格，且一次缩进两个空格。</p>
</div>
<p>我们使用空格缩进。不要在代码中使用制表符。你应该将编辑器设置成自动将制表符替换成空格。</p>
</div>
<div class="section" id="id2">
<h4>行宽</h4>
<p>尽量让你的代码保持在 80 列之内。</p>
<p>我们深知 Objective-C 是一门繁冗的语言，在某些情况下略超 80 列可能有助于提高可读性，但这也只能是特例而已，不能成为开脱。</p>
<p>如果阅读代码的人认为把把某行行宽保持在 80 列仍然有不失可读性，你应该按他们说的去做。</p>
<p>我们意识到这条规则是有争议的，但很多已经存在的代码坚持了本规则，我们觉得保证一致性更重要。</p>
<p>通过设置 <em>Xcode &gt; Preferences &gt; Text Editing &gt; Show page guide</em>，来使越界更容易被发现。</p>
</div>
<div class="section" id="id3">
<h4>方法声明和定义</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<ul class="last simple">
<li>/ + 和返回类型之间须使用一个空格，参数列表中只有参数之间可以有空格。</li>
</ul>
</div>
<p>方法应该像这样：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doSomethingWithString:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">theString</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>星号前的空格是可选的。当写新的代码时，要与先前代码保持一致。</p>
<p>如果一行有非常多的参数，更好的方式是将每个参数单独拆成一行。如果使用多行，将每个参数前的冒号对齐。</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doSomethingWith:</span><span class="p">(</span><span class="n">GTMFoo</span> <span class="o">*</span><span class="p">)</span><span class="nv">theFoo</span>
                   <span class="nf">rect:</span><span class="p">(</span><span class="n">NSRect</span><span class="p">)</span><span class="nv">theRect</span>
               <span class="nf">interval:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="nv">theInterval</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>当第一个关键字比其它的短时，保证下一行至少有 4 个空格的缩进。这样可以使关键字垂直对齐，而不是使用冒号对齐：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">short:</span><span class="p">(</span><span class="n">GTMFoo</span> <span class="o">*</span><span class="p">)</span><span class="nv">theFoo</span>
    <span class="nf">longKeyword:</span><span class="p">(</span><span class="n">NSRect</span><span class="p">)</span><span class="nv">theRect</span>
    <span class="nf">evenLongerKeyword:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="nv">theInterval</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>方法调用</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">方法调用应尽量保持与方法声明的格式一致。当格式的风格有多种选择时，新的代码要与已有代码保持一致。</p>
</div>
<p>调用时所有参数应该在同一行：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">myObject</span> <span class="nl">doFooWith</span><span class="p">:</span><span class="n">arg1</span> <span class="nl">name</span><span class="p">:</span><span class="n">arg2</span> <span class="nl">error</span><span class="p">:</span><span class="n">arg3</span><span class="p">];</span>
</pre></div>
</div>
<p>或者每行一个参数，以冒号对齐：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">myObject</span> <span class="nl">doFooWith</span><span class="p">:</span><span class="n">arg1</span>
               <span class="nl">name</span><span class="p">:</span><span class="n">arg2</span>
              <span class="nl">error</span><span class="p">:</span><span class="n">arg3</span><span class="p">];</span>
</pre></div>
</div>
<p>不要使用下面的缩进风格：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">myObject</span> <span class="nl">doFooWith</span><span class="p">:</span><span class="n">arg1</span> <span class="nl">name</span><span class="p">:</span><span class="n">arg2</span>  <span class="c1">// some lines with &gt;1 arg</span>
              <span class="nl">error</span><span class="p">:</span><span class="n">arg3</span><span class="p">];</span>

<span class="p">[</span><span class="n">myObject</span> <span class="nl">doFooWith</span><span class="p">:</span><span class="n">arg1</span>
               <span class="nl">name</span><span class="p">:</span><span class="n">arg2</span> <span class="nl">error</span><span class="p">:</span><span class="n">arg3</span><span class="p">];</span>

<span class="p">[</span><span class="n">myObject</span> <span class="nl">doFooWith</span><span class="p">:</span><span class="n">arg1</span>
          <span class="nl">name</span><span class="p">:</span><span class="n">arg2</span>  <span class="c1">// aligning keywords instead of colons</span>
          <span class="nl">error</span><span class="p">:</span><span class="n">arg3</span><span class="p">];</span>
</pre></div>
</div>
<p>方法定义与方法声明一样，当关键字的长度不足以以冒号对齐时，下一行都要以四个空格进行缩进。</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">myObj</span> <span class="kt">short</span><span class="o">:</span><span class="n">arg1</span>
    <span class="nl">longKeyword</span><span class="p">:</span><span class="n">arg2</span>
    <span class="nl">evenLongerKeyword</span><span class="p">:</span><span class="n">arg3</span><span class="p">];</span>
</pre></div>
</div>
</div>
<div class="section" id="public-private">
<h4><code class="docutils literal"><span class="pre">&#64;public</span></code> 和 <code class="docutils literal"><span class="pre">&#64;private</span></code></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><code class="docutils literal"><span class="pre">&#64;public</span></code> 和 <code class="docutils literal"><span class="pre">&#64;private</span></code> 访问修饰符应该以一个空格缩进。</p>
</div>
<p>与 C++ 中的 <code class="docutils literal"><span class="pre">public,</span> <span class="pre">private</span></code> 以及 <code class="docutils literal"><span class="pre">protected</span></code> 非常相似。</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="bp">MyClass</span> : <span class="bp">NSObject</span> <span class="p">{</span>
 <span class="k">@public</span>
  <span class="p">...</span>
 <span class="k">@private</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>异常</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每个 <code class="docutils literal"><span class="pre">&#64;</span></code> 标签应该有独立的一行，在 <code class="docutils literal"><span class="pre">&#64;</span></code> 与 <code class="docutils literal"><span class="pre">{}</span></code> 之间需要有一个空格， <code class="docutils literal"><span class="pre">&#64;catch</span></code> 与被捕捉到的异常对象的声明之间也要有一个空格。</p>
</div>
<p>如果你决定使用 Objective-C 的异常，那么就按下面的格式。不过你最好先看看 <a class="reference internal" href="contents.html#avoid-throwing-exceptions"><span class="std std-ref">避免抛出异常</span></a> 了解下为什么不要使用异常。</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="k">@try</span> <span class="p">{</span>
  <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">@catch</span> <span class="p">(</span><span class="bp">NSException</span> <span class="o">*</span><span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@finally</span> <span class="p">{</span>
  <span class="n">baz</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>协议名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">类型标识符和尖括号内的协议名之间，不能有任何空格。</p>
</div>
<p>这条规则适用于类声明、实例变量以及方法声明。例如：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">MyProtocoledClass</span> : <span class="bp">NSObject</span><span class="o">&lt;</span><span class="n">NSWindowDelegate</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="kt">id</span><span class="o">&lt;</span><span class="n">MyFancyDelegate</span><span class="o">&gt;</span> <span class="n">delegate_</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setDelegate</span><span class="p">:(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">MyFancyDelegate</span><span class="o">&gt;</span><span class="p">)</span><span class="n">aDelegate</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h4>块（闭包）</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">块（block）适合用在 target/selector 模式下创建回调方法时，因为它使代码更易读。块中的代码应该缩进 4 个空格。</p>
</div>
<p>取决于块的长度，下列都是合理的风格准则：</p>
<ul class="simple">
<li>如果一行可以写完块，则没必要换行。</li>
<li>如果不得不换行，关括号应与块声明的第一个字符对齐。</li>
<li>块内的代码须按 4 空格缩进。</li>
<li>如果块太长，比如超过 20 行，建议把它定义成一个局部变量，然后再使用该变量。</li>
<li>如果块不带参数，<code class="docutils literal"><span class="pre">^{</span></code> 之间无须空格。如果带有参数，<code class="docutils literal"><span class="pre">^(</span></code> 之间无须空格，但 <code class="docutils literal"><span class="pre">)</span> <span class="pre">{</span></code> 之间须有一个空格。</li>
<li>块内允许按两个空格缩进，但前提是和项目的其它代码保持一致的缩进风格。</li>
</ul>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="c1">// The entire block fits on one line.</span>
<span class="p">[</span><span class="n">operation</span> <span class="nl">setCompletionBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span> <span class="p">[</span><span class="nb">self</span> <span class="n">onOperationDone</span><span class="p">];</span> <span class="p">}];</span>

<span class="c1">// The block can be put on a new line, indented four spaces, with the</span>
<span class="c1">// closing brace aligned with the first character of the line on which</span>
<span class="c1">// block was declared.</span>
<span class="p">[</span><span class="n">operation</span> <span class="nl">setCompletionBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">delegate</span> <span class="n">newDataAvailable</span><span class="p">];</span>
<span class="p">}];</span>

<span class="c1">// Using a block with a C API follows the same alignment and spacing</span>
<span class="c1">// rules as with Objective-C.</span>
<span class="n">dispatch_async</span><span class="p">(</span><span class="n">fileIOQueue_</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
    <span class="bp">NSString</span><span class="o">*</span> <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">sessionFilePath</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// An example where the parameter wraps and the block declaration fits</span>
<span class="c1">// on the same line. Note the spacing of |^(SessionWindow *window) {|</span>
<span class="c1">// compared to |^{| above.</span>
<span class="p">[[</span><span class="n">SessionService</span> <span class="n">sharedService</span><span class="p">]</span>
    <span class="nl">loadWindowWithCompletionBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">SessionWindow</span> <span class="o">*</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
          <span class="p">[</span><span class="nb">self</span> <span class="nl">windowDidLoad</span><span class="p">:</span><span class="n">window</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="p">[</span><span class="nb">self</span> <span class="n">errorLoadingWindow</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}];</span>

<span class="c1">// An example where the parameter wraps and the block declaration does</span>
<span class="c1">// not fit on the same line as the name.</span>
<span class="p">[[</span><span class="n">SessionService</span> <span class="n">sharedService</span><span class="p">]</span>
    <span class="nl">loadWindowWithCompletionBlock</span><span class="p">:</span>
        <span class="o">^</span><span class="p">(</span><span class="n">SessionWindow</span> <span class="o">*</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
              <span class="p">[</span><span class="nb">self</span> <span class="nl">windowDidLoad</span><span class="p">:</span><span class="n">window</span><span class="p">];</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="p">[</span><span class="nb">self</span> <span class="n">errorLoadingWindow</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}];</span>

<span class="c1">// Large blocks can be declared out-of-line.</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">largeBlock</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
<span class="p">[</span><span class="n">operationQueue_</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="n">largeBlock</span><span class="p">];</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-objc-styleguide/naming"></span><div class="section" id="id1">
<h3>命名</h3>
<p>对于易维护的代码而言，命名规则非常重要。Objective-C 的方法名往往十分长，但代码块读起来就像散文一样，不需要太多的代码注释。</p>
<p>当编写纯粹的 Objective-C 代码时，我们基本遵守标准的 <a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html">Objective-C naming rules</a>，这些命名规则可能与 C++ 风格指南中的大相径庭。例如，Google 的 C++ 风格指南中推荐使用下划线分隔的单词作为变量名，而(苹果的)风格指南则使用驼峰命名法，这在 Objective-C 社区中非常普遍。</p>
<p>任何的类、类别、方法以及变量的名字中都使用全大写的 <a class="reference external" href="http://en.wikipedia.org/wiki/Initialism">首字母缩写</a>。这遵守了苹果的标准命名方式，如 URL、TIFF 以及 EXIF。</p>
<p>当编写 Objective-C++ 代码时，事情就不这么简单了。许多项目需要实现跨平台的 C++ API，并混合一些 Objective-C、Cocoa 代码，或者直接以 C++ 为后端，前端用本地 Cocoa 代码。这就导致了两种命名方式直接不统一。</p>
<p>我们的解决方案是：编码风格取决于方法/函数以哪种语言实现。如果在一个 <code class="docutils literal"><span class="pre">&#64;implementation</span></code> 语句中，就使用 Objective-C 的风格。如果实现一个 C++ 的类，就使用 C++ 的风格。这样避免了一个函数里面实例变量和局部变量命名规则混乱，严重影响可读性。</p>
<div class="section" id="id3">
<h4>文件名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">文件名须反映出其实现了什么类 &#8211; 包括大小写。遵循你所参与项目的约定。</p>
</div>
<p>文件的扩展名应该如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">.h</span></code></td>
<td>C/C++/Objective-C 的头文件</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">.m</span></code></td>
<td>Ojbective-C 实现文件</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">.mm</span></code></td>
<td>Ojbective-C++ 的实现文件</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">.cc</span></code></td>
<td>纯 C++ 的实现文件</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">.c</span></code></td>
<td>纯 C 的实现文件</td>
</tr>
</tbody>
</table>
<p>类别的文件名应该包含被扩展的类名，如：<code class="docutils literal"><span class="pre">GTMNSString+Utils.h</span></code> 或``GTMNSTextView+Autocomplete.h``。</p>
</div>
<div class="section" id="objective-c">
<h4>Objective-C++</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">源代码文件内，Ojbective-C++ 代码遵循你正在实现的函数/方法的风格。</p>
</div>
<p>为了最小化 Cocoa/Objective-C 与 C++ 之间命名风格的冲突，根据待实现的函数/方法选择编码风格。实现 <code class="docutils literal"><span class="pre">&#64;implementation</span></code> 语句块时，使用 Objective-C 的命名规则；如果实现一个 C++ 的类，就使用 C++ 命名规则。</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="c1">// file: cross_platform_header.h</span>

<span class="k">class</span> <span class="n">CrossPlatformAPI</span> <span class="p">{</span>
 <span class="nl">public</span><span class="p">:</span>
  <span class="p">...</span>
  <span class="kt">int</span> <span class="n">DoSomethingPlatformSpecific</span><span class="p">();</span>  <span class="c1">// impl on each platform</span>
 <span class="nl">private</span><span class="p">:</span>
  <span class="kt">int</span> <span class="n">an_instance_var_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// file: mac_implementation.mm</span>
<span class="cp">#include</span> <span class="cpf">&quot;cross_platform_header.h&quot;</span><span class="cp"></span>

<span class="c1">// A typical Objective-C class, using Objective-C naming.</span>
<span class="k">@interface</span> <span class="nc">MyDelegate</span> : <span class="bp">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="kt">int</span> <span class="n">instanceVar_</span><span class="p">;</span>
  <span class="n">CrossPlatformAPI</span><span class="o">*</span> <span class="n">backEndObject_</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">respondToSomething:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">something</span><span class="p">;</span>
<span class="k">@end</span>
<span class="k">@implementation</span> <span class="nc">MyDelegate</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">respondToSomething:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">something</span> <span class="p">{</span>
  <span class="c1">// bridge from Cocoa through our C++ backend</span>
  <span class="n">instanceVar_</span> <span class="o">=</span> <span class="n">backEndObject</span><span class="o">-&gt;</span><span class="n">DoSomethingPlatformSpecific</span><span class="p">();</span>
  <span class="bp">NSString</span><span class="o">*</span> <span class="n">tempString</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithInt</span><span class="p">:</span><span class="n">instanceVar_</span><span class="p">];</span>
  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">tempString</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="c1">// The platform-specific implementation of the C++ class, using</span>
<span class="c1">// C++ naming.</span>
<span class="kt">int</span> <span class="n">CrossPlatformAPI</span><span class="o">::</span><span class="n">DoSomethingPlatformSpecific</span><span class="p">()</span> <span class="p">{</span>
  <span class="bp">NSString</span><span class="o">*</span> <span class="n">temp_string</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithInt</span><span class="p">:</span><span class="n">an_instance_var_</span><span class="p">];</span>
  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">temp_string</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">temp_string</span> <span class="n">intValue</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>类名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">类名（以及类别、协议名）应首字母大写，并以驼峰格式分割单词。</p>
</div>
<p><em>应用层</em> 的代码，应该尽量避免不必要的前缀。为每个类都添加相同的前缀无助于可读性。当编写的代码期望在不同应用程序间复用时，应使用前缀（如：<code class="docutils literal"><span class="pre">GTMSendMessage</span></code>）。</p>
</div>
<div class="section" id="id5">
<h4>类别名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">类别名应该有两三个字母的前缀以表示类别是项目的一部分或者该类别是通用的。类别名应该包含它所扩展的类的名字。</p>
</div>
<p>比如我们要基于 <code class="docutils literal"><span class="pre">NSString</span></code> 创建一个用于解析的类别，我们将把类别放在一个名为 <code class="docutils literal"><span class="pre">GTMNSString+Parsing.h</span></code> 的文件中。类别本身命名为 <code class="docutils literal"><span class="pre">GTMStringParsingAdditions</span></code> （是的，我们知道类别名和文件名不一样，但是这个文件中可能存在多个不同的与解析有关类别）。类别中的方法应该以 <code class="docutils literal"><span class="pre">gtm_myCategoryMethodOnAString:</span></code> 为前缀以避免命名冲突，因为 Objective-C 只有一个名字空间。如果代码不会分享出去，也不会运行在不同的地址空间中，方法名字就不那么重要了。</p>
<p>类名与包含类别名的括号之间，应该以一个空格分隔。</p>
</div>
<div class="section" id="id6">
<h4>Objective-C 方法名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">方法名应该以小写字母开头，并混合驼峰格式。每个具名参数也应该以小写字母开头。</p>
</div>
<p>方法名应尽量读起来就像句子，这表示你应该选择与方法名连在一起读起来通顺的参数名。（例如，<code class="docutils literal"><span class="pre">convertPoint:fromRect:</span></code> 或 <code class="docutils literal"><span class="pre">replaceCharactersInRange:withString:</span></code>）。详情参见 <a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html">Apple’s Guide to Naming Methods</a>。</p>
<p>访问器方法应该与他们 <code class="docutils literal"><span class="pre">要获取的</span></code> 成员变量的名字一样，但不应该以get作为前缀。例如：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">getDelegate</span><span class="p">;</span>  <span class="c1">// AVOID</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">delegate</span><span class="p">;</span>     <span class="c1">// GOOD</span>
</pre></div>
</div>
<p>这仅限于 Objective-C 的方法名。C++ 的方法与函数的命名规则应该遵从 C++ 风格指南中的规则。</p>
</div>
<div class="section" id="id7">
<h4>变量名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">变量名应该以小写字母开头，并使用驼峰格式。类的成员变量应该以下划线作为后缀。例如：<code class="docutils literal"><span class="pre">myLocalVariable</span></code>、<code class="docutils literal"><span class="pre">myInstanceVariable_</span></code>。如果不能使用 Objective-C 2.0 的 <code class="docutils literal"><span class="pre">&#64;property</span></code>，使用 KVO/KVC 绑定的成员变量可以以一个下划线作为前缀。</p>
</div>
<div class="section" id="id8">
<h5>普通变量名</h5>
<p>对于静态的属性（<code class="docutils literal"><span class="pre">int</span></code> 或指针），不要使用匈牙利命名法。尽量为变量起一个描述性的名字。不要担心浪费列宽，因为让新的代码阅读者立即理解你的代码更重要。例如：</p>
<ul>
<li><p class="first">错误的命名：</p>
<blockquote>
<div><div class="highlight-objc"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">w</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">nerr</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">nCompConns</span><span class="p">;</span>
<span class="n">tix</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">someObject</span> <span class="n">object</span><span class="p">];</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">network</span> <span class="n">port</span><span class="p">];</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">正确的命名：</p>
<blockquote>
<div><div class="highlight-objc"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">numErrors</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">numCompletedConnections</span><span class="p">;</span>
<span class="n">tickets</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="n">userInfo</span> <span class="o">=</span> <span class="p">[</span><span class="n">someObject</span> <span class="n">object</span><span class="p">];</span>
<span class="n">port</span> <span class="o">=</span> <span class="p">[</span><span class="n">network</span> <span class="n">port</span><span class="p">];</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="id9">
<h5>实例变量</h5>
<p>实例变量应该混合大小写，并以下划线作为后缀，如 <code class="docutils literal"><span class="pre">usernameTextField_</span></code>。然而，如果不能使用 Objective-C 2.0（操作系统版本的限制），并且使用了 KVO/KVC 绑定成员变量时，我们允许例外（译者注： <code class="docutils literal"><span class="pre">KVO=Key</span> <span class="pre">Value</span> <span class="pre">Observing，KVC=Key</span> <span class="pre">Value</span> <span class="pre">Coding</span></code>）。这种情况下，可以以一个下划线作为成员变量名字的前缀，这是苹果所接受的键/值命名惯例。如果可以使用 Objective-C 2.0，<code class="docutils literal"><span class="pre">&#64;property</span></code> 以及 <code class="docutils literal"><span class="pre">&#64;synthesize</span></code> 提供了遵从这一命名规则的解决方案。</p>
</div>
<div class="section" id="id10">
<h5>常量</h5>
<p>常量名（如宏定义、枚举、静态局部变量等）应该以小写字母 <code class="docutils literal"><span class="pre">k</span></code> 开头，使用驼峰格式分隔单词，如：<code class="docutils literal"><span class="pre">kInvalidHandle，kWritePerm</span></code>。</p>
</div>
</div>
</div>
<span id="document-google-objc-styleguide/comments"></span><div class="section" id="id1">
<h3>注释</h3>
<p>虽然写起来很痛苦，但注释是保证代码可读性的关键。下面的规则给出了你应该什么时候、在哪进行注释。记住：尽管注释很重要，但最好的代码应该自成文档。与其给类型及变量起一个晦涩难懂的名字，再为它写注释，不如直接起一个有意义的名字。</p>
<p>当你写注释的时候，记得你是在给你的听众写，即下一个需要阅读你所写代码的贡献者。大方一点，下一个读代码的人可能就是你！</p>
<p>记住所有 C++ 风格指南里的规则在这里也同样适用，不同的之处后续会逐步指出。</p>
<div class="section" id="id2">
<h4>文件注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每个文件的开头以文件内容的简要描述起始，紧接着是作者，最后是版权声明和/或许可证样板。</p>
</div>
<div class="section" id="id3">
<h5>版权信息及作者</h5>
<p>每个文件应该按顺序包括如下项：</p>
<ul class="simple">
<li>文件内容的简要描述</li>
<li>代码作者</li>
<li>版权信息声明（如：<code class="docutils literal"><span class="pre">Copyright</span> <span class="pre">2008</span> <span class="pre">Google</span> <span class="pre">Inc.</span></code>）</li>
<li>必要的话，加上许可证样板。为项目选择一个合适的授权样板（例如，<code class="docutils literal"><span class="pre">Apache</span> <span class="pre">2.0,</span> <span class="pre">BSD,</span> <span class="pre">LGPL,</span> <span class="pre">GPL</span></code>）。</li>
</ul>
<p>如果你对其他人的原始代码作出重大的修改，请把你自己的名字添加到作者里面。当另外一个代码贡献者对文件有问题时，他需要知道怎么联系你，这十分有用。</p>
</div>
</div>
<div class="section" id="id4">
<h4>声明部分的注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每个接口、类别以及协议应辅以注释，以描述它的目的及与整个项目的关系。</p>
</div>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="c1">// A delegate for NSApplication to handle notifications about app</span>
<span class="c1">// launch and shutdown. Owned by the main app controller.</span>
<span class="k">@interface</span> <span class="nc">MyAppDelegate</span> : <span class="bp">NSObject</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>如果你已经在文件头部详细描述了接口，可以直接说明 “完整的描述请参见文件头部”，但是一定要有这部分注释。</p>
<p>另外，公共接口的每个方法，都应该有注释来解释它的作用、参数、返回值以及其它影响。</p>
<p>为类的线程安全性作注释，如果有的话。如果类的实例可以被多个线程访问，记得注释多线程条件下的使用规则。</p>
</div>
<div class="section" id="id5">
<h4>实现部分的注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 <code class="docutils literal"><span class="pre">|</span></code> 来引用注释中的变量名及符号名而不是使用引号。</p>
</div>
<p>这会避免二义性，尤其是当符号是一个常用词汇，这使用语句读起来很糟糕。例如，对于符号 <code class="docutils literal"><span class="pre">count</span></code> ：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="c1">// Sometimes we need |count| to be less than zero.</span>
</pre></div>
</div>
<p>或者当引用已经包含引号的符号：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="c1">// Remember to call |StringWithoutSpaces(&quot;foo bar baz&quot;)|</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>对象所有权</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">当与 Objective-C 最常规的作法不同时，尽量使指针的所有权模型尽量明确。</p>
</div>
<p>继承自 <code class="docutils literal"><span class="pre">NSObject</span></code> 的对象的实例变量指针，通常被假定是强引用关系（retained），某些情况下也可以注释为弱引用（weak）或使用 <code class="docutils literal"><span class="pre">__weak</span></code> 生命周期限定符。同样，声明的属性如果没有被类 <code class="docutils literal"><span class="pre">retained</span></code>，必须指定是弱引用或赋予 <code class="docutils literal"><span class="pre">&#64;property</span></code> 属性。然而，Mac 软件中标记上 <code class="docutils literal"><span class="pre">IBOutlets</span></code> 的实例变量，被认为是不会被类 <code class="docutils literal"><span class="pre">retained</span></code> 的。</p>
<p>当实例变量指向 <code class="docutils literal"><span class="pre">CoreFoundation</span></code>、C++ 或者其它非 Objective-C 对象时，不论指针是否会被 <code class="docutils literal"><span class="pre">retained</span></code>，都需要使用 <code class="docutils literal"><span class="pre">__strong</span></code> 和 <code class="docutils literal"><span class="pre">__weak</span></code> 类型修饰符明确指明。<code class="docutils literal"><span class="pre">CoreFoundation</span></code> 和其它非 Objective-C 对象指针需要显式的内存管理，即便使用了自动引用计数或垃圾回收机制。当不允许使用 <code class="docutils literal"><span class="pre">__weak</span></code> 类型修饰符（比如，使用 clang 编译时的 C++ 成员变量），应使用注释替代说明。</p>
<p>注意：Objective-C 对象中的 C++ 对象的自动封装，缺省是不允许的，参见 <a class="reference external" href="http://chanson.livejournal.com/154253.html">这里</a> 的说明。</p>
<p>强引用及弱引用声明的例子：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">MyDelegate</span> : <span class="bp">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="kt">IBOutlet</span> <span class="n">NSButton</span> <span class="o">*</span><span class="n">okButton_</span><span class="p">;</span>  <span class="c1">// normal NSControl; implicitly weak on Mac only</span>

  <span class="n">AnObjcObject</span><span class="o">*</span> <span class="n">doohickey_</span><span class="p">;</span>  <span class="c1">// my doohickey</span>
  <span class="k">__weak</span> <span class="n">MyObjcParent</span> <span class="o">*</span><span class="n">parent_</span><span class="p">;</span>  <span class="c1">// so we can send msgs back (owns me)</span>

  <span class="c1">// non-NSObject pointers...</span>
  <span class="k">__strong</span> <span class="n">CWackyCPPClass</span> <span class="o">*</span><span class="n">wacky_</span><span class="p">;</span>  <span class="c1">// some cross-platform object</span>
  <span class="k">__strong</span> <span class="n">CFDictionaryRef</span> <span class="o">*</span><span class="n">dict_</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@property</span><span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">doohickey</span><span class="p">;</span>
<span class="k">@property</span><span class="p">(</span><span class="k">weak</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>（译注：强引用 - 对象被类 <code class="docutils literal"><span class="pre">retained</span></code>。弱引用 - 对象没有被类 <code class="docutils literal"><span class="pre">retained</span></code>，如委托）</p>
</div>
</div>
<span id="document-google-objc-styleguide/features"></span><div class="section" id="cocoa-objective-c">
<h3>Cocoa 和 Objective-C 特性</h3>
<div class="section" id="private">
<h4>成员变量应该是 <code class="docutils literal"><span class="pre">&#64;private</span></code></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">成员变量应该声明为 <code class="docutils literal"><span class="pre">&#64;private</span></code></p>
</div>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="bp">MyClass</span> : <span class="bp">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="kt">id</span> <span class="n">myInstanceVariable_</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// public accessors, setter takes ownership</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">myInstanceVariable</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setMyInstanceVariable:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">theVar</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
<div class="section" id="id1">
<h4>明确指定构造函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">注释并且明确指定你的类的构造函数。</p>
</div>
<p>对于需要继承你的类的人来说，明确指定构造函数十分重要。这样他们就可以只重写一个构造函数（可能是几个）来保证他们的子类的构造函数会被调用。这也有助于将来别人调试你的类时，理解初始化代码的工作流程。</p>
</div>
<div class="section" id="id2">
<h4>重载指定构造函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">当你写子类的时候，如果需要 <code class="docutils literal"><span class="pre">init…</span></code> 方法，记得重载父类的指定构造函数。</p>
</div>
<p>如果你没有重载父类的指定构造函数，你的构造函数有时可能不会被调用，这会导致非常隐秘而且难以解决的 bug。</p>
</div>
<div class="section" id="nsobject">
<h4>重载 <code class="docutils literal"><span class="pre">NSObject</span></code> 的方法</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如果重载了 <code class="docutils literal"><span class="pre">NSObject</span></code> 类的方法，强烈建议把它们放在 <code class="docutils literal"><span class="pre">&#64;implementation</span></code> 内的起始处，这也是常见的操作方法。</p>
</div>
<p>通常适用（但不局限）于 <code class="docutils literal"><span class="pre">init...</span></code>，<code class="docutils literal"><span class="pre">copyWithZone:</span></code>，以及 <code class="docutils literal"><span class="pre">dealloc</span></code> 方法。所有 <code class="docutils literal"><span class="pre">init...</span></code> 方法应该放在一起，<code class="docutils literal"><span class="pre">copyWithZone:</span></code> 紧随其后，最后才是 <code class="docutils literal"><span class="pre">dealloc</span></code> 方法。</p>
</div>
<div class="section" id="id3">
<h4>初始化</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要在 init 方法中，将成员变量初始化为 <code class="docutils literal"><span class="pre">0</span></code> 或者 <code class="docutils literal"><span class="pre">nil</span></code>；毫无必要。</p>
</div>
<p>刚分配的对象，默认值都是 0，除了 <code class="docutils literal"><span class="pre">isa</span></code> 指针（译者注：<code class="docutils literal"><span class="pre">NSObject</span></code> 的 <code class="docutils literal"><span class="pre">isa</span></code> 指针，用于标识对象的类型）。所以不要在初始化器里面写一堆将成员初始化为 <code class="docutils literal"><span class="pre">0</span></code> 或者 <code class="docutils literal"><span class="pre">nil</span></code> 的代码。</p>
</div>
<div class="section" id="new">
<h4>避免 <code class="docutils literal"><span class="pre">+new</span></code></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要调用 <code class="docutils literal"><span class="pre">NSObject</span></code> 类方法 <code class="docutils literal"><span class="pre">new</span></code>，也不要在子类中重载它。使用 <code class="docutils literal"><span class="pre">alloc</span></code> 和 <code class="docutils literal"><span class="pre">init</span></code> 方法创建并初始化对象。</p>
</div>
<p>现代的 Ojbective-C 代码通过调用 <code class="docutils literal"><span class="pre">alloc</span></code> 和 <code class="docutils literal"><span class="pre">init</span></code> 方法来创建并 retain 一个对象。由于类方法 <code class="docutils literal"><span class="pre">new</span></code> 很少使用，这使得有关内存分配的代码审查更困难。</p>
</div>
<div class="section" id="api">
<h4>保持公共 API 简单</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">保持类简单；避免 “厨房水槽（kitchen-sink）” 式的 API。如果一个函数压根没必要公开，就不要这么做。用私有类别保证公共头文件整洁。</p>
</div>
<p>与 C++ 不同，Objective-C 没有方法来区分公共的方法和私有的方法 &#8211; 所有的方法都是公共的（译者注：这取决于 Objective-C 运行时的方法调用的消息机制）。因此，除非客户端的代码期望使用某个方法，不要把这个方法放进公共 API 中。尽可能的避免了你你不希望被调用的方法却被调用到。这包括重载父类的方法。对于内部实现所需要的方法，在实现的文件中定义一个类别，而不是把它们放进公有的头文件中。</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="c1">// GTMFoo.m</span>
<span class="cp">#import &quot;GTMFoo.h&quot;</span>

<span class="k">@interface</span> <span class="nc">GTMFoo</span> <span class="nl">(PrivateDelegateHandling)</span>
<span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">doSomethingWithDelegate</span><span class="p">;</span>  <span class="c1">// Declare private method</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">GTMFoo</span><span class="nl">(PrivateDelegateHandling)</span>
<span class="p">...</span>
<span class="o">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">doSomethingWithDelegate</span> <span class="p">{</span>
  <span class="c1">// Implement this method</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>Objective-C 2.0 以前，如果你在私有的 <code class="docutils literal"><span class="pre">&#64;interface</span></code> 中声明了某个方法，但在 <code class="docutils literal"><span class="pre">&#64;implementation</span></code> 中忘记定义这个方法，编译器不会抱怨（这是因为你没有在其它的类别中实现这个私有的方法）。解决文案是将方法放进指定类别的 <code class="docutils literal"><span class="pre">&#64;implemenation</span></code> 中。</p>
<p>如果你在使用 Objective-C 2.0，相反你应该使用 <a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/Articles/chapter_4_section_5.html">类扩展</a> 来声明你的私有类别，例如：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">GMFoo</span> <span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>这么做确保如果声明的方法没有在 <code class="docutils literal"><span class="pre">&#64;implementation</span></code> 中实现，会触发一个编译器告警。</p>
<p>再次说明，“私有的” 方法其实不是私有的。你有时可能不小心重载了父类的私有方法，因而制造出很难查找的 Bug。通常，私有的方法应该有一个相当特殊的名字以防止子类无意地重载它们。</p>
<p>Ojbective-C 的类别可以用来将一个大的 <code class="docutils literal"><span class="pre">&#64;implementation</span></code> 拆分成更容易理解的小块，同时，类别可以为最适合的类添加新的、特定应用程序的功能。例如，当添加一个 “middle truncation” 方法时，创建一个 <code class="docutils literal"><span class="pre">NSString</span></code> 的新类别并把方法放在里面，要比创建任意的一个新类把方法放进里面好得多。</p>
</div>
<div class="section" id="import-and-include">
<h4><code class="docutils literal"><span class="pre">#import</span></code> and <code class="docutils literal"><span class="pre">#include</span></code></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><code class="docutils literal"><span class="pre">#import</span></code> Ojbective-C/Objective-C++ 头文件，<code class="docutils literal"><span class="pre">#include</span></code> C/C++ 头文件。</p>
</div>
<p>基于你所包括的头文件的编程语言，选择使用 <code class="docutils literal"><span class="pre">#import</span></code> 或是 <code class="docutils literal"><span class="pre">#include</span></code>：</p>
<ul class="simple">
<li>当包含一个使用 Objective-C、Objective-C++ 的头文件时，使用 <code class="docutils literal"><span class="pre">#import</span></code> 。</li>
<li>当包含一个使用标准 C、C++ 头文件时，使用 <code class="docutils literal"><span class="pre">#include</span></code>。头文件应该使用 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=The__define_Guard#The__define_Guard">#define 保护</a>。</li>
</ul>
<p>一些 Ojbective-C 的头文件缺少 <code class="docutils literal"><span class="pre">#define</span></code> 保护，需要使用 <code class="docutils literal"><span class="pre">#import</span></code> 的方式包含。由于 Objective-C 的头文件只会被 Objective-C 的源文件及头文件包含，广泛地使用 <code class="docutils literal"><span class="pre">#import</span></code> 是可以的。</p>
<p>文件中没有 Objective-C 代码的标准 C、C++ 头文件，很可能会被普通的 C、C++ 包含。由于标准 C、C++ 里面没有 <code class="docutils literal"><span class="pre">#import</span></code> 的用法，这些文件将被 <code class="docutils literal"><span class="pre">#include</span></code>。在 Objective-C 源文件中使用 <code class="docutils literal"><span class="pre">#include</span></code> 包含这些头文件，意味着这些头文件永远会在相同的语义下包含。</p>
<p>这条规则帮助跨平台的项目避免低级错误。某个 Mac 开发者写了一个新的 C 或 C++ 头文件，如果忘记使用 <code class="docutils literal"><span class="pre">#define</span></code> 保护，在 Mac 下使用 <code class="docutils literal"><span class="pre">#import</span></code> 这个头文件不回引起问题，但是在其它平台下使用 <code class="docutils literal"><span class="pre">#include</span></code> 将可能编译失败。在所有的平台上统一使用 <code class="docutils literal"><span class="pre">#include</span></code>，意味着构造更可能全都成功或者失败，防止这些文件只能在某些平台下能够工作。</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="cp">#import &lt;Cocoa/Cocoa.h&gt;</span>
<span class="cp">#include</span> <span class="cpf">&lt;CoreFoundation/CoreFoundation.h&gt;</span><span class="cp"></span>
<span class="cp">#import &quot;GTMFoo.h&quot;</span>
<span class="cp">#include</span> <span class="cpf">&quot;base/basictypes.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>使用根框架</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><code class="docutils literal"><span class="pre">#import</span></code> 根框架而不是单独的零散文件</p>
</div>
<p>当你试图从框架（如 Cocoa 或者 Foundation）中包含若干零散的系统头文件时，实际上包含顶层根框架的话，编译器要做的工作更少。根框架通常已经经过预编译，加载更快。另外记得使用 <code class="docutils literal"><span class="pre">#import</span></code> 而不是 <code class="docutils literal"><span class="pre">#include</span></code> 来包含 Objective-C 的框架。</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="cp">#import &lt;Foundation/Foundation.h&gt;     </span><span class="c1">// good</span>

<span class="cp">#import &lt;Foundation/NSArray.h&gt;        </span><span class="c1">// avoid</span>
<span class="cp">#import &lt;Foundation/NSString.h&gt;</span>
<span class="p">...</span>
</pre></div>
</div>
</div>
<div class="section" id="autorelease">
<h4>构建时即设定 <code class="docutils literal"><span class="pre">autorelease</span></code></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">当创建临时对象时，在同一行使用 <code class="docutils literal"><span class="pre">autolease</span></code>，而不是在同一个方法的后面语句中使用一个单独的 <code class="docutils literal"><span class="pre">release</span></code>。</p>
</div>
<p>尽管运行效率会差一点，但避免了意外删除 <code class="docutils literal"><span class="pre">release</span></code> 或者插入 <code class="docutils literal"><span class="pre">return</span></code> 语句而导致内存泄露的可能。例如：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="c1">// AVOID (unless you have a compelling performance reason)</span>
<span class="n">MyController</span><span class="o">*</span> <span class="n">controller</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyController</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="c1">// ... code here that might return ...</span>
<span class="p">[</span><span class="n">controller</span> <span class="k">release</span><span class="p">];</span>

<span class="c1">// BETTER</span>
<span class="n">MyController</span><span class="o">*</span> <span class="n">controller</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">MyController</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
</pre></div>
</div>
</div>
<div class="section" id="autorelease-retain">
<h4><code class="docutils literal"><span class="pre">autorelease</span></code> 优先 <code class="docutils literal"><span class="pre">retain</span></code> 其次</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">给对象赋值时遵守 <code class="docutils literal"><span class="pre">autorelease``之后</span> <span class="pre">``retain</span></code> 的模式。</p>
</div>
<p>当给一个变量赋值新的对象时，必须先释放掉旧的对象以避免内存泄露。有很多 “正确的” 方法可以处理这种情况。我们则选择 “<code class="docutils literal"><span class="pre">autorelease</span></code> 之后 <code class="docutils literal"><span class="pre">retain</span></code>” 的方法，因为事实证明它不容易出错。注意大的循环会填满 <code class="docutils literal"><span class="pre">autorelease</span></code> 池，并且可能效率上会差一点，但权衡之下我们认为是可以接受的。</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setFoo:</span><span class="p">(</span><span class="n">GMFoo</span> <span class="o">*</span><span class="p">)</span><span class="nv">aFoo</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">foo_</span> <span class="n">autorelease</span><span class="p">];</span>  <span class="c1">// Won&#39;t dealloc if |foo_| == |aFoo|</span>
  <span class="n">foo_</span> <span class="o">=</span> <span class="p">[</span><span class="n">aFoo</span> <span class="k">retain</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="init-dealloc">
<h4><code class="docutils literal"><span class="pre">init</span></code> 和 <code class="docutils literal"><span class="pre">dealloc</span></code> 内避免使用访问器</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">在 <code class="docutils literal"><span class="pre">init</span></code> 和 <code class="docutils literal"><span class="pre">dealloc</span></code> 方法执行的过程中，子类可能会处在一个不一致的状态，所以这些方法中的代码应避免调用访问器。</p>
</div>
<p>子类尚未初始化，或在 <code class="docutils literal"><span class="pre">init</span></code> 和 <code class="docutils literal"><span class="pre">dealloc</span></code> 方法执行时已经被销毁，会使访问器方法很可能不可靠。实际上，应在这些方法中直接对 ivals 进行赋值或释放操作。</p>
<p>正确：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
  <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bar_</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSMutableString</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>  <span class="c1">// good</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">bar_</span> <span class="k">release</span><span class="p">];</span>                           <span class="c1">// good</span>
  <span class="p">[</span><span class="nb">super</span> <span class="n">dealloc</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
  <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">self</span><span class="p">.</span><span class="n">bar</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableString</span> <span class="n">string</span><span class="p">];</span>  <span class="c1">// avoid</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
  <span class="nb">self</span><span class="p">.</span><span class="n">bar</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>                         <span class="c1">// avoid</span>
  <span class="p">[</span><span class="nb">super</span> <span class="n">dealloc</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>按声明顺序销毁实例变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><code class="docutils literal"><span class="pre">dealloc</span></code> 中实例变量被释放的顺序应该与它们在 <code class="docutils literal"><span class="pre">&#64;interface</span></code> 中声明的顺序一致，这有助于代码审查。</p>
</div>
<p>代码审查者在评审新的或者修改过的 <code class="docutils literal"><span class="pre">dealloc</span></code> 实现时，需要保证每个 <code class="docutils literal"><span class="pre">retained</span></code> 的实例变量都得到了释放。</p>
<p>为了简化 <code class="docutils literal"><span class="pre">dealloc</span></code> 的审查，<code class="docutils literal"><span class="pre">retained</span></code> 实例变量被释放的顺序应该与他们在 <code class="docutils literal"><span class="pre">&#64;interface</span></code> 中声明的顺序一致。如果 <code class="docutils literal"><span class="pre">dealloc</span></code> 调用了其它方法释放成员变量，添加注释解释这些方法释放了哪些实例变量。</p>
</div>
<div class="section" id="setter-nsstrings">
<h4><code class="docutils literal"><span class="pre">setter</span></code> 应复制 NSStrings</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">接受 <code class="docutils literal"><span class="pre">NSString</span></code> 作为参数的 <code class="docutils literal"><span class="pre">setter</span></code>，应该总是 <code class="docutils literal"><span class="pre">copy</span></code> 传入的字符串。</p>
</div>
<p>永远不要仅仅 <code class="docutils literal"><span class="pre">retain</span></code> 一个字符串。因为调用者很可能在你不知情的情况下修改了字符串。不要假定别人不会修改，你接受的对象是一个 <code class="docutils literal"><span class="pre">NSString</span></code> 对象而不是 <code class="docutils literal"><span class="pre">NSMutableString</span></code> 对象。</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setFoo:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">aFoo</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">foo_</span> <span class="n">autorelease</span><span class="p">];</span>
  <span class="n">foo_</span> <span class="o">=</span> <span class="p">[</span><span class="n">aFoo</span> <span class="k">copy</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="avoid-throwing-exceptions">
<span id="id7"></span><h4>避免抛异常</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要 <code class="docutils literal"><span class="pre">&#64;throw</span></code> Objective-C 异常，同时也要时刻准备捕获从第三方或 OS 代码中抛出的异常。</p>
</div>
<p>我们的确允许 <code class="docutils literal"><span class="pre">-fobjc-exceptions</span></code> 编译开关（主要因为我们要用到 <code class="docutils literal"><span class="pre">&#64;synchronized</span></code> ），但我们不使用 <code class="docutils literal"><span class="pre">&#64;throw</span></code>。为了合理使用第三方的代码，<code class="docutils literal"><span class="pre">&#64;try</span></code>、<code class="docutils literal"><span class="pre">&#64;catch</span></code> 和 <code class="docutils literal"><span class="pre">&#64;finally</span></code> 是允许的。如果你确实使用了异常，请明确注释你期望什么方法抛出异常。</p>
<p>不要使用 <code class="docutils literal"><span class="pre">NS_DURING</span></code>、<code class="docutils literal"><span class="pre">NS_HANDLER</span></code>、<code class="docutils literal"><span class="pre">NS_ENDHANDLER</span></code>、<code class="docutils literal"><span class="pre">NS_VALUERETURN</span></code> 和 <code class="docutils literal"><span class="pre">NS_VOIDRETURN</span></code> 宏，除非你写的代码需要在 Mac OS X 10.2 或之前的操作系统中运行。</p>
<p>注意：如果抛出 Objective-C 异常，Objective-C++ 代码中基于栈的对象不会被销毁。比如：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">exceptiontest</span> <span class="p">{</span>
 <span class="nl">public</span><span class="p">:</span>
  <span class="n">exceptiontest</span><span class="p">()</span> <span class="p">{</span> <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Created&quot;</span><span class="p">);</span> <span class="p">}</span>
  <span class="o">~</span><span class="n">exceptiontest</span><span class="p">()</span> <span class="p">{</span> <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Destroyed&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">exceptiontest</span> <span class="n">a</span><span class="p">;</span>
  <span class="bp">NSException</span> <span class="o">*</span><span class="n">exception</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSException</span> <span class="nl">exceptionWithName</span><span class="p">:</span><span class="s">@&quot;foo&quot;</span>
                                                   <span class="nl">reason</span><span class="p">:</span><span class="s">@&quot;bar&quot;</span>
                                                 <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
  <span class="k">@throw</span> <span class="n">exception</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="n">GMAutoreleasePool</span> <span class="n">pool</span><span class="p">;</span>
  <span class="k">@try</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">@catch</span><span class="p">(</span><span class="bp">NSException</span> <span class="o">*</span><span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;exception raised&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>会输出：</p>
<p>注意：这里析构函数从未被调用。这主要会影响基于栈的 <code class="docutils literal"><span class="pre">smartptr</span></code>，比如 <code class="docutils literal"><span class="pre">shared_ptr</span></code>、<code class="docutils literal"><span class="pre">linked_ptr</span></code>，以及所有你可能用到的 STL 对象。因此我们不得不痛苦的说，如果必须在 Objective-C++ 中使用异常，就只用 C++ 的异常机制。永远不应该重新抛出 Objective-C 异常，也不应该在 <code class="docutils literal"><span class="pre">&#64;try</span></code>、<code class="docutils literal"><span class="pre">&#64;catch</span></code> 或 <code class="docutils literal"><span class="pre">&#64;finally</span></code> 语句块中使用基于栈的 C++ 对象。</p>
</div>
<div class="section" id="nil">
<h4>nil 检查</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><code class="docutils literal"><span class="pre">nil</span></code> 检查只用在逻辑流程中。</p>
</div>
<p>使用 <code class="docutils literal"><span class="pre">nil</span></code> 的检查来检查应用程序的逻辑流程，而不是避免崩溃。Objective-C 运行时会处理向 <code class="docutils literal"><span class="pre">nil</span></code> 对象发送消息的情况。如果方法没有返回值，就没关系。如果有返回值，可能由于运行时架构、返回值类型以及 OS X 版本的不同而不同，参见 <a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/Articles/chapter_2_section_3.html">Apple’s documentation</a> 。</p>
<p>注意，这和 C/C++ 中检查指针是否为 ‵‵NULL`` 很不一样，C/C++ 运行时不做任何检查，从而导致应用程序崩溃。因此你仍然需要保证你不会对一个 C/C++ 的空指针解引用。</p>
</div>
<div class="section" id="bool">
<h4>BOOL 若干陷阱</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">将普通整形转换成 <code class="docutils literal"><span class="pre">BOOL</span></code> 时要小心。不要直接将 <code class="docutils literal"><span class="pre">BOOL</span></code> 值与 <code class="docutils literal"><span class="pre">YES</span></code> 进行比较。</p>
</div>
<p>Ojbective-C 中把 <code class="docutils literal"><span class="pre">BOOL</span></code> 定义成无符号字符型，这意味着 <code class="docutils literal"><span class="pre">BOOL</span></code> 类型的值远不止 <code class="docutils literal"><span class="pre">YES``(1)或</span> <span class="pre">``NO``(0)。不要直接把整形转换成</span> <span class="pre">``BOOL</span></code>。常见的错误包括将数组的大小、指针值及位运算的结果直接转换成 <code class="docutils literal"><span class="pre">BOOL</span></code> ，取决于整型结果的最后一个字节，很可能会产生一个 <code class="docutils literal"><span class="pre">NO</span></code> 值。当转换整形至 <code class="docutils literal"><span class="pre">BOOL</span></code> 时，使用三目操作符来返回 <code class="docutils literal"><span class="pre">YES</span></code> 或者 <code class="docutils literal"><span class="pre">NO</span></code>。（译者注：读者可以试一下任意的 256 的整数的转换结果，如 256、512 …）</p>
<p>你可以安全在 <code class="docutils literal"><span class="pre">BOOL</span></code>、<code class="docutils literal"><span class="pre">_Bool</span></code> 以及 <code class="docutils literal"><span class="pre">bool</span></code> 之间转换（参见 C++ Std 4.7.4, 4.12 以及 C99 Std 6.3.1.2）。你不能安全在 <code class="docutils literal"><span class="pre">BOOL</span></code> 以及 <code class="docutils literal"><span class="pre">Boolean</span></code> 之间转换，因此请把 <code class="docutils literal"><span class="pre">Boolean</span></code> 当作一个普通整形，就像之前讨论的那样。但 Objective-C 的方法标识符中，只使用 <code class="docutils literal"><span class="pre">BOOL</span></code>。</p>
<p>对 <code class="docutils literal"><span class="pre">BOOL</span></code> 使用逻辑运算符（<code class="docutils literal"><span class="pre">&amp;&amp;</span></code>，<code class="docutils literal"><span class="pre">||</span></code> 和 <code class="docutils literal"><span class="pre">!</span></code>）是合法的，返回值也可以安全地转换成 <code class="docutils literal"><span class="pre">BOOL</span></code>，不需要使用三目操作符。</p>
<p>错误的用法：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isBold</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="n">fontTraits</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">NSFontBoldTrait</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isValid</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="n">stringValue</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>正确的用法：</p>
<blockquote>
<div><div class="highlight-objc"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<ul class="simple">
<li>(BOOL)isBold {
return ([self fontTraits] &amp; NSFontBoldTrait) ? YES : NO;</li>
</ul>
<p>}
- (BOOL)isValid {</p>
<blockquote>
<div>return [self stringValue] != nil;</div></blockquote>
<p>}
- (BOOL)isEnabled {</p>
<blockquote>
<div>return [self isValid] &amp;&amp; [self isBold];</div></blockquote>
<p>}</p>
</div></blockquote>
<p>同样，不要直接比较 <code class="docutils literal"><span class="pre">YES/NO</span></code> 和 <code class="docutils literal"><span class="pre">BOOL</span></code> 变量。不仅仅因为影响可读性，更重要的是结果可能与你想的不同。</p>
<p>错误的用法：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="kt">BOOL</span> <span class="n">great</span> <span class="o">=</span> <span class="p">[</span><span class="n">foo</span> <span class="n">isGreat</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">great</span> <span class="o">==</span> <span class="nb">YES</span><span class="p">)</span>
  <span class="c1">// ...be great!</span>
</pre></div>
</div>
<p>正确的用法：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="kt">BOOL</span> <span class="n">great</span> <span class="o">=</span> <span class="p">[</span><span class="n">foo</span> <span class="n">isGreat</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">great</span><span class="p">)</span>
  <span class="c1">// ...be great!</span>
</pre></div>
</div>
</div>
<div class="section" id="property">
<h4>属性（Property）</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">属性（Property）通常允许使用，但需要清楚的了解：属性（Property）是 Objective-C 2.0 的特性，会限制你的代码只能跑在 iPhone 和 Mac OS X 10.5 (Leopard) 及更高版本上。点引用只允许访问声明过的 <code class="docutils literal"><span class="pre">&#64;property</span></code>。</p>
</div>
<div class="section" id="id8">
<h5>命名</h5>
<p>属性所关联的实例变量的命名必须遵守以下划线作为后缀的规则。属性的名字应该与成员变量去掉下划线后缀的名字一模一样。</p>
<p>使用 <code class="docutils literal"><span class="pre">&#64;synthesize</span></code> 指示符来正确地重命名属性。</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="bp">MyClass</span> : <span class="bp">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="bp">NSString</span> <span class="o">*</span><span class="n">name_</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@property</span><span class="p">(</span><span class="k">copy</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="bp">MyClass</span>
<span class="k">@synthesize</span> <span class="n">name</span> <span class="o">=</span> <span class="n">name_</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h5>位置</h5>
<p>属性的声明必须紧靠着类接口中的实例变量语句块。属性的定义必须在 <code class="docutils literal"><span class="pre">&#64;implementation</span></code> 的类定义的最上方。他们的缩进与包含他们的 <code class="docutils literal"><span class="pre">&#64;interface</span></code> 以及 <code class="docutils literal"><span class="pre">&#64;implementation</span></code> 语句一样。</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="bp">MyClass</span> : <span class="bp">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="bp">NSString</span> <span class="o">*</span><span class="n">name_</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@property</span><span class="p">(</span><span class="k">copy</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="bp">MyClass</span>
<span class="k">@synthesize</span> <span class="n">name</span> <span class="o">=</span> <span class="n">name_</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
<div class="section" id="copy-attribute">
<h5>字符串应使用 <code class="docutils literal"><span class="pre">copy</span></code> 属性（Attribute）</h5>
<p>应总是用 <code class="docutils literal"><span class="pre">copy</span></code> 属性（attribute）声明 <code class="docutils literal"><span class="pre">NSString</span></code> 属性（property）。</p>
<p>从逻辑上，确保遵守 <code class="docutils literal"><span class="pre">NSString</span></code> 的 <code class="docutils literal"><span class="pre">setter</span></code> 必须使用 <code class="docutils literal"><span class="pre">copy</span></code> 而不是 <code class="docutils literal"><span class="pre">retain</span></code> 的原则。</p>
</div>
<div class="section" id="id10">
<h5>原子性</h5>
<p>一定要注意属性（property）的开销。缺省情况下，所有 <code class="docutils literal"><span class="pre">synthesize</span></code> 的 <code class="docutils literal"><span class="pre">setter</span></code> 和 <code class="docutils literal"><span class="pre">getter</span></code> 都是原子的。这会给每个 <code class="docutils literal"><span class="pre">get</span></code> 或者 <code class="docutils literal"><span class="pre">set</span></code> 带来一定的同步开销。将属性（property）声明为 <code class="docutils literal"><span class="pre">nonatomic</span></code>，除非你需要原子性。</p>
</div>
<div class="section" id="id11">
<h5>点引用</h5>
<p>点引用是地道的 Objective-C 2.0 风格。它被使用于简单的属性 <code class="docutils literal"><span class="pre">set</span></code>、<code class="docutils literal"><span class="pre">get</span></code> 操作，但不应该用它来调用对象的其它操作。</p>
<p>正确的做法：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="bp">NSString</span> <span class="o">*</span><span class="n">oldName</span> <span class="o">=</span> <span class="n">myObject</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="n">myObject</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">@&quot;Alice&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>错误的做法：</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="bp">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSArray</span> <span class="nl">arrayWithObject</span><span class="p">:</span><span class="s">@&quot;hello&quot;</span><span class="p">]</span> <span class="k">retain</span><span class="p">];</span>

<span class="n">NSUInteger</span> <span class="n">numberOfItems</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>  <span class="c1">// not a property</span>
<span class="n">array</span><span class="p">.</span><span class="k">release</span><span class="p">;</span>                           <span class="c1">// not a property</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id12">
<h4>没有实例变量的接口</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">没有声明任何实例变量的接口，应省略空花括号。</p>
</div>
<p>正确的做法：</p>
<blockquote>
<div>&#64;interface MyClass : NSObject
// Does a lot of stuff
- (void)fooBarBam;
&#64;end</div></blockquote>
<p>错误的做法：</p>
<blockquote>
<div>&#64;interface MyClass : NSObject {
}
// Does a lot of stuff
- (void)fooBarBam;
&#64;end</div></blockquote>
</div>
<div class="section" id="synthesize">
<h4>自动 <code class="docutils literal"><span class="pre">synthesize</span></code> 实例变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只运行在 iOS 下的代码，优先考虑使用自动 <code class="docutils literal"><span class="pre">synthesize</span></code> 实例变量。</p>
</div>
<p><code class="docutils literal"><span class="pre">synthesize</span></code> 实例变量时，使用 <code class="docutils literal"><span class="pre">&#64;synthesize</span> <span class="pre">var</span> <span class="pre">=</span> <span class="pre">var_;</span></code> 防止原本想调用 <code class="docutils literal"><span class="pre">self.var</span> <span class="pre">=</span> <span class="pre">blah;</span></code> 却不慎写成了 <code class="docutils literal"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">blah;</span></code>。</p>
<p>不要synthesize CFType的属性 CFType应该永远使用&#64;dynamic实现指示符。 尽管CFType不能使用retain属性特性，开发者必须自己处理retain和release。很少有情况你需要仅仅对它进行赋值，因此最好显示地实现getter和setter，并作出注释说明。 列出所有的实现指示符 尽管&#64;dynamic是默认的，显示列出它以及其它的实现指示符会提高可读性，代码阅读者可以一眼就知道类的每个属性是如何实现的。</p>
<div class="highlight-objc"><div class="highlight"><pre><span></span><span class="c1">// Header file</span>
<span class="k">@interface</span> <span class="nc">Foo</span> : <span class="bp">NSObject</span>
<span class="c1">// A guy walks into a bar.</span>
<span class="k">@property</span><span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">bar</span><span class="p">;</span>
<span class="k">@end</span>

<span class="c1">// Implementation file</span>
<span class="k">@interface</span> <span class="nc">Foo</span> <span class="p">()</span>
<span class="k">@property</span><span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">retain</span><span class="p">)</span> <span class="bp">NSArray</span> <span class="o">*</span><span class="n">baz</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo</span>
<span class="k">@synthesize</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">bar_</span><span class="p">;</span>
<span class="k">@synthesize</span> <span class="n">baz</span> <span class="o">=</span> <span class="n">baz_</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-objc-styleguide/patterns"></span><div class="section" id="cocoa">
<h3>Cocoa 模式</h3>
<div class="section" id="id1">
<h4>委托模式</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">委托对象不应该被 <code class="docutils literal"><span class="pre">retain</span></code></p>
</div>
<p>实现委托模式的类应：</p>
<ol class="arabic simple">
<li>拥有一个名为 <code class="docutils literal"><span class="pre">delegate_</span></code> 的实例变量来引用委托。</li>
<li>因此，访问器方法应该命名为 <code class="docutils literal"><span class="pre">delegate</span></code> 和 <code class="docutils literal"><span class="pre">setDelegate:</span></code>。</li>
<li><code class="docutils literal"><span class="pre">delegate_</span></code> 对象不应该被 <code class="docutils literal"><span class="pre">retain</span></code>。</li>
</ol>
</div>
<div class="section" id="mvc">
<h4>模型/视图/控制器（MVC）</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">分离模型与视图。分离控制器与视图、模型。回调 API 使用 <code class="docutils literal"><span class="pre">&#64;protocol</span></code>。</p>
</div>
<ul class="simple">
<li>分离模型与视图：不要假设模型或者数据源的表示方法。保持数据源与表示层之间的接口抽象。视图不需要了解模型的逻辑（主要的规则是问问你自己，对于数据源的一个实例，有没有可能有多种不同状态的表示方法）。</li>
<li>分离控制器与模型、视图：不要把所有的 “业务逻辑” 放进跟视图有关的类中。这使代码非常难以复用。使用控制器类来处理这些代码，但保证控制器不需要了解太多表示层的逻辑。</li>
<li>使用 <code class="docutils literal"><span class="pre">&#64;protocol</span></code> 来定义回调 API，如果不是所有的方法都必须实现，使用 <code class="docutils literal"><span class="pre">&#64;optional``（特例：使用</span> <span class="pre">Objective-C</span> <span class="pre">1.0</span> <span class="pre">时，``&#64;optional</span></code> 不可用，可使用类别来定义一个 “非正规的协议”）。</li>
</ul>
</div>
</div>
</div>
</div>
<span id="document-google-python-styleguide/contents"></span><div class="section" id="python">
<span id="python-contents"></span><h2>Python 风格指南 - 内容目录</h2>
<div class="toctree-wrapper compound">
<span id="document-google-python-styleguide/index"></span><div class="section" id="id1">
<h3>扉页</h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">版本:</th><td class="field-body"><p class="first">2.59</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">原作者:</th><td class="field-body"><div class="first line-block">
<div class="line">Amit Patel</div>
<div class="line">Antoine Picard</div>
<div class="line">Eugene Jhong</div>
<div class="line">Jeremy Hylton</div>
<div class="line">Matt Smart</div>
<div class="line">Mike Shields</div>
</div>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">翻译:</th><td class="field-body"><div class="first line-block">
<div class="line"><a class="reference external" href="http://guoqiao.me/">guoqiao</a> v2.19</div>
<div class="line"><a class="reference external" href="https://github.com/xuxinkun">xuxinkun</a> v2.59</div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">项目主页:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference external" href="https://github.com/google/styleguide">Google Style Guide</a></li>
<li><a class="reference external" href="http://github.com/zh-google-styleguide/zh-google-styleguide">Google 开源项目风格指南 - 中文版</a></li>
</ul>
</td>
</tr>
</tbody>
</table>
</div>
<span id="document-google-python-styleguide/background"></span><div class="section" id="id1">
<h3>背景</h3>
<p>Python 是 Google主要的脚本语言。这本风格指南主要包含的是针对python的编程准则。</p>
<p>为帮助读者能够将代码准确格式化，我们提供了针对 <a class="reference external" href="https://github.com/google/styleguide/blob/gh-pages/google_python_style.vim">Vim的配置文件</a> 。对于Emacs用户，保持默认设置即可。</p>
</div>
<span id="document-google-python-styleguide/python_language_rules"></span><div class="section" id="python">
<h3>Python语言规范</h3>
<div class="section" id="lint">
<h4>Lint</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">对你的代码运行pylint</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>pylint是一个在Python源代码中查找bug的工具. 对于C和C++这样的不那么动态的(译者注: 原文是less dynamic)语言, 这些bug通常由编译器来捕获. 由于Python的动态特性, 有些警告可能不对. 不过伪告警应该很少.</dd>
<dt>优点:</dt>
<dd>可以捕获容易忽视的错误, 例如输入错误, 使用未赋值的变量等.</dd>
<dt>缺点:</dt>
<dd>pylint不完美. 要利用其优势, 我们有时侯需要: a) 围绕着它来写代码 b) 抑制其告警 c) 改进它, 或者d) 忽略它.</dd>
<dt>结论:</dt>
<dd><p class="first">确保对你的代码运行pylint.抑制不准确的警告,以便能够将其他警告暴露出来。</p>
<p>你可以通过设置一个行注释来抑制告警. 例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nb">dict</span> <span class="o">=</span> <span class="s1">&#39;something awful&#39;</span>  <span class="c1"># Bad Idea... pylint: disable=redefined-builtin</span>
</pre></div>
</div>
<p>pylint警告是以一个数字编号(如 <code class="docutils literal"><span class="pre">C0112</span></code> )和一个符号名(如 <code class="docutils literal"><span class="pre">empty-docstring</span></code> )来标识的. 在编写新代码或更新已有代码时对告警进行医治, 推荐使用符号名来标识.</p>
<p>如果警告的符号名不够见名知意，那么请对其增加一个详细解释。</p>
<p>采用这种抑制方式的好处是我们可以轻松查找抑制并回顾它们.</p>
<p>你可以使用命令 <code class="docutils literal"><span class="pre">pylint</span> <span class="pre">--list-msgs</span></code> 来获取pylint告警列表. 你可以使用命令 <code class="docutils literal"><span class="pre">pylint</span> <span class="pre">--help-msg=C6409</span></code> , 以获取关于特定消息的更多信息.</p>
<p>相比较于之前使用的 <code class="docutils literal"><span class="pre">pylint:</span> <span class="pre">disable-msg</span></code> , 本文推荐使用 <code class="docutils literal"><span class="pre">pylint:</span> <span class="pre">disable</span></code> .</p>
<p>要抑制&#8221;参数未使用&#8221;告警, 你可以用&#8221;_&#8221;作为参数标识符, 或者在参数名前加&#8221;unused_&#8221;. 遇到不能改变参数名的情况, 你可以通过在函数开头&#8221;提到&#8221;它们来消除告警. 例如:</p>
<div class="last highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">unused_b</span><span class="p">,</span> <span class="n">unused_c</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span>
    <span class="k">return</span> <span class="n">a</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id1">
<h4>导入</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">仅对包和模块使用导入</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>模块间共享代码的重用机制.</dd>
<dt>优点:</dt>
<dd>命名空间管理约定十分简单. 每个标识符的源都用一种一致的方式指示. x.Obj表示Obj对象定义在模块x中.</dd>
<dt>缺点:</dt>
<dd>模块名仍可能冲突. 有些模块名太长, 不太方便.</dd>
<dt>结论:</dt>
<dd><p class="first">使用 <code class="docutils literal"><span class="pre">import</span> <span class="pre">x</span></code> 来导入包和模块.</p>
<p>使用 <code class="docutils literal"><span class="pre">from</span> <span class="pre">x</span> <span class="pre">import</span> <span class="pre">y</span></code> , 其中x是包前缀, y是不带前缀的模块名.</p>
<p>使用 <code class="docutils literal"><span class="pre">from</span> <span class="pre">x</span> <span class="pre">import</span> <span class="pre">y</span> <span class="pre">as</span> <span class="pre">z</span></code>, 如果两个要导入的模块都叫做y或者y太长了.</p>
<p>例如, 模块 <code class="docutils literal"><span class="pre">sound.effects.echo</span></code> 可以用如下方式导入:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sound.effects</span> <span class="kn">import</span> <span class="n">echo</span>
<span class="o">...</span>
<span class="n">echo</span><span class="o">.</span><span class="n">EchoFilter</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">atten</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">导入时不要使用相对名称. 即使模块在同一个包中, 也要使用完整包名. 这能帮助你避免无意间导入一个包两次.</p>
</dd>
</dl>
</div>
<div class="section" id="id2">
<h4>包</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用模块的全路径名来导入每个模块</p>
</div>
<dl class="docutils">
<dt>优点:</dt>
<dd>避免模块名冲突. 查找包更容易.</dd>
<dt>缺点:</dt>
<dd>部署代码变难, 因为你必须复制包层次.</dd>
<dt>结论:</dt>
<dd><p class="first">所有的新代码都应该用完整包名来导入每个模块.</p>
<p>应该像下面这样导入:</p>
<div class="last highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Reference in code with complete name.</span>
<span class="kn">import</span> <span class="nn">sound.effects.echo</span>

<span class="c1"># Reference in code with just module name (preferred).</span>
<span class="kn">from</span> <span class="nn">sound.effects</span> <span class="kn">import</span> <span class="n">echo</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id3">
<h4>异常</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">允许使用异常, 但必须小心</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>异常是一种跳出代码块的正常控制流来处理错误或者其它异常条件的方式.</dd>
<dt>优点:</dt>
<dd>正常操作代码的控制流不会和错误处理代码混在一起. 当某种条件发生时, 它也允许控制流跳过多个框架. 例如, 一步跳出N个嵌套的函数, 而不必继续执行错误的代码.</dd>
<dt>缺点:</dt>
<dd>可能会导致让人困惑的控制流. 调用库时容易错过错误情况.</dd>
<dt>结论:</dt>
<dd><p class="first">异常必须遵守特定条件:</p>
<ol class="last arabic">
<li><p class="first">像这样触发异常: <code class="docutils literal"><span class="pre">raise</span> <span class="pre">MyException(&quot;Error</span> <span class="pre">message&quot;)</span></code> 或者 <code class="docutils literal"><span class="pre">raise</span> <span class="pre">MyException</span></code> . 不要使用两个参数的形式( <code class="docutils literal"><span class="pre">raise</span> <span class="pre">MyException,</span> <span class="pre">&quot;Error</span> <span class="pre">message&quot;</span></code> )或者过时的字符串异常( <code class="docutils literal"><span class="pre">raise</span> <span class="pre">&quot;Error</span> <span class="pre">message&quot;</span></code> ).</p>
</li>
<li><p class="first">模块或包应该定义自己的特定域的异常基类, 这个基类应该从内建的Exception类继承. 模块的异常基类应该叫做&#8221;Error&#8221;.</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Error</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">永远不要使用 <code class="docutils literal"><span class="pre">except:</span></code> 语句来捕获所有异常, 也不要捕获 <code class="docutils literal"><span class="pre">Exception</span></code> 或者 <code class="docutils literal"><span class="pre">StandardError</span></code> , 除非你打算重新触发该异常, 或者你已经在当前线程的最外层(记得还是要打印一条错误消息). 在异常这方面, Python非常宽容, <code class="docutils literal"><span class="pre">except:</span></code> 真的会捕获包括Python语法错误在内的任何错误. 使用 <code class="docutils literal"><span class="pre">except:</span></code> 很容易隐藏真正的bug.</p>
</li>
<li><p class="first">尽量减少try/except块中的代码量. try块的体积越大, 期望之外的异常就越容易被触发. 这种情况下, try/except块将隐藏真正的错误.</p>
</li>
<li><p class="first">使用finally子句来执行那些无论try块中有没有异常都应该被执行的代码. 这对于清理资源常常很有用, 例如关闭文件.</p>
</li>
<li><p class="first">当捕获异常时, 使用 <code class="docutils literal"><span class="pre">as</span></code> 而不要用逗号. 例如</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">Error</span>
<span class="k">except</span> <span class="n">Error</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="id4">
<h4>全局变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">避免全局变量</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>定义在模块级的变量.</dd>
<dt>优点:</dt>
<dd>偶尔有用.</dd>
<dt>缺点:</dt>
<dd>导入时可能改变模块行为, 因为导入模块时会对模块级变量赋值.</dd>
<dt>结论:</dt>
<dd><p class="first">避免使用全局变量, 用类变量来代替. 但也有一些例外:</p>
<ol class="last arabic simple">
<li>脚本的默认选项.</li>
<li>模块级常量. 例如:　PI = 3.14159. 常量应该全大写, 用下划线连接.</li>
<li>有时候用全局变量来缓存值或者作为函数返回值很有用.</li>
<li>如果需要, 全局变量应该仅在模块内部可用, 并通过模块级的公共函数来访问.</li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="id5">
<h4>嵌套/局部/内部类或函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">鼓励使用嵌套/本地/内部类或函数</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>类可以定义在方法, 函数或者类中. 函数可以定义在方法或函数中. 封闭区间中定义的变量对嵌套函数是只读的.</dd>
<dt>优点:</dt>
<dd>允许定义仅用于有效范围的工具类和函数.</dd>
<dt>缺点:</dt>
<dd>嵌套类或局部类的实例不能序列化(pickled).</dd>
<dt>结论:</dt>
<dd>推荐使用.</dd>
</dl>
</div>
<div class="section" id="list-comprehensions">
<h4>列表推导(List Comprehensions)</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">可以在简单情况下使用</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>列表推导(list comprehensions)与生成器表达式(generator expression)提供了一种简洁高效的方式来创建列表和迭代器, 而不必借助map(), filter(), 或者lambda.</dd>
<dt>优点:</dt>
<dd>简单的列表推导可以比其它的列表创建方法更加清晰简单. 生成器表达式可以十分高效, 因为它们避免了创建整个列表.</dd>
<dt>缺点:</dt>
<dd>复杂的列表推导或者生成器表达式可能难以阅读.</dd>
<dt>结论:</dt>
<dd><p class="first">适用于简单情况. 每个部分应该单独置于一行: 映射表达式, for语句, 过滤器表达式. 禁止多重for语句或过滤器表达式. 复杂情况下还是使用循环.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span>
  <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
              <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

  <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">:</span>
              <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
                  <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">z</span><span class="p">:</span>
                      <span class="k">yield</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

  <span class="k">return</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">complicated_transform</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
          <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">long_generator_function</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span>

  <span class="n">squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

  <span class="n">eat</span><span class="p">(</span><span class="n">jelly_bean</span> <span class="k">for</span> <span class="n">jelly_bean</span> <span class="ow">in</span> <span class="n">jelly_beans</span>
      <span class="k">if</span> <span class="n">jelly_bean</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="last highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>
  <span class="n">result</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">]</span>

  <span class="k">return</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
          <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
          <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span>
          <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id6">
<h4>默认迭代器和操作符</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如果类型支持, 就使用默认迭代器和操作符. 比如列表, 字典及文件等.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>容器类型, 像字典和列表, 定义了默认的迭代器和关系测试操作符(in和not in)</dd>
<dt>优点:</dt>
<dd>默认操作符和迭代器简单高效, 它们直接表达了操作, 没有额外的方法调用. 使用默认操作符的函数是通用的. 它可以用于支持该操作的任何类型.</dd>
<dt>缺点:</dt>
<dd>你没法通过阅读方法名来区分对象的类型(例如, has_key()意味着字典). 不过这也是优点.</dd>
<dt>结论:</dt>
<dd><p class="first">如果类型支持, 就使用默认迭代器和操作符, 例如列表, 字典和文件. 内建类型也定义了迭代器方法. 优先考虑这些方法, 而不是那些返回列表的方法. 当然，这样遍历容器时，你将不能修改容器.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span>  <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">adict</span><span class="p">:</span> <span class="o">...</span>
      <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adict</span><span class="p">:</span> <span class="o">...</span>
      <span class="k">if</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">alist</span><span class="p">:</span> <span class="o">...</span>
      <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">afile</span><span class="p">:</span> <span class="o">...</span>
      <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">dict</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span> <span class="o">...</span>
</pre></div>
</div>
<div class="last highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>   <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">adict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> <span class="o">...</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">adict</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">key</span><span class="p">):</span> <span class="o">...</span>
      <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">afile</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span> <span class="o">...</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id7">
<h4>生成器</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">按需使用生成器.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>所谓生成器函数, 就是每当它执行一次生成(yield)语句, 它就返回一个迭代器, 这个迭代器生成一个值. 生成值后, 生成器函数的运行状态将被挂起, 直到下一次生成.</dd>
<dt>优点:</dt>
<dd>简化代码, 因为每次调用时, 局部变量和控制流的状态都会被保存. 比起一次创建一系列值的函数, 生成器使用的内存更少.</dd>
<dt>缺点:</dt>
<dd>没有.</dd>
<dt>结论:</dt>
<dd><p class="first">鼓励使用. 注意在生成器函数的文档字符串中使用&#8221;Yields:&#8221;而不是&#8221;Returns:&#8221;.</p>
<p class="last">(译者注: 参看 <a class="reference internal" href="contents.html#comments"><span class="std std-ref">注释</span></a> )</p>
</dd>
</dl>
</div>
<div class="section" id="lambda">
<h4>Lambda函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">适用于单行函数</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>与语句相反, lambda在一个表达式中定义匿名函数. 常用于为 <code class="docutils literal"><span class="pre">map()</span></code> 和 <code class="docutils literal"><span class="pre">filter()</span></code> 之类的高阶函数定义回调函数或者操作符.</dd>
<dt>优点:</dt>
<dd>方便.</dd>
<dt>缺点:</dt>
<dd>比本地函数更难阅读和调试. 没有函数名意味着堆栈跟踪更难理解. 由于lambda函数通常只包含一个表达式, 因此其表达能力有限.</dd>
<dt>结论:</dt>
<dd><p class="first">适用于单行函数. 如果代码超过60-80个字符, 最好还是定义成常规(嵌套)函数.</p>
<p class="last">对于常见的操作符，例如乘法操作符，使用 <code class="docutils literal"><span class="pre">operator</span></code> 模块中的函数以代替lambda函数. 例如, 推荐使用 <code class="docutils literal"><span class="pre">operator.mul</span></code> , 而不是 <code class="docutils literal"><span class="pre">lambda</span> <span class="pre">x,</span> <span class="pre">y:</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code> .</p>
</dd>
</dl>
</div>
<div class="section" id="id8">
<h4>条件表达式</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">适用于单行函数</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>条件表达式是对于if语句的一种更为简短的句法规则. 例如: <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">if</span> <span class="pre">cond</span> <span class="pre">else</span> <span class="pre">2</span></code> .</dd>
<dt>优点:</dt>
<dd>比if语句更加简短和方便.</dd>
<dt>缺点:</dt>
<dd>比if语句难于阅读. 如果表达式很长， 难于定位条件.</dd>
<dt>结论:</dt>
<dd>适用于单行函数. 在其他情况下，推荐使用完整的if语句.</dd>
</dl>
</div>
<div class="section" id="id9">
<h4>默认参数值</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">适用于大部分情况.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>你可以在函数参数列表的最后指定变量的值, 例如, <code class="docutils literal"><span class="pre">def</span> <span class="pre">foo(a,</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">0):</span></code> . 如果调用foo时只带一个参数, 则b被设为0. 如果带两个参数, 则b的值等于第二个参数.</dd>
<dt>优点:</dt>
<dd>你经常会碰到一些使用大量默认值的函数, 但偶尔(比较少见)你想要覆盖这些默认值. 默认参数值提供了一种简单的方法来完成这件事, 你不需要为这些罕见的例外定义大量函数. 同时, Python也不支持重载方法和函数, 默认参数是一种&#8221;仿造&#8221;重载行为的简单方式.</dd>
<dt>缺点:</dt>
<dd>默认参数只在模块加载时求值一次. 如果参数是列表或字典之类的可变类型, 这可能会导致问题. 如果函数修改了对象(例如向列表追加项), 默认值就被修改了.</dd>
<dt>结论:</dt>
<dd><p class="first">鼓励使用, 不过有如下注意事项:</p>
<p>不要在函数或方法定义中使用可变对象作为默认值.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
         <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
             <span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<div class="last highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>  <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="p">[]):</span>
         <span class="o">...</span>
<span class="n">No</span><span class="p">:</span>  <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()):</span>  <span class="c1"># The time the module was loaded???</span>
         <span class="o">...</span>
<span class="n">No</span><span class="p">:</span>  <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">FLAGS</span><span class="o">.</span><span class="n">my_thing</span><span class="p">):</span>  <span class="c1"># sys.argv has not yet been parsed...</span>
         <span class="o">...</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="properties">
<h4>属性(properties)</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">访问和设置数据成员时, 你通常会使用简单, 轻量级的访问和设置函数. 建议用属性（properties）来代替它们.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>一种用于包装方法调用的方式. 当运算量不大, 它是获取和设置属性(attribute)的标准方式.</dd>
<dt>优点:</dt>
<dd>通过消除简单的属性(attribute)访问时显式的get和set方法调用, 可读性提高了. 允许懒惰的计算. 用Pythonic的方式来维护类的接口. 就性能而言, 当直接访问变量是合理的, 添加访问方法就显得琐碎而无意义. 使用属性(properties)可以绕过这个问题. 将来也可以在不破坏接口的情况下将访问方法加上.</dd>
<dt>缺点:</dt>
<dd>属性(properties)是在get和set方法声明后指定, 这需要使用者在接下来的代码中注意: set和get是用于属性(properties)的(除了用 <code class="docutils literal"><span class="pre">&#64;property</span></code> 装饰器创建的只读属性).  必须继承自object类. 可能隐藏比如操作符重载之类的副作用. 继承时可能会让人困惑.</dd>
<dt>结论:</dt>
<dd><p class="first">你通常习惯于使用访问或设置方法来访问或设置数据, 它们简单而轻量. 不过我们建议你在新的代码中使用属性. 只读属性应该用 <code class="docutils literal"><span class="pre">&#64;property</span></code> <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/pyguide.html#Function_and_Method_Decorators">装饰器</a> 来创建.</p>
<p>如果子类没有覆盖属性, 那么属性的继承可能看上去不明显. 因此使用者必须确保访问方法间接被调用, 以保证子类中的重载方法被属性调用(使用模板方法设计模式).</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span> <span class="kn">import</span> <span class="nn">math</span>

     <span class="k">class</span> <span class="nc">Square</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
         <span class="sd">&quot;&quot;&quot;A square with two properties: a writable area and a read-only perimeter.</span>

<span class="sd">         To use:</span>
<span class="sd">         &gt;&gt;&gt; sq = Square(3)</span>
<span class="sd">         &gt;&gt;&gt; sq.area</span>
<span class="sd">         9</span>
<span class="sd">         &gt;&gt;&gt; sq.perimeter</span>
<span class="sd">         12</span>
<span class="sd">         &gt;&gt;&gt; sq.area = 16</span>
<span class="sd">         &gt;&gt;&gt; sq.side</span>
<span class="sd">         4</span>
<span class="sd">         &gt;&gt;&gt; sq.perimeter</span>
<span class="sd">         16</span>
<span class="sd">         &quot;&quot;&quot;</span>

         <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">side</span> <span class="o">=</span> <span class="n">side</span>

         <span class="k">def</span> <span class="nf">__get_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
             <span class="sd">&quot;&quot;&quot;Calculates the &#39;area&#39; property.&quot;&quot;&quot;</span>
             <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">side</span> <span class="o">**</span> <span class="mi">2</span>

         <span class="k">def</span> <span class="nf">___get_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
             <span class="sd">&quot;&quot;&quot;Indirect accessor for &#39;area&#39; property.&quot;&quot;&quot;</span>
             <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_area</span><span class="p">()</span>

         <span class="k">def</span> <span class="nf">__set_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area</span><span class="p">):</span>
             <span class="sd">&quot;&quot;&quot;Sets the &#39;area&#39; property.&quot;&quot;&quot;</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">side</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>

         <span class="k">def</span> <span class="nf">___set_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area</span><span class="p">):</span>
             <span class="sd">&quot;&quot;&quot;Indirect setter for &#39;area&#39; property.&quot;&quot;&quot;</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">_SetArea</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>

         <span class="n">area</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">___get_area</span><span class="p">,</span> <span class="n">___set_area</span><span class="p">,</span>
                         <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Gets or sets the area of the square.&quot;&quot;&quot;</span><span class="p">)</span>

         <span class="nd">@property</span>
         <span class="k">def</span> <span class="nf">perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
             <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">side</span> <span class="o">*</span> <span class="mi">4</span>
</pre></div>
</div>
<p class="last">(译者注: 老实说, 我觉得这段示例代码很不恰当, 有必要这么蛋疼吗?)</p>
</dd>
</dl>
</div>
<div class="section" id="true-false">
<h4>True/False的求值</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">尽可能使用隐式false</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>Python在布尔上下文中会将某些值求值为false. 按简单的直觉来讲, 就是所有的&#8221;空&#8221;值都被认为是false. 因此0， None, [], {}, &#8220;&#8221; 都被认为是false.</dd>
<dt>优点:</dt>
<dd>使用Python布尔值的条件语句更易读也更不易犯错. 大部分情况下, 也更快.</dd>
<dt>缺点:</dt>
<dd>对C/C++开发人员来说, 可能看起来有点怪.</dd>
<dt>结论:</dt>
<dd><p class="first">尽可能使用隐式的false, 例如: 使用 <code class="docutils literal"><span class="pre">if</span> <span class="pre">foo:</span></code> 而不是 <code class="docutils literal"><span class="pre">if</span> <span class="pre">foo</span> <span class="pre">!=</span> <span class="pre">[]:</span></code> . 不过还是有一些注意事项需要你铭记在心:</p>
<ol class="last arabic">
<li><p class="first">永远不要用==或者!=来比较单件, 比如None. 使用is或者is not.</p>
</li>
<li><p class="first">注意: 当你写下 <code class="docutils literal"><span class="pre">if</span> <span class="pre">x:</span></code> 时, 你其实表示的是 <code class="docutils literal"><span class="pre">if</span> <span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code> . 例如: 当你要测试一个默认值是None的变量或参数是否被设为其它值. 这个值在布尔语义下可能是false!</p>
</li>
<li><p class="first">永远不要用==将一个布尔量与false相比较. 使用 <code class="docutils literal"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">x:</span></code> 代替. 如果你需要区分false和None, 你应该用像 <code class="docutils literal"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">x</span> <span class="pre">and</span> <span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None:</span></code> 这样的语句.</p>
</li>
<li><p class="first">对于序列(字符串, 列表, 元组), 要注意空序列是false. 因此 <code class="docutils literal"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">seq:</span></code> 或者 <code class="docutils literal"><span class="pre">if</span> <span class="pre">seq:</span></code> 比 <code class="docutils literal"><span class="pre">if</span> <span class="pre">len(seq):</span></code> 或 <code class="docutils literal"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">len(seq):</span></code> 要更好.</p>
</li>
<li><p class="first">处理整数时, 使用隐式false可能会得不偿失(即不小心将None当做0来处理). 你可以将一个已知是整型(且不是len()的返回结果)的值与0比较.</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">users</span><span class="p">:</span>
         <span class="k">print</span> <span class="s1">&#39;no users&#39;</span>

     <span class="k">if</span> <span class="n">foo</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">handle_zero</span><span class="p">()</span>

     <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">handle_multiple_of_ten</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="k">print</span> <span class="s1">&#39;no users&#39;</span>

     <span class="k">if</span> <span class="n">foo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">foo</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">handle_zero</span><span class="p">()</span>

     <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">handle_multiple_of_ten</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">注意&#8216;0&#8217;(字符串)会被当做true.</p>
</li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="id11">
<h4>过时的语言特性</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">尽可能使用字符串方法取代字符串模块. 使用函数调用语法取代apply(). 使用列表推导, for循环取代filter(), map()以及reduce().</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>当前版本的Python提供了大家通常更喜欢的替代品.</dd>
<dt>结论:</dt>
<dd><p class="first">我们不使用不支持这些特性的Python版本, 所以没理由不用新的方式.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span> <span class="n">words</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>

     <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">my_list</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">]</span>

     <span class="nb">map</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>    <span class="c1"># Ok. No inlined lambda expression.</span>

     <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<div class="last highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>  <span class="n">words</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">)</span>

     <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">,</span> <span class="n">my_list</span><span class="p">))</span>

     <span class="nb">apply</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="lexical-scoping">
<h4>词法作用域(Lexical Scoping)</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">推荐使用</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd><p class="first">嵌套的Python函数可以引用外层函数中定义的变量, 但是不能够对它们赋值. 变量绑定的解析是使用词法作用域, 也就是基于静态的程序文本. 对一个块中的某个名称的任何赋值都会导致Python将对该名称的全部引用当做局部变量, 甚至是赋值前的处理. 如果碰到global声明, 该名称就会被视作全局变量.</p>
<p>一个使用这个特性的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_adder</span><span class="p">(</span><span class="n">summand1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a function that adds numbers to a given number.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">adder</span><span class="p">(</span><span class="n">summand2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">summand1</span> <span class="o">+</span> <span class="n">summand2</span>

    <span class="k">return</span> <span class="n">adder</span>
</pre></div>
</div>
<p class="last">(译者注: 这个例子有点诡异, 你应该这样使用这个函数: <code class="docutils literal"><span class="pre">sum</span> <span class="pre">=</span> <span class="pre">get_adder(summand1)(summand2)</span></code> )</p>
</dd>
<dt>优点:</dt>
<dd>通常可以带来更加清晰, 优雅的代码. 尤其会让有经验的Lisp和Scheme(还有Haskell, ML等)程序员感到欣慰.</dd>
<dt>缺点:</dt>
<dd><p class="first">可能导致让人迷惑的bug. 例如下面这个依据 <a class="reference external" href="http://www.python.org/dev/peps/pep-0227/">PEP-0227</a> 的例子:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">4</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
        <span class="k">print</span> <span class="n">i</span><span class="p">,</span>
    <span class="c1"># ...</span>
    <span class="c1"># A bunch of code here</span>
    <span class="c1"># ...</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>  <span class="c1"># Ah, i *is* local to Foo, so this is what Bar sees</span>
        <span class="k">print</span> <span class="n">i</span><span class="p">,</span>
    <span class="n">bar</span><span class="p">()</span>
</pre></div>
</div>
<p>因此 <code class="docutils literal"><span class="pre">foo([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></code> 会打印 <code class="docutils literal"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">3</span> <span class="pre">3</span></code> , 不是 <code class="docutils literal"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">3</span> <span class="pre">4</span></code> .</p>
<p class="last">(译者注: x是一个列表, for循环其实是将x中的值依次赋给i.这样对i的赋值就隐式的发生了, 整个foo函数体中的i都会被当做局部变量, 包括bar()中的那个. 这一点与C++之类的静态语言还是有很大差别的.)</p>
</dd>
<dt>结论:</dt>
<dd>鼓励使用.</dd>
</dl>
</div>
<div class="section" id="id12">
<h4>函数与方法装饰器</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如果好处很显然, 就明智而谨慎的使用装饰器</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd><p class="first"><a class="reference external" href="https://docs.python.org/release/2.4.3/whatsnew/node6.html">用于函数及方法的装饰器</a> (也就是&#64;标记). 最常见的装饰器是&#64;classmethod 和&#64;staticmethod, 用于将常规函数转换成类方法或静态方法. 不过, 装饰器语法也允许用户自定义装饰器. 特别地, 对于某个函数 <code class="docutils literal"><span class="pre">my_decorator</span></code> , 下面的两段代码是等效的:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="nd">@my_decorator</span>
   <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="c1"># method body ...</span>
</pre></div>
</div>
<div class="last highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># method body ...</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">my_decorator</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>优点:</dt>
<dd>优雅的在函数上指定一些转换. 该转换可能减少一些重复代码, 保持已有函数不变(enforce invariants), 等.</dd>
<dt>缺点:</dt>
<dd>装饰器可以在函数的参数或返回值上执行任何操作, 这可能导致让人惊异的隐藏行为. 而且, 装饰器在导入时执行. 从装饰器代码的失败中恢复更加不可能.</dd>
<dt>结论:</dt>
<dd><p class="first">如果好处很显然, 就明智而谨慎的使用装饰器. 装饰器应该遵守和函数一样的导入和命名规则. 装饰器的python文档应该清晰的说明该函数是一个装饰器. 请为装饰器编写单元测试.</p>
<p>避免装饰器自身对外界的依赖(即不要依赖于文件, socket, 数据库连接等), 因为装饰器运行时这些资源可能不可用(由 <code class="docutils literal"><span class="pre">pydoc</span></code> 或其它工具导入). 应该保证一个用有效参数调用的装饰器在所有情况下都是成功的.</p>
<p class="last">装饰器是一种特殊形式的&#8221;顶级代码&#8221;. 参考后面关于 <a class="reference internal" href="contents.html#main"><span class="std std-ref">Main</span></a> 的话题.</p>
</dd>
</dl>
</div>
<div class="section" id="id14">
<h4>线程</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要依赖内建类型的原子性.</p>
</div>
<p>虽然Python的内建类型例如字典看上去拥有原子操作, 但是在某些情形下它们仍然不是原子的(即: 如果__hash__或__eq__被实现为Python方法)且它们的原子性是靠不住的. 你也不能指望原子变量赋值(因为这个反过来依赖字典).</p>
<p>优先使用Queue模块的 <code class="docutils literal"><span class="pre">Queue</span></code> 数据类型作为线程间的数据通信方式. 另外, 使用threading模块及其锁原语(locking primitives). 了解条件变量的合适使用方式, 这样你就可以使用 <code class="docutils literal"><span class="pre">threading.Condition</span></code> 来取代低级别的锁了.</p>
</div>
<div class="section" id="id15">
<h4>威力过大的特性</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">避免使用这些特性</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>Python是一种异常灵活的语言, 它为你提供了很多花哨的特性, 诸如元类(metaclasses), 字节码访问, 任意编译(on-the-fly compilation), 动态继承, 对象父类重定义(object reparenting), 导入黑客(import hacks), 反射, 系统内修改(modification of system internals), 等等.</dd>
<dt>优点:</dt>
<dd>强大的语言特性, 能让你的代码更紧凑.</dd>
<dt>缺点:</dt>
<dd>使用这些很&#8221;酷&#8221;的特性十分诱人, 但不是绝对必要. 使用奇技淫巧的代码将更加难以阅读和调试. 开始可能还好(对原作者而言), 但当你回顾代码, 它们可能会比那些稍长一点但是很直接的代码更加难以理解.</dd>
<dt>结论:</dt>
<dd>在你的代码中避免这些特性.</dd>
</dl>
</div>
</div>
<span id="document-google-python-styleguide/python_style_rules"></span><div class="section" id="python">
<h3>Python风格规范</h3>
<div class="section" id="id1">
<h4>分号</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要在行尾加分号, 也不要用分号将两条命令放在同一行.</p>
</div>
</div>
<div class="section" id="line-length">
<span id="id2"></span><h4>行长度</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每行不超过80个字符</p>
</div>
<p>例外:</p>
<ol class="arabic simple">
<li>长的导入模块语句</li>
<li>注释里的URL</li>
</ol>
<p>不要使用反斜杠连接行.</p>
<p>Python会将 <a class="reference external" href="http://docs.python.org/2/reference/lexical_analysis.html#implicit-line-joining">圆括号, 中括号和花括号中的行隐式的连接起来</a> , 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span> <span class="n">foo_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">design</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span>
             <span class="n">emphasis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">highlight</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

     <span class="k">if</span> <span class="p">(</span><span class="n">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">height</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
         <span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;red&#39;</span> <span class="ow">and</span> <span class="n">emphasis</span> <span class="o">==</span> <span class="s1">&#39;strong&#39;</span><span class="p">):</span>
</pre></div>
</div>
<p>如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;This will build a very long long &#39;</span>
     <span class="s1">&#39;long long long long long long string&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>在注释中，如果必要，将长的URL放在一行上。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span>  <span class="c1"># See details at</span>
      <span class="c1"># http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>  <span class="c1"># See details at</span>
     <span class="c1"># http://www.example.com/us/developer/documentation/api/content/\</span>
     <span class="c1"># v2.0/csv_file_name_extension_full_specification.html</span>
</pre></div>
</div>
<p>注意上面例子中的元素缩进; 你可以在本文的 <a class="reference internal" href="#indentation"><span class="std std-ref">缩进</span></a> 部分找到解释.</p>
</div>
<div class="section" id="id4">
<h4>括号</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">宁缺毋滥的使用括号</p>
</div>
<p>除非是用于实现行连接, 否则不要在返回语句或条件语句中使用括号. 不过在元组两边使用括号是可以的.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span> <span class="k">if</span> <span class="n">foo</span><span class="p">:</span>
         <span class="n">bar</span><span class="p">()</span>
     <span class="k">while</span> <span class="n">x</span><span class="p">:</span>
         <span class="n">x</span> <span class="o">=</span> <span class="n">bar</span><span class="p">()</span>
     <span class="k">if</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">y</span><span class="p">:</span>
         <span class="n">bar</span><span class="p">()</span>
     <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
         <span class="n">bar</span><span class="p">()</span>
     <span class="k">return</span> <span class="n">foo</span>
     <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="o">...</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>  <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">):</span>
         <span class="n">bar</span><span class="p">()</span>
     <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
         <span class="n">bar</span><span class="p">()</span>
     <span class="k">return</span> <span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="indentation">
<span id="id5"></span><h4>缩进</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">用4个空格来缩进代码</p>
</div>
<p>绝对不要用tab, 也不要tab和空格混用. 对于行连接的情况, 你应该要么垂直对齐换行的元素(见 <a class="reference internal" href="#line-length"><span class="std std-ref">行长度</span></a> 部分的示例), 或者使用4空格的悬挂式缩进(这时第一行不应该有参数):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span>   <span class="c1"># Aligned with opening delimiter</span>
       <span class="n">foo</span> <span class="o">=</span> <span class="n">long_function_name</span><span class="p">(</span><span class="n">var_one</span><span class="p">,</span> <span class="n">var_two</span><span class="p">,</span>
                                <span class="n">var_three</span><span class="p">,</span> <span class="n">var_four</span><span class="p">)</span>

       <span class="c1"># Aligned with opening delimiter in a dictionary</span>
       <span class="n">foo</span> <span class="o">=</span> <span class="p">{</span>
           <span class="n">long_dictionary_key</span><span class="p">:</span> <span class="n">value1</span> <span class="o">+</span>
                                <span class="n">value2</span><span class="p">,</span>
           <span class="o">...</span>
       <span class="p">}</span>

       <span class="c1"># 4-space hanging indent; nothing on first line</span>
       <span class="n">foo</span> <span class="o">=</span> <span class="n">long_function_name</span><span class="p">(</span>
           <span class="n">var_one</span><span class="p">,</span> <span class="n">var_two</span><span class="p">,</span> <span class="n">var_three</span><span class="p">,</span>
           <span class="n">var_four</span><span class="p">)</span>

       <span class="c1"># 4-space hanging indent in a dictionary</span>
       <span class="n">foo</span> <span class="o">=</span> <span class="p">{</span>
           <span class="n">long_dictionary_key</span><span class="p">:</span>
               <span class="n">long_dictionary_value</span><span class="p">,</span>
           <span class="o">...</span>
       <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>    <span class="c1"># Stuff on first line forbidden</span>
      <span class="n">foo</span> <span class="o">=</span> <span class="n">long_function_name</span><span class="p">(</span><span class="n">var_one</span><span class="p">,</span> <span class="n">var_two</span><span class="p">,</span>
          <span class="n">var_three</span><span class="p">,</span> <span class="n">var_four</span><span class="p">)</span>

      <span class="c1"># 2-space hanging indent forbidden</span>
      <span class="n">foo</span> <span class="o">=</span> <span class="n">long_function_name</span><span class="p">(</span>
        <span class="n">var_one</span><span class="p">,</span> <span class="n">var_two</span><span class="p">,</span> <span class="n">var_three</span><span class="p">,</span>
        <span class="n">var_four</span><span class="p">)</span>

      <span class="c1"># No hanging indent in a dictionary</span>
      <span class="n">foo</span> <span class="o">=</span> <span class="p">{</span>
          <span class="n">long_dictionary_key</span><span class="p">:</span>
              <span class="n">long_dictionary_value</span><span class="p">,</span>
              <span class="o">...</span>
      <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>空行</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">顶级定义之间空两行, 方法定义之间空一行</p>
</div>
<p>顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行.</p>
</div>
<div class="section" id="id7">
<h4>空格</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">按照标准的排版规范来使用标点两边的空格</p>
</div>
<p>括号内不要有空格.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span> <span class="n">spam</span><span class="p">(</span><span class="n">ham</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">{</span><span class="n">eggs</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="p">[])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>  <span class="n">spam</span><span class="p">(</span> <span class="n">ham</span><span class="p">[</span> <span class="mi">1</span> <span class="p">],</span> <span class="p">{</span> <span class="n">eggs</span><span class="p">:</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">[</span> <span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾).</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
         <span class="k">print</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
     <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>  <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">:</span>
         <span class="k">print</span> <span class="n">x</span> <span class="p">,</span> <span class="n">y</span>
     <span class="n">x</span> <span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="p">,</span> <span class="n">x</span>
</pre></div>
</div>
<p>参数列表, 索引或切片的左括号前不应加空格.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span> <span class="n">spam</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">no</span><span class="p">:</span> <span class="n">spam</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>  <span class="nb">dict</span> <span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span> <span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<p>在二元操作符两边都加上一个空格, 比如赋值(=), 比较(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not), 布尔(and, or, not).  至于算术操作符两边的空格该如何使用, 需要你自己好好判断. 不过两侧务必要保持一致.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>  <span class="n">x</span><span class="o">&lt;</span><span class="mi">1</span>
</pre></div>
</div>
<p>当&#8217;=&#8217;用于指示关键字参数或默认参数值时, 不要在其两侧使用空格.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span> <span class="k">def</span> <span class="nf">complex</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span> <span class="k">return</span> <span class="n">magic</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">real</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">imag</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>  <span class="k">def</span> <span class="nf">complex</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">imag</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">):</span> <span class="k">return</span> <span class="n">magic</span><span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="n">real</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">imag</span><span class="p">)</span>
</pre></div>
</div>
<p>不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于:, #, =等):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span>
     <span class="n">foo</span> <span class="o">=</span> <span class="mi">1000</span>  <span class="c1"># comment</span>
     <span class="n">long_name</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># comment that should not be aligned</span>

     <span class="n">dictionary</span> <span class="o">=</span> <span class="p">{</span>
         <span class="s2">&quot;foo&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
         <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
         <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>
     <span class="n">foo</span>       <span class="o">=</span> <span class="mi">1000</span>  <span class="c1"># comment</span>
     <span class="n">long_name</span> <span class="o">=</span> <span class="mi">2</span>     <span class="c1"># comment that should not be aligned</span>

     <span class="n">dictionary</span> <span class="o">=</span> <span class="p">{</span>
         <span class="s2">&quot;foo&quot;</span>      <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
         <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
         <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="shebang">
<h4>Shebang</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">大部分.py文件不必以#!作为文件的开始. 根据 <a class="reference external" href="http://www.python.org/dev/peps/pep-0394/">PEP-394</a> , 程序的main文件应该以 #!/usr/bin/python2或者 #!/usr/bin/python3开始.</p>
</div>
<p>(译者注: 在计算机科学中, <a class="reference external" href="http://en.wikipedia.org/wiki/Shebang_(Unix)">Shebang</a> (也称为Hashbang)是一个由井号和叹号构成的字符串行(#!), 其出现在文本文件的第一行的前两个字符. 在文件中存在Shebang的情况下, 类Unix操作系统的程序载入器会分析Shebang后的内容, 将这些内容作为解释器指令, 并调用该指令, 并将载有Shebang的文件路径作为该解释器的参数. 例如, 以指令#!/bin/sh开头的文件在执行时会实际调用/bin/sh程序.)</p>
<p>#!先用于帮助内核找到Python解释器, 但是在导入模块时, 将会被忽略. 因此只有被直接执行的文件中才有必要加入#!.</p>
</div>
<div class="section" id="comments">
<span id="id9"></span><h4>注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">确保对模块, 函数, 方法和行内注释使用正确的风格</p>
</div>
<p><strong>文档字符串</strong></p>
<blockquote>
<div>Python有一种独一无二的的注释方式: 使用文档字符串. 文档字符串是包, 模块, 类或函数里的第一个语句. 这些字符串可以通过对象的__doc__成员被自动提取, 并且被pydoc所用. (你可以在你的模块上运行pydoc试一把, 看看它长什么样). 我们对文档字符串的惯例是使用三重双引号&#8221;&#8220;&#8221;( <a class="reference external" href="http://www.python.org/dev/peps/pep-0257/">PEP-257</a> ). 一个文档字符串应该这样组织: 首先是一行以句号, 问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行). 接着是一个空行. 接着是文档字符串剩下的部分, 它应该与文档字符串的第一行的第一个引号对齐. 下面有更多文档字符串的格式化规范.</div></blockquote>
<p><strong>模块</strong></p>
<blockquote>
<div>每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板.</div></blockquote>
<p><strong>函数和方法</strong></p>
<blockquote>
<div><p>下文所指的函数,包括函数, 方法, 以及生成器.</p>
<p>一个函数必须要有文档字符串, 除非它满足以下条件:</p>
<ol class="arabic simple">
<li>外部不可见</li>
<li>非常短小</li>
<li>简单明了</li>
</ol>
<p>文档字符串应该包含函数做什么, 以及输入和输出的详细描述. 通常, 不应该描述&#8221;怎么做&#8221;, 除非是一些复杂的算法. 文档字符串应该提供足够的信息, 当别人编写代码调用该函数时, 他不需要看一行代码, 只要看文档字符串就可以了. 对于复杂的代码, 在代码旁边加注释会比使用文档字符串更有意义.</p>
<p>关于函数的几个方面应该在特定的小节中进行描述记录， 这几个方面如下文所述. 每节应该以一个标题行开始. 标题行以冒号结尾. 除标题行外, 节的其他内容应被缩进2个空格.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致).
描述应该包括所需的类型和含义.
如果一个函数接受*foo(可变长度参数列表)或者**bar (任意关键字参数), 应该详细列出*foo和**bar.</dd>
<dt>Returns: (或者 Yields: 用于生成器)</dt>
<dd>描述返回值的类型和语义. 如果函数返回None, 这一部分可以省略.</dd>
<dt>Raises:</dt>
<dd>列出与接口有关的所有异常.</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fetch_bigtable_rows</span><span class="p">(</span><span class="n">big_table</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">other_silly_variable</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fetches rows from a Bigtable.</span>

<span class="sd">    Retrieves rows pertaining to the given keys from the Table instance</span>
<span class="sd">    represented by big_table.  Silly things may happen if</span>
<span class="sd">    other_silly_variable is not None.</span>

<span class="sd">    Args:</span>
<span class="sd">        big_table: An open Bigtable Table instance.</span>
<span class="sd">        keys: A sequence of strings representing the key of each table row</span>
<span class="sd">            to fetch.</span>
<span class="sd">        other_silly_variable: Another optional variable, that has a much</span>
<span class="sd">            longer name than the other args, and which does nothing.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dict mapping keys to the corresponding table row data</span>
<span class="sd">        fetched. Each row is represented as a tuple of strings. For</span>
<span class="sd">        example:</span>

<span class="sd">        {&#39;Serak&#39;: (&#39;Rigel VII&#39;, &#39;Preparer&#39;),</span>
<span class="sd">         &#39;Zim&#39;: (&#39;Irk&#39;, &#39;Invader&#39;),</span>
<span class="sd">         &#39;Lrrr&#39;: (&#39;Omicron Persei 8&#39;, &#39;Emperor&#39;)}</span>

<span class="sd">        If a key from the keys argument is missing from the dictionary,</span>
<span class="sd">        then that row was not found in the table.</span>

<span class="sd">    Raises:</span>
<span class="sd">        IOError: An error occurred accessing the bigtable.Table object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>类</strong></p>
<blockquote>
<div><p>类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SampleClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Summary of class here.</span>

<span class="sd">    Longer class information....</span>
<span class="sd">    Longer class information....</span>

<span class="sd">    Attributes:</span>
<span class="sd">        likes_spam: A boolean indicating if we like SPAM or not.</span>
<span class="sd">        eggs: An integer count of the eggs we have laid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">likes_spam</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inits SampleClass with blah.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">likes_spam</span> <span class="o">=</span> <span class="n">likes_spam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eggs</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">public_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs operation blah.&quot;&quot;&quot;</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>块注释和行注释</strong></p>
<blockquote>
<div><p>最需要写注释的是代码中那些技巧性的部分. 如果你在下次 <a class="reference external" href="http://en.wikipedia.org/wiki/Code_review">代码审查</a> 的时候必须解释一下, 那么你应该现在就给它写注释. 对于复杂的操作, 应该在其操作开始前写上若干行注释. 对于不是一目了然的代码, 应在其行尾添加注释.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># We use a weighted dictionary search to find out where i is in</span>
<span class="c1"># the array.  We extrapolate position based on the largest num</span>
<span class="c1"># in the array and the array size and then do binary search to</span>
<span class="c1"># get the exact number.</span>

<span class="k">if</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>        <span class="c1"># true iff i is a power of 2</span>
</pre></div>
</div>
<p>为了提高可读性, 注释应该至少离开代码2个空格.</p>
<p>另一方面, 绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># BAD COMMENT: Now go through the b array and make sure whenever i occurs</span>
<span class="c1"># the next element is i+1</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id11">
<h4>类</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span> <span class="k">class</span> <span class="nc">SampleClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
         <span class="k">pass</span>


     <span class="k">class</span> <span class="nc">OuterClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

         <span class="k">class</span> <span class="nc">InnerClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
             <span class="k">pass</span>


     <span class="k">class</span> <span class="nc">ChildClass</span><span class="p">(</span><span class="n">ParentClass</span><span class="p">):</span>
         <span class="sd">&quot;&quot;&quot;Explicitly inherits from another class already.&quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span> <span class="k">class</span> <span class="nc">SampleClass</span><span class="p">:</span>
        <span class="k">pass</span>


    <span class="k">class</span> <span class="nc">OuterClass</span><span class="p">:</span>

        <span class="k">class</span> <span class="nc">InnerClass</span><span class="p">:</span>
            <span class="k">pass</span>
</pre></div>
</div>
<p>继承自 <code class="docutils literal"><span class="pre">object</span></code> 是为了使属性(properties)正常工作, 并且这样可以保护你的代码, 使其不受 <a class="reference external" href="http://www.python.org/dev/peps/pep-3000/">PEP-3000</a> 的一个特殊的潜在不兼容性影响. 这样做也定义了一些特殊的方法, 这些方法实现了对象的默认语义, 包括 <code class="docutils literal"><span class="pre">__new__,</span> <span class="pre">__init__,</span> <span class="pre">__delattr__,</span> <span class="pre">__getattribute__,</span> <span class="pre">__setattr__,</span> <span class="pre">__hash__,</span> <span class="pre">__repr__,</span> <span class="pre">and</span> <span class="pre">__str__</span></code> .</p>
</div>
<div class="section" id="id12">
<h4>字符串</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">即使参数都是字符串, 使用%操作符或者格式化方法格式化字符串. 不过也不能一概而论, 你需要在+和%之间好好判定.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span> <span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
     <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">!&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">imperative</span><span class="p">,</span> <span class="n">expletive</span><span class="p">)</span>
     <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;{}, {}!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">imperative</span><span class="p">,</span> <span class="n">expletive</span><span class="p">)</span>
     <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;name: </span><span class="si">%s</span><span class="s1">; score: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
     <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;name: {}; score: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span> <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># use + in this case</span>
    <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;{}{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># use + in this case</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">imperative</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="n">expletive</span> <span class="o">+</span> <span class="s1">&#39;!&#39;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;name: &#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;; score: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>避免在循环中用+和+=操作符来累加字符串. 由于字符串是不可变的, 这样做会创建不必要的临时对象, 并且导致二次方而不是线性的运行时间. 作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 <code class="docutils literal"><span class="pre">.join</span></code> 连接列表. (也可以将每个子串写入一个 <code class="docutils literal"><span class="pre">cStringIO.StringIO</span></code> 缓存中.)</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span> <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&lt;table&gt;&#39;</span><span class="p">]</span>
     <span class="k">for</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">first_name</span> <span class="ow">in</span> <span class="n">employee_list</span><span class="p">:</span>
         <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&lt;tr&gt;&lt;td&gt;</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">&lt;/td&gt;&lt;/tr&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">last_name</span><span class="p">,</span> <span class="n">first_name</span><span class="p">))</span>
     <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&lt;/table&gt;&#39;</span><span class="p">)</span>
     <span class="n">employee_table</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span> <span class="n">employee_table</span> <span class="o">=</span> <span class="s1">&#39;&lt;table&gt;&#39;</span>
    <span class="k">for</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">first_name</span> <span class="ow">in</span> <span class="n">employee_list</span><span class="p">:</span>
        <span class="n">employee_table</span> <span class="o">+=</span> <span class="s1">&#39;&lt;tr&gt;&lt;td&gt;</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">&lt;/td&gt;&lt;/tr&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">last_name</span><span class="p">,</span> <span class="n">first_name</span><span class="p">)</span>
    <span class="n">employee_table</span> <span class="o">+=</span> <span class="s1">&#39;&lt;/table&gt;&#39;</span>
</pre></div>
</div>
<p>在同一个文件中, 保持使用字符串引号的一致性. 使用单引号&#8217;或者双引号&#8221;之一用以引用字符串, 并在同一文件中沿用. 在字符串内可以使用另外一种引号, 以避免在字符串中使用. GPyLint已经加入了这一检查.</p>
<p>(译者注:GPyLint疑为笔误, 应为PyLint.)</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span>
     <span class="n">Python</span><span class="p">(</span><span class="s1">&#39;Why are you hiding your eyes?&#39;</span><span class="p">)</span>
     <span class="n">Gollum</span><span class="p">(</span><span class="s2">&quot;I&#39;m scared of lint errors.&quot;</span><span class="p">)</span>
     <span class="n">Narrator</span><span class="p">(</span><span class="s1">&#39;&quot;Good!&quot; thought a happy Python reviewer.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>
     <span class="n">Python</span><span class="p">(</span><span class="s2">&quot;Why are you hiding your eyes?&quot;</span><span class="p">)</span>
     <span class="n">Gollum</span><span class="p">(</span><span class="s1">&#39;The lint. It burns. It burns us.&#39;</span><span class="p">)</span>
     <span class="n">Gollum</span><span class="p">(</span><span class="s2">&quot;Always the great lint. Watching. Watching.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>为多行字符串使用三重双引号&#8221;&#8220;&#8221;而非三重单引号&#8217;&#8216;&#8217;. 当且仅当项目中使用单引号&#8217;来引用字符串时, 才可能会使用三重&#8217;&#8216;&#8217;为非文档字符串的多行字符串来标识引用. 文档字符串必须使用三重双引号&#8221;&#8220;&#8221;. 不过要注意, 通常用隐式行连接更清晰, 因为多行字符串与程序其他部分的缩进方式不一致.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span>
    <span class="k">print</span> <span class="p">(</span><span class="s2">&quot;This is much nicer.</span><span class="se">\n</span><span class="s2">&quot;</span>
           <span class="s2">&quot;Do it this way.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>
      <span class="k">print</span> <span class="s2">&quot;&quot;&quot;This is pretty ugly.</span>
<span class="s2">  Don&#39;t do this.</span>
<span class="s2">  &quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="sockets">
<h4>文件和sockets</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">在文件和sockets结束时, 显式的关闭它.</p>
</div>
<p>除文件外, sockets或其他类似文件的对象在没有必要的情况下打开, 会有许多副作用, 例如:</p>
<ol class="arabic simple">
<li>它们可能会消耗有限的系统资源, 如文件描述符. 如果这些资源在使用后没有及时归还系统, 那么用于处理这些对象的代码会将资源消耗殆尽.</li>
<li>持有文件将会阻止对于文件的其他诸如移动、删除之类的操作.</li>
<li>仅仅是从逻辑上关闭文件和sockets, 那么它们仍然可能会被其共享的程序在无意中进行读或者写操作. 只有当它们真正被关闭后, 对于它们尝试进行读或者写操作将会抛出异常, 并使得问题快速显现出来.</li>
</ol>
<p>而且, 幻想当文件对象析构时, 文件和sockets会自动关闭, 试图将文件对象的生命周期和文件的状态绑定在一起的想法, 都是不现实的. 因为有如下原因:</p>
<ol class="arabic simple">
<li>没有任何方法可以确保运行环境会真正的执行文件的析构. 不同的Python实现采用不同的内存管理技术, 比如延时垃圾处理机制. 延时垃圾处理机制可能会导致对象生命周期被任意无限制的延长.</li>
<li>对于文件意外的引用,会导致对于文件的持有时间超出预期(比如对于异常的跟踪, 包含有全局变量等).</li>
</ol>
<p>推荐使用 <a class="reference external" href="http://docs.python.org/reference/compound_stmts.html#the-with-statement">&#8220;with&#8221;语句</a> 以管理文件:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;hello.txt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hello_file</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">hello_file</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">line</span>
</pre></div>
</div>
<p>对于不支持使用&#8221;with&#8221;语句的类似文件的对象,使用 contextlib.closing():</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">contextlib</span>

<span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">closing</span><span class="p">(</span><span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s2">&quot;http://www.python.org/&quot;</span><span class="p">))</span> <span class="k">as</span> <span class="n">front_page</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">front_page</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">line</span>
</pre></div>
</div>
<p>Legacy AppEngine 中Python 2.5的代码如使用&#8221;with&#8221;语句, 需要添加 &#8220;from __future__ import with_statement&#8221;.</p>
</div>
<div class="section" id="todo">
<h4>TODO注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了.</p>
</div>
<p>TODO注释应该在所有开头处包含&#8221;TODO&#8221;字符串, 紧跟着是用括号括起来的你的名字, email地址或其它标识符. 然后是一个可选的冒号. 接着必须有一行注释, 解释要做什么. 主要目的是为了有一个统一的TODO格式, 这样添加注释的人就可以搜索到(并可以按需提供更多细节). 写了TODO注释并不保证写的人会亲自解决问题. 当你写了一个TODO, 请注上你的名字.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># TODO(kl@gmail.com): Use a &quot;*&quot; here for string repetition.</span>
<span class="c1"># TODO(Zeke) Change this to use relations.</span>
</pre></div>
</div>
<p>如果你的TODO是&#8221;将来做某事&#8221;的形式, 那么请确保你包含了一个指定的日期(&#8220;2009年11月解决&#8221;)或者一个特定的事件(&#8220;等到所有的客户都可以处理XML请求就移除这些代码&#8221;).</p>
</div>
<div class="section" id="id13">
<h4>导入格式</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每个导入应该独占一行</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span> <span class="kn">import</span> <span class="nn">os</span>
     <span class="kn">import</span> <span class="nn">sys</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>  <span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span>
</pre></div>
</div>
<p>导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前.  导入应该按照从最通用到最不通用的顺序分组:</p>
<ol class="arabic simple">
<li>标准库导入</li>
<li>第三方库导入</li>
<li>应用程序指定导入</li>
</ol>
<p>每种分组中,  应该根据每个模块的完整包路径按字典序排序, 忽略大小写.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">foo</span>
<span class="kn">from</span> <span class="nn">foo</span> <span class="kn">import</span> <span class="n">bar</span>
<span class="kn">from</span> <span class="nn">foo.bar</span> <span class="kn">import</span> <span class="n">baz</span>
<span class="kn">from</span> <span class="nn">foo.bar</span> <span class="kn">import</span> <span class="n">Quux</span>
<span class="kn">from</span> <span class="nn">Foob</span> <span class="kn">import</span> <span class="n">ar</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h4>语句</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">通常每个语句应该独占一行</p>
</div>
<p>不过, 如果测试结果与测试语句在一行放得下, 你也可以将它们放在同一行.  如果是if语句, 只有在没有else时才能这样做. 特别地, 绝不要对 <code class="docutils literal"><span class="pre">try/except</span></code> 这样做, 因为try和except不能放在同一行.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Yes</span><span class="p">:</span>

  <span class="k">if</span> <span class="n">foo</span><span class="p">:</span> <span class="n">bar</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">No</span><span class="p">:</span>

  <span class="k">if</span> <span class="n">foo</span><span class="p">:</span> <span class="n">bar</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>   <span class="n">baz</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

  <span class="k">try</span><span class="p">:</span>               <span class="n">bar</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="n">baz</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

  <span class="k">try</span><span class="p">:</span>
      <span class="n">bar</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="n">baz</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h4>访问控制</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你可以用属性(property)来保持语法的一致性.</p>
<p class="last">(译者注: 重视封装的面向对象程序员看到这个可能会很反感, 因为他们一直被教育: 所有成员变量都必须是私有的! 其实, 那真的是有点麻烦啊. 试着去接受Pythonic哲学吧)</p>
</div>
<p>另一方面, 如果访问更复杂, 或者变量的访问开销很显著, 那么你应该使用像 <code class="docutils literal"><span class="pre">get_foo()</span></code> 和 <code class="docutils literal"><span class="pre">set_foo()</span></code> 这样的函数调用. 如果之前的代码行为允许通过属性(property)访问 , 那么就不要将新的访问函数与属性绑定. 这样, 任何试图通过老方法访问变量的代码就没法运行, 使用者也就会意识到复杂性发生了变化.</p>
</div>
<div class="section" id="id16">
<h4>命名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_VAR_NAME, instance_var_name, function_parameter_name, local_var_name.</p>
</div>
<p><strong>应该避免的名称</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li>单字符名称, 除了计数器和迭代器.</li>
<li>包/模块名中的连字符(-)</li>
<li>双下划线开头并结尾的名称(Python保留, 例如__init__)</li>
</ol>
</div></blockquote>
<p><strong>命名约定</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li>所谓&#8221;内部(Internal)&#8221;表示仅模块内可用, 或者, 在类内是保护或私有的.</li>
<li>用单下划线(_)开头表示模块变量或函数是protected的(使用import * from时不会包含).</li>
<li>用双下划线(__)开头的实例变量或方法表示类内私有.</li>
<li>将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.</li>
<li>对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰.</li>
</ol>
</div></blockquote>
<p><strong>Python之父Guido推荐的规范</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="17%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type</th>
<th class="head">Public</th>
<th class="head">Internal</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Modules</td>
<td>lower_with_under</td>
<td>_lower_with_under</td>
</tr>
<tr class="row-odd"><td>Packages</td>
<td>lower_with_under</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>Classes</td>
<td>CapWords</td>
<td>_CapWords</td>
</tr>
<tr class="row-odd"><td>Exceptions</td>
<td>CapWords</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>Functions</td>
<td>lower_with_under()</td>
<td>_lower_with_under()</td>
</tr>
<tr class="row-odd"><td>Global/Class Constants</td>
<td>CAPS_WITH_UNDER</td>
<td>_CAPS_WITH_UNDER</td>
</tr>
<tr class="row-even"><td>Global/Class Variables</td>
<td>lower_with_under</td>
<td>_lower_with_under</td>
</tr>
<tr class="row-odd"><td>Instance Variables</td>
<td>lower_with_under</td>
<td>_lower_with_under (protected) or __lower_with_under (private)</td>
</tr>
<tr class="row-even"><td>Method Names</td>
<td>lower_with_under()</td>
<td>_lower_with_under() (protected) or __lower_with_under() (private)</td>
</tr>
<tr class="row-odd"><td>Function/Method Parameters</td>
<td>lower_with_under</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>Local Variables</td>
<td>lower_with_under</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="main">
<span id="id17"></span><h4>Main</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">即使是一个打算被用作脚本的文件, 也应该是可导入的. 并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行, 这是一种副作用. 主功能应该放在一个main()函数中.</p>
</div>
<p>在Python中, pydoc以及单元测试要求模块必须是可导入的. 你的代码应该在执行主程序前总是检查 <code class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> , 这样当模块被导入时主程序就不会被执行.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
      <span class="o">...</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>所有的顶级代码在模块导入时都会被执行. 要小心不要去调用函数, 创建对象, 或者执行那些不应该在使用pydoc时执行的操作.</p>
</div>
</div>
<span id="document-google-python-styleguide/parting_words"></span><div class="section" id="id1">
<h3>临别赠言</h3>
<p><strong>请务必保持代码的一致性</strong></p>
<p>如果你正在编辑代码, 花几分钟看一下周边代码, 然后决定风格. 如果它们在所有的算术操作符两边都使用空格, 那么你也应该这样做. 如果它们的注释都用标记包围起来, 那么你的注释也要这样.</p>
<p>制定风格指南的目的在于让代码有规可循, 这样人们就可以专注于&#8221;你在说什么&#8221;, 而不是&#8221;你在怎么说&#8221;. 我们在这里给出的是全局的规范, 但是本地的规范同样重要. 如果你加到一个文件里的代码和原有代码大相径庭, 它会让读者不知所措. 避免这种情况.</p>
<div class="line-block">
<div class="line">Revision 2.59</div>
<div class="line"><br /></div>
<div class="line">Amit Patel</div>
<div class="line">Antoine Picard</div>
<div class="line">Eugene Jhong</div>
<div class="line">Gregory P. Smith</div>
<div class="line">Jeremy Hylton</div>
<div class="line">Matt Smart</div>
<div class="line">Mike Shields</div>
<div class="line">Shane Liebling</div>
</div>
</div>
</div>
</div>
<span id="document-google-shell-styleguide/contents"></span><div class="section" id="shell">
<span id="shell-contents"></span><h2>Shell 风格指南 - 内容目录</h2>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#shell" id="id1">Shell 风格指南 - 内容目录</a></li>
</ul>
</div>
<div class="toctree-wrapper compound">
<span id="document-google-shell-styleguide/index"></span><div class="section" id="id1">
<h3>扉页</h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">版本:</th><td class="field-body"><p class="first">1.26</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">原作者:</th><td class="field-body"><div class="first line-block">
<div class="line">Paul Armstrong</div>
<div class="line">等等</div>
</div>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">翻译:</th><td class="field-body"><div class="first line-block">
<div class="line"><a class="reference external" href="http://87boy.me/">Bean Zhang</a> v1.26</div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">项目主页:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference external" href="https://github.com/google/styleguide">Google Style Guide</a></li>
<li><a class="reference external" href="http://github.com/zh-google-styleguide/zh-google-styleguide">Google 开源项目风格指南 - 中文版</a></li>
</ul>
</td>
</tr>
</tbody>
</table>
</div>
<span id="document-google-shell-styleguide/background"></span><div class="section" id="id1">
<h3>背景</h3>
<div class="section" id="shell">
<h4>使用哪一种Shell</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Bash是唯一被允许执行的shell脚本语言。</p>
</div>
<p>可执行文件必须以 <code class="docutils literal"><span class="pre">#!/bin/bash</span></code> 和最小数量的标志开始。请使用 <code class="docutils literal"><span class="pre">set</span></code> 来设置shell的选项，使得用 <code class="docutils literal"><span class="pre">bash</span> <span class="pre">&lt;script_name&gt;</span></code> 调用你的脚本时不会破坏其功能。</p>
<p>限制所有的可执行shell脚本为bash使得我们安装在所有计算机中的shell语言保持一致性。</p>
<p>无论你是为什么而编码，对此唯一例外的是当你被迫时可以不这么做的。其中一个例子是Solaris SVR4包，编写任何脚本都需要用纯Bourne shell。</p>
</div>
<div class="section" id="id2">
<h4>什么时候使用Shell</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Shell应该仅仅被用于小功能或者简单的包装脚本。</p>
</div>
<p>尽管Shell脚本不是一种开发语言，但在整个谷歌它被用于编写多种实用工具的脚本。这个风格指南更多的是认同它的使用，而不是一个建议，即它可被用于广泛部署。</p>
<p>以下是一些准则：</p>
<ul class="simple">
<li>如果你主要是在调用其他的工具并且做一些相对很小数据量的操作，那么使用shell来完成任务是一种可接受的选择。</li>
<li>如果你在乎性能，那么请选择其他工具，而不是使用shell。</li>
<li>如果你发现你需要使用数据而不是变量赋值（如 <code class="docutils literal"><span class="pre">${PHPESTATUS}</span></code> ），那么你应该使用Python脚本。</li>
<li>如果你将要编写的脚本会超过100行，那么你可能应该使用Python来编写，而不是Shell。请记住，当脚本行数增加，尽早使用另外一种语言重写你的脚本，以避免之后花更多的时间来重写。</li>
</ul>
</div>
</div>
<span id="document-google-shell-styleguide/shell_files_and_interpreter_invocation"></span><div class="section" id="shell">
<h3>Shell文件和解释器调用</h3>
<div class="section" id="id1">
<h4>文件扩展名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">可执行文件应该没有扩展名（强烈建议）或者使用.sh扩展名。库文件必须使用.sh作为扩展名，而且应该是不可执行的。</p>
</div>
<p>当执行一个程序时，并不需要知道它是用什么语言编写的。而且shell脚本也不要求有扩展名。所以我们更喜欢可执行文件没有扩展名。</p>
<p>然而，对于库文件，知道其用什么语言编写的是很重要的，有时候会需要使用不同语言编写的相似的库文件。使用.sh这样特定语言后缀作为扩展名，就使得用不同语言编写的具有相同功能的库文件可以采用一样的名称。</p>
</div>
<div class="section" id="suid-sgid">
<h4>SUID / SGID</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">SUID(Set User ID)和SGID(Set Group ID)在shell脚本中是被禁止的。</p>
</div>
<p>shell存在太多的安全问题，以致于如果允许SUID/SGID会使得shell几乎不可能足够安全。虽然bash使得运行SUID非常困难，但在某些平台上仍然有可能运行，这就是为什么我们明确提出要禁止它。</p>
<p>如果你需要较高权限的访问请使用 <code class="docutils literal"><span class="pre">sudo</span></code> 。</p>
</div>
</div>
<span id="document-google-shell-styleguide/environment"></span><div class="section" id="id1">
<h3>环境</h3>
<div class="section" id="stdout-vs-stderr">
<h4>STDOUT vs STDERR</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">所有的错误信息都应该被导向STDERR。</p>
</div>
<p>这使得从实际问题中分离出正常状态变得更容易。</p>
<p>推荐使用类似如下函数，将错误信息和其他状态信息一起打印出来。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>err<span class="o">()</span> <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">&quot;[</span><span class="k">$(</span>date +<span class="s1">&#39;%Y-%m-%dT%H:%M:%S%z&#39;</span><span class="k">)</span><span class="s2">]: </span><span class="nv">$@</span><span class="s2">&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
<span class="o">}</span>

<span class="k">if</span> ! do_something<span class="p">;</span> <span class="k">then</span>
    err <span class="s2">&quot;Unable to do_something&quot;</span>
    <span class="nb">exit</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">E_DID_NOTHING</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">fi</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-shell-styleguide/comments"></span><div class="section" id="id1">
<h3>注释</h3>
<div class="section" id="id2">
<h4>文件头</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每个文件的开头是其文件内容的描述。</p>
</div>
<p>每个文件必须包含一个顶层注释，对其内容进行简要概述。版权声明和作者信息是可选的。</p>
<p>例如：</p>
<blockquote>
<div><div class="highlight-shell"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1">#</span>
<span class="c1"># Perform hot backups of Oracle databases.</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id3">
<h4>功能注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">任何不是既明显又短的函数都必须被注释。任何库函数无论其长短和复杂性都必须被注释。</p>
</div>
<p>其他人通过阅读注释（和帮助信息，如果有的话）就能够学会如何使用你的程序或库函数，而不需要阅读代码。</p>
<p>所有的函数注释应该包含：</p>
<ul class="simple">
<li>函数的描述</li>
<li>全局变量的使用和修改</li>
<li>使用的参数说明</li>
<li>返回值，而不是上一条命令运行后默认的退出状态</li>
</ul>
<p>例如：</p>
<blockquote>
<div><div class="highlight-shell"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1">#</span>
<span class="c1"># Perform hot backups of Oracle databases.</span>

<span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="s1">&#39;/usr/xpg4/bin:/usr/bin:/opt/csw/bin:/opt/goog/bin&#39;</span>

<span class="c1">#######################################</span>
<span class="c1"># Cleanup files from the backup dir</span>
<span class="c1"># Globals:</span>
<span class="c1">#   BACKUP_DIR</span>
<span class="c1">#   ORACLE_SID</span>
<span class="c1"># Arguments:</span>
<span class="c1">#   None</span>
<span class="c1"># Returns:</span>
<span class="c1">#   None</span>
<span class="c1">#######################################</span>
cleanup<span class="o">()</span> <span class="o">{</span>
  ...
<span class="o">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id4">
<h4>实现部分的注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">注释你代码中含有技巧、不明显、有趣的或者重要的部分。</p>
</div>
<p>这部分遵循谷歌代码注释的通用做法。不要注释所有代码。如果有一个复杂的算法或者你正在做一些与众不同的，放一个简单的注释。</p>
</div>
<div class="section" id="todo">
<h4>TODO注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用TODO注释临时的、短期解决方案的、或者足够好但不够完美的代码。</p>
</div>
<p>这与C++指南中的约定相一致。</p>
<p>TODOs应该包含全部大写的字符串TODO，接着是括号中你的用户名。冒号是可选的。最好在TODO条目之后加上 bug或者ticket 的序号。</p>
<p>例如：</p>
<blockquote>
<div><div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># TODO(mrmonkey): Handle the unlikely edge cases (bug ####)</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<span id="document-google-shell-styleguide/formatting"></span><div class="section" id="id1">
<h3>格式</h3>
<div class="section" id="id2">
<h4>缩进</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">缩进两个空格，没有制表符。</p>
</div>
<p>在代码块之间请使用空行以提升可读性。缩进为两个空格。无论你做什么，请不要使用制表符。对于已有文件，保持已有的缩进格式。</p>
</div>
<div class="section" id="id3">
<h4>行的长度和长字符串</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">行的最大长度为80个字符。</p>
</div>
<p>如果你必须写长度超过80个字符的字符串，如果可能的话，尽量使用here document或者嵌入的换行符。长度超过80个字符的文字串且不能被合理地分割，这是正常的。但强烈建议找到一个方法使其变短。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># DO use &#39;here document&#39;s</span>
cat <span class="s">&lt;&lt;END;</span>
<span class="s">I am an exceptionally long</span>
<span class="s">string.</span>
<span class="s">END</span>

<span class="c1"># Embedded newlines are ok too</span>
<span class="nv">long_string</span><span class="o">=</span><span class="s2">&quot;I am an exceptionally</span>
<span class="s2">  long string.&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>管道</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如果一行容不下整个管道操作，那么请将整个管道操作分割成每行一个管段。</p>
</div>
<p>如果一行容得下整个管道操作，那么请将整个管道操作写在同一行。</p>
<p>否则，应该将整个管道操作分割成每行一个管段，管道操作的下一部分应该将管道符放在新行并且缩进2个空格。这适用于使用管道符&#8217;|&#8217;的合并命令链以及使用&#8217;||&#8217;和&#8217;&amp;&amp;&#8217;的逻辑运算链。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># All fits on one line</span>
command1 <span class="p">|</span> command2

<span class="c1"># Long commands</span>
command1 <span class="se">\</span>
  <span class="p">|</span> command2 <span class="se">\</span>
  <span class="p">|</span> command3 <span class="se">\</span>
  <span class="p">|</span> command4
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>循环</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">请将 <code class="docutils literal"><span class="pre">;</span> <span class="pre">do</span></code> , <code class="docutils literal"><span class="pre">;</span> <span class="pre">then</span></code> 和 <code class="docutils literal"><span class="pre">while</span></code> , <code class="docutils literal"><span class="pre">for</span></code> , <code class="docutils literal"><span class="pre">if</span></code> 放在同一行。</p>
</div>
<p>shell中的循环略有不同，但是我们遵循跟声明函数时的大括号相同的原则。也就是说， <code class="docutils literal"><span class="pre">;</span> <span class="pre">do</span></code> , <code class="docutils literal"><span class="pre">;</span> <span class="pre">then</span></code> 应该和 if/for/while 放在同一行。 <code class="docutils literal"><span class="pre">else</span></code> 应该单独一行，结束语句应该单独一行并且跟开始语句垂直对齐。</p>
<p>例如：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="k">for</span> dir in <span class="si">${</span><span class="nv">dirs_to_cleanup</span><span class="si">}</span><span class="p">;</span> <span class="k">do</span>
  <span class="k">if</span> <span class="o">[[</span> -d <span class="s2">&quot;</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">ORACLE_SID</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
    log_date <span class="s2">&quot;Cleaning up old files in </span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">ORACLE_SID</span><span class="si">}</span><span class="s2">&quot;</span>
    rm <span class="s2">&quot;</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">ORACLE_SID</span><span class="si">}</span><span class="s2">/&quot;</span>*
    <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$?</span><span class="s2">&quot;</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
      error_message
    <span class="k">fi</span>
  <span class="k">else</span>
    mkdir -p <span class="s2">&quot;</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">ORACLE_SID</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$?</span><span class="s2">&quot;</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
      error_message
    <span class="k">fi</span>
  <span class="k">fi</span>
<span class="k">done</span>
</pre></div>
</div>
</div>
<div class="section" id="case">
<h4>case语句</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<ul class="last simple">
<li>通过2个空格缩进可选项。</li>
<li>在同一行可选项的模式右圆括号之后和结束符 <code class="docutils literal"><span class="pre">;;</span></code> 之前各需要一个空格。</li>
<li>长可选项或者多命令可选项应该被拆分成多行，模式、操作和结束符 <code class="docutils literal"><span class="pre">;;</span></code> 在不同的行。</li>
</ul>
</div>
<p>匹配表达式比 <code class="docutils literal"><span class="pre">case</span></code> 和 <code class="docutils literal"><span class="pre">esac</span></code> 缩进一级。多行操作要再缩进一级。一般情况下，不需要引用匹配表达式。模式表达式前面不应该出现左括号。避免使用 <code class="docutils literal"><span class="pre">;&amp;</span></code> 和 <code class="docutils literal"><span class="pre">;;&amp;</span></code> 符号。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">expression</span><span class="si">}</span><span class="s2">&quot;</span> in
  a<span class="o">)</span>
    <span class="nv">variable</span><span class="o">=</span><span class="s2">&quot;...&quot;</span>
    some_command <span class="s2">&quot;</span><span class="si">${</span><span class="nv">variable</span><span class="si">}</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">other_expr</span><span class="si">}</span><span class="s2">&quot;</span> ...
    <span class="p">;;</span>
  absolute<span class="o">)</span>
    <span class="nv">actions</span><span class="o">=</span><span class="s2">&quot;relative&quot;</span>
    another_command <span class="s2">&quot;</span><span class="si">${</span><span class="nv">actions</span><span class="si">}</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">other_expr</span><span class="si">}</span><span class="s2">&quot;</span> ...
    <span class="p">;;</span>
  *<span class="o">)</span>
    error <span class="s2">&quot;Unexpected expression &#39;</span><span class="si">${</span><span class="nv">expression</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
    <span class="p">;;</span>
<span class="k">esac</span>
</pre></div>
</div>
<p>只要整个表达式可读，简单的命令可以跟模式和 <code class="docutils literal"><span class="pre">;;</span></code> 写在同一行。这通常适用于单字母选项的处理。当单行容不下操作时，请将模式单独放一行，然后是操作，最后结束符 <code class="docutils literal"><span class="pre">;;</span></code> 也单独一行。当操作在同一行时，模式的右括号之后和结束符 <code class="docutils literal"><span class="pre">;;</span></code> 之前请使用一个空格分隔。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="nv">verbose</span><span class="o">=</span><span class="s1">&#39;false&#39;</span>
<span class="nv">aflag</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="nv">bflag</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="nv">files</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="k">while</span> <span class="nb">getopts</span> <span class="s1">&#39;abf:v&#39;</span> flag<span class="p">;</span> <span class="k">do</span>
  <span class="k">case</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">flag</span><span class="si">}</span><span class="s2">&quot;</span> in
    a<span class="o">)</span> <span class="nv">aflag</span><span class="o">=</span><span class="s1">&#39;true&#39;</span> <span class="p">;;</span>
    b<span class="o">)</span> <span class="nv">bflag</span><span class="o">=</span><span class="s1">&#39;true&#39;</span> <span class="p">;;</span>
    f<span class="o">)</span> <span class="nv">files</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">OPTARG</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">;;</span>
    v<span class="o">)</span> <span class="nv">verbose</span><span class="o">=</span><span class="s1">&#39;true&#39;</span> <span class="p">;;</span>
    *<span class="o">)</span> error <span class="s2">&quot;Unexpected option </span><span class="si">${</span><span class="nv">flag</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">;;</span>
  <span class="k">esac</span>
<span class="k">done</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>变量扩展</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">按优先级顺序：保持跟你所发现的一致；引用你的变量；推荐用 <code class="docutils literal"><span class="pre">${var}</span></code> 而不是 <code class="docutils literal"><span class="pre">$var</span></code> ，详细解释如下。</p>
</div>
<p>这些仅仅是指南，因为作为强制规定似乎饱受争议。</p>
<p>以下按照优先顺序列出。</p>
<ol class="arabic simple">
<li>与现存代码中你所发现的保持一致。</li>
<li>引用变量参阅下面一节，引用。</li>
<li>除非绝对必要或者为了避免深深的困惑，否则不要用大括号将单个字符的shell特殊变量或定位变量括起来。推荐将其他所有变量用大括号括起来。</li>
</ol>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># Section of recommended cases.</span>

<span class="c1"># Preferred style for &#39;special&#39; variables:</span>
<span class="nb">echo</span> <span class="s2">&quot;Positional: </span><span class="nv">$1</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="nv">$5</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="nv">$3</span><span class="s2">&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;Specials: !=</span><span class="nv">$!</span><span class="s2">, -=</span><span class="nv">$-</span><span class="s2">, _=</span><span class="nv">$_</span><span class="s2">. ?=</span><span class="nv">$?</span><span class="s2">, #=</span><span class="nv">$#</span><span class="s2"> *=</span><span class="nv">$*</span><span class="s2"> @=</span><span class="nv">$@</span><span class="s2"> \$=</span><span class="nv">$$</span><span class="s2"> ...&quot;</span>

<span class="c1"># Braces necessary:</span>
<span class="nb">echo</span> <span class="s2">&quot;many parameters: </span><span class="si">${</span><span class="nv">10</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># Braces avoiding confusion:</span>
<span class="c1"># Output is &quot;a0b0c0&quot;</span>
<span class="nb">set</span> -- a b c
<span class="nb">echo</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">1</span><span class="si">}</span><span class="s2">0</span><span class="si">${</span><span class="nv">2</span><span class="si">}</span><span class="s2">0</span><span class="si">${</span><span class="nv">3</span><span class="si">}</span><span class="s2">0&quot;</span>

<span class="c1"># Preferred style for other variables:</span>
<span class="nb">echo</span> <span class="s2">&quot;PATH=</span><span class="si">${</span><span class="nv">PATH</span><span class="si">}</span><span class="s2">, PWD=</span><span class="si">${</span><span class="nv">PWD</span><span class="si">}</span><span class="s2">, mine=</span><span class="si">${</span><span class="nv">some_var</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">while</span> <span class="nb">read</span> f<span class="p">;</span> <span class="k">do</span>
  <span class="nb">echo</span> <span class="s2">&quot;file=</span><span class="si">${</span><span class="nv">f</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">done</span> &lt; &lt;<span class="o">(</span>ls -l /tmp<span class="o">)</span>

<span class="c1"># Section of discouraged cases</span>

<span class="c1"># Unquoted vars, unbraced vars, brace-quoted single letter</span>
<span class="c1"># shell specials.</span>
<span class="nb">echo</span> <span class="nv">a</span><span class="o">=</span><span class="nv">$avar</span> <span class="s2">&quot;b=</span><span class="nv">$bvar</span><span class="s2">&quot;</span> <span class="s2">&quot;PID=</span><span class="si">${</span>$<span class="si">}</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">1</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># Confusing use: this is expanded as &quot;${1}0${2}0${3}0&quot;,</span>
<span class="c1"># not &quot;${10}${20}${30}</span>
<span class="nb">set</span> -- a b c
<span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$10$20$30</span><span class="s2">&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h4>引用</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<ul class="simple">
<li>除非需要小心不带引用的扩展，否则总是引用包含变量、命令替换符、空格或shell元字符的字符串。</li>
<li>推荐引用是单词的字符串（而不是命令选项或者路径名）。</li>
<li>千万不要引用整数。</li>
<li>注意 <code class="docutils literal"><span class="pre">[[</span></code> 中模式匹配的引用规则。</li>
<li>请使用 <code class="docutils literal"><span class="pre">$&#64;</span></code> 除非你有特殊原因需要使用 <code class="docutils literal"><span class="pre">$*</span></code> 。</li>
</ul>
<div class="last highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># &#39;Single&#39; quotes indicate that no substitution is desired.</span>
<span class="c1"># &quot;Double&quot; quotes indicate that substitution is required/tolerated.</span>

<span class="c1"># Simple examples</span>
<span class="c1"># &quot;quote command substitutions&quot;</span>
<span class="nv">flag</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>some_command and its args <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span> <span class="s1">&#39;quoted separately&#39;</span><span class="k">)</span><span class="s2">&quot;</span>

<span class="c1"># &quot;quote variables&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">flag</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># &quot;never quote literal integers&quot;</span>
<span class="nv">value</span><span class="o">=</span><span class="m">32</span>
<span class="c1"># &quot;quote command substitutions&quot;, even when you expect integers</span>
<span class="nv">number</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>generate_number<span class="k">)</span><span class="s2">&quot;</span>

<span class="c1"># &quot;prefer quoting words&quot;, not compulsory</span>
<span class="nb">readonly</span> <span class="nv">USE_INTEGER</span><span class="o">=</span><span class="s1">&#39;true&#39;</span>

<span class="c1"># &quot;quote shell meta characters&quot;</span>
<span class="nb">echo</span> <span class="s1">&#39;Hello stranger, and well met. Earn lots of $$$&#39;</span>
<span class="nb">echo</span> <span class="s2">&quot;Process </span><span class="nv">$$</span><span class="s2">: Done making \$\$\$.&quot;</span>

<span class="c1"># &quot;command options or path names&quot;</span>
<span class="c1"># ($1 is assumed to contain a value here)</span>
grep -li Hugo /dev/null <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span>

<span class="c1"># Less simple examples</span>
<span class="c1"># &quot;quote variables, unless proven false&quot;: ccs might be empty</span>
git send-email --to <span class="s2">&quot;</span><span class="si">${</span><span class="nv">reviewers</span><span class="si">}</span><span class="s2">&quot;</span> <span class="si">${</span><span class="nv">ccs</span><span class="p">:+</span><span class="s2">&quot;--cc&quot;</span><span class="p"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">ccs</span><span class="si">}</span><span class="s2">&quot;</span><span class="si">}</span>

<span class="c1"># Positional parameter precautions: $1 might be unset</span>
<span class="c1"># Single quotes leave regex as-is.</span>
grep -cP <span class="s1">&#39;([Ss]pecial|\|?characters*)$&#39;</span> <span class="si">${</span><span class="nv">1</span><span class="p">:+</span><span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span><span class="si">}</span>

<span class="c1"># For passing on arguments,</span>
<span class="c1"># &quot;$@&quot; is right almost everytime, and</span>
<span class="c1"># $* is wrong almost everytime:</span>
<span class="c1">#</span>
<span class="c1"># * $* and $@ will split on spaces, clobbering up arguments</span>
<span class="c1">#   that contain spaces and dropping empty strings;</span>
<span class="c1"># * &quot;$@&quot; will retain arguments as-is, so no args</span>
<span class="c1">#   provided will result in no args being passed on;</span>
<span class="c1">#   This is in most cases what you want to use for passing</span>
<span class="c1">#   on arguments.</span>
<span class="c1"># * &quot;$*&quot; expands to one argument, with all args joined</span>
<span class="c1">#   by (usually) spaces,</span>
<span class="c1">#   so no args provided will result in one empty string</span>
<span class="c1">#   being passed on.</span>
<span class="c1"># (Consult &#39;man bash&#39; for the nit-grits ;-)</span>

<span class="nb">set</span> -- <span class="m">1</span> <span class="s2">&quot;2 two&quot;</span> <span class="s2">&quot;3 three tres&quot;</span><span class="p">;</span> <span class="nb">echo</span> <span class="nv">$#</span> <span class="p">;</span> <span class="nb">set</span> -- <span class="s2">&quot;</span><span class="nv">$*</span><span class="s2">&quot;</span><span class="p">;</span> <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$#</span><span class="s2">, </span><span class="nv">$@</span><span class="s2">&quot;</span><span class="o">)</span>
<span class="nb">set</span> -- <span class="m">1</span> <span class="s2">&quot;2 two&quot;</span> <span class="s2">&quot;3 three tres&quot;</span><span class="p">;</span> <span class="nb">echo</span> <span class="nv">$#</span> <span class="p">;</span> <span class="nb">set</span> -- <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span><span class="p">;</span> <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$#</span><span class="s2">, </span><span class="nv">$@</span><span class="s2">&quot;</span><span class="o">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-google-shell-styleguide/features_and_bugs"></span><div class="section" id="id1">
<h3>特性及错误</h3>
<div class="section" id="id2">
<h4>命令替换</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 <code class="docutils literal"><span class="pre">$(command)</span></code> 而不是反引号。</p>
</div>
<p>嵌套的反引号要求用反斜杠转义内部的反引号。而 <code class="docutils literal"><span class="pre">$(command)</span></code> 形式嵌套时不需要改变，而且更易于阅读。</p>
<p>例如：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># This is preferred:</span>
<span class="nv">var</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span><span class="nb">command</span> <span class="s2">&quot;</span><span class="k">$(</span>command1<span class="k">)</span><span class="s2">&quot;</span><span class="k">)</span><span class="s2">&quot;</span>

<span class="c1"># This is not:</span>
<span class="nv">var</span><span class="o">=</span><span class="s2">&quot;`command \`command1\``&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="test">
<h4>test，[和[[</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">推荐使用 <code class="docutils literal"><span class="pre">[[</span> <span class="pre">...</span> <span class="pre">]]</span></code> ，而不是 <code class="docutils literal"><span class="pre">[</span></code> , <code class="docutils literal"><span class="pre">test</span></code> , 和 <code class="docutils literal"><span class="pre">/usr/bin/</span> <span class="pre">[</span></code> 。</p>
</div>
<p>因为在 <code class="docutils literal"><span class="pre">[[</span></code> 和 <code class="docutils literal"><span class="pre">]]</span></code> 之间不会有路径名称扩展或单词分割发生，所以使用 <code class="docutils literal"><span class="pre">[[</span> <span class="pre">...</span> <span class="pre">]]</span></code> 能够减少错误。而且 <code class="docutils literal"><span class="pre">[[</span> <span class="pre">...</span> <span class="pre">]]</span></code> 允许正则表达式匹配，而 <code class="docutils literal"><span class="pre">[</span> <span class="pre">...</span> <span class="pre">]</span></code> 不允许。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># This ensures the string on the left is made up of characters in the</span>
<span class="c1"># alnum character class followed by the string name.</span>
<span class="c1"># Note that the RHS should not be quoted here.</span>
<span class="c1"># For the gory details, see</span>
<span class="c1"># E14 at http://tiswww.case.edu/php/chet/bash/FAQ</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;filename&quot;</span> <span class="o">=</span>~ ^<span class="o">[[</span>:alnum:<span class="o">]]</span>+name <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Match&quot;</span>
<span class="k">fi</span>

<span class="c1"># This matches the exact pattern &quot;f*&quot; (Does not match in this case)</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;filename&quot;</span> <span class="o">==</span> <span class="s2">&quot;f*&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Match&quot;</span>
<span class="k">fi</span>

<span class="c1"># This gives a &quot;too many arguments&quot; error as f* is expanded to the</span>
<span class="c1"># contents of the current directory</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;filename&quot;</span> <span class="o">==</span> f* <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Match&quot;</span>
<span class="k">fi</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>测试字符串</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">尽可能使用引用，而不是过滤字符串。</p>
</div>
<p>Bash足以在测试中处理空字符串。所以，请使用空（非空）字符串测试，而不是过滤字符，使得代码更易于阅读。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># Do this:</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">my_var</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;some_string&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  do_something
<span class="k">fi</span>

<span class="c1"># -z (string length is zero) and -n (string length is not zero) are</span>
<span class="c1"># preferred over testing for an empty string</span>
<span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;</span><span class="si">${</span><span class="nv">my_var</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  do_something
<span class="k">fi</span>

<span class="c1"># This is OK (ensure quotes on the empty side), but not preferred:</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">my_var</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  do_something
<span class="k">fi</span>

<span class="c1"># Not this:</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">my_var</span><span class="si">}</span><span class="s2">X&quot;</span> <span class="o">=</span> <span class="s2">&quot;some_stringX&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  do_something
<span class="k">fi</span>
</pre></div>
</div>
<p>为了避免对你测试的目的产生困惑，请明确使用`-z`或者`-n`</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># Use this</span>
<span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;</span><span class="si">${</span><span class="nv">my_var</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  do_something
<span class="k">fi</span>

<span class="c1"># Instead of this as errors can occur if ${my_var} expands to a test</span>
<span class="c1"># flag</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">my_var</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  do_something
<span class="k">fi</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>文件名的通配符扩展</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">当进行文件名的通配符扩展时，请使用明确的路径。</p>
</div>
<p>因为文件名可能以 <code class="docutils literal"><span class="pre">-</span></code> 开头，所以使用扩展通配符 <code class="docutils literal"><span class="pre">./*</span></code> 比 <code class="docutils literal"><span class="pre">*</span></code> 来得安全得多。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># Here&#39;s the contents of the directory:</span>
<span class="c1"># -f  -r  somedir  somefile</span>

<span class="c1"># This deletes almost everything in the directory by force</span>
psa@bilby$ rm -v *
removed directory: <span class="sb">`</span>somedir<span class="s1">&#39;</span>
<span class="s1">removed `somefile&#39;</span>

<span class="c1"># As opposed to:</span>
psa@bilby$ rm -v ./*
removed <span class="sb">`</span>./-f<span class="s1">&#39;</span>
<span class="s1">removed `./-r&#39;</span>
rm: cannot remove <span class="sb">`</span>./somedir<span class="s1">&#39;: Is a directory</span>
<span class="s1">removed `./somefile&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="eval">
<h4>Eval</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">应该避免使用eval。</p>
</div>
<p>当用于给变量赋值时，Eval解析输入，并且能够设置变量，但无法检查这些变量是什么。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># What does this set?</span>
<span class="c1"># Did it succeed? In part or whole?</span>
<span class="nb">eval</span> <span class="k">$(</span>set_my_variables<span class="k">)</span>

<span class="c1"># What happens if one of the returned values has a space in it?</span>
<span class="nv">variable</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span><span class="nb">eval</span> some_function<span class="k">)</span><span class="s2">&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="while">
<h4>管道导向while循环</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">请使用过程替换或者for循环，而不是管道导向while循环。在while循环中被修改的变量是不能传递给父shell的，因为循环命令是在一个子shell中运行的。</p>
</div>
<p>管道导向while循环中的隐式子shell使得追踪bug变得很困难。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="nv">last_line</span><span class="o">=</span><span class="s1">&#39;NULL&#39;</span>
your_command <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> line<span class="p">;</span> <span class="k">do</span>
  <span class="nv">last_line</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">line</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">done</span>

<span class="c1"># This will output &#39;NULL&#39;</span>
<span class="nb">echo</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">last_line</span><span class="si">}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>如果你确定输入中不包含空格或者特殊符号（通常意味着不是用户输入的），那么可以使用一个for循环。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="nv">total</span><span class="o">=</span><span class="m">0</span>
<span class="c1"># Only do this if there are no spaces in return values.</span>
<span class="k">for</span> value in <span class="k">$(</span><span class="nb">command</span><span class="k">)</span><span class="p">;</span> <span class="k">do</span>
  <span class="nv">total</span><span class="o">+=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">value</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">done</span>
</pre></div>
</div>
<p>使用过程替换允许重定向输出，但是请将命令放入一个显式的子shell中，而不是bash为while循环创建的隐式子shell。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="nv">total</span><span class="o">=</span><span class="m">0</span>
<span class="nv">last_file</span><span class="o">=</span>
<span class="k">while</span> <span class="nb">read</span> count filename<span class="p">;</span> <span class="k">do</span>
  <span class="nv">total</span><span class="o">+=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">count</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="nv">last_file</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">filename</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">done</span> &lt; &lt;<span class="o">(</span>your_command <span class="p">|</span> uniq -c<span class="o">)</span>

<span class="c1"># This will output the second field of the last line of output from</span>
<span class="c1"># the command.</span>
<span class="nb">echo</span> <span class="s2">&quot;Total = </span><span class="si">${</span><span class="nv">total</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;Last one = </span><span class="si">${</span><span class="nv">last_file</span><span class="si">}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>当不需要传递复杂的结果给父shell时可以使用while循环。这通常需要一些更复杂的“解析”。请注意简单的例子使用如awk这类工具可能更容易完成。当你特别不希望改变父shell的范围变量时这可能也是有用的。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># Trivial implementation of awk expression:</span>
<span class="c1">#   awk &#39;$3 == &quot;nfs&quot; { print $2 &quot; maps to &quot; $1 }&#39; /proc/mounts</span>
cat /proc/mounts <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> src dest <span class="nb">type</span> opts rest<span class="p">;</span> <span class="k">do</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="si">${</span><span class="nv">type</span><span class="si">}</span> <span class="o">==</span> <span class="s2">&quot;nfs&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;NFS </span><span class="si">${</span><span class="nv">dest</span><span class="si">}</span><span class="s2"> maps to </span><span class="si">${</span><span class="nv">src</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="k">fi</span>
<span class="k">done</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-shell-styleguide/naming_conventions"></span><div class="section" id="id1">
<h3>命名约定</h3>
<div class="section" id="id2">
<h4>函数名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用小写字母，并用下划线分隔单词。使用双冒号 <code class="docutils literal"><span class="pre">::</span></code> 分隔库。函数名之后必须有圆括号。关键词 <code class="docutils literal"><span class="pre">function</span></code> 是可选的，但必须在一个项目中保持一致。</p>
</div>
<p>如果你正在写单个函数，请用小写字母来命名，并用下划线分隔单词。如果你正在写一个包，使用双冒号 <code class="docutils literal"><span class="pre">::</span></code> 来分隔包名。大括号必须和函数名位于同一行（就像在Google的其他语言一样），并且函数名和圆括号之间没有空格。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># Single function</span>
my_func<span class="o">()</span> <span class="o">{</span>
  ...
<span class="o">}</span>

<span class="c1"># Part of a package</span>
mypackage::my_func<span class="o">()</span> <span class="o">{</span>
  ...
<span class="o">}</span>
</pre></div>
</div>
<p>当函数名后存在 <code class="docutils literal"><span class="pre">()</span></code> 时，关键词 <code class="docutils literal"><span class="pre">function</span></code> 是多余的。但是其促进了函数的快速辨识。</p>
</div>
<div class="section" id="id3">
<h4>变量名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如函数名。</p>
</div>
<p>循环的变量名应该和循环的任何变量同样命名。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="k">for</span> zone in <span class="si">${</span><span class="nv">zones</span><span class="si">}</span><span class="p">;</span> <span class="k">do</span>
  something_with <span class="s2">&quot;</span><span class="si">${</span><span class="nv">zone</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">done</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4>常量和环境变量名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">全部大写，用下划线分隔，声明在文件的顶部。</p>
</div>
<p>常量和任何导出到环境中的都应该大写。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># Constant</span>
<span class="nb">readonly</span> <span class="nv">PATH_TO_FILES</span><span class="o">=</span><span class="s1">&#39;/some/path&#39;</span>

<span class="c1"># Both constant and environment</span>
<span class="nb">declare</span> -xr <span class="nv">ORACLE_SID</span><span class="o">=</span><span class="s1">&#39;PROD&#39;</span>
</pre></div>
</div>
<p>第一次设置时有一些就变成了常量（例如，通过getopts）。因此，可以在getopts中或基于条件来设定常量，但之后应该立即设置其为只读。值得注意的是，在函数中 <code class="docutils literal"><span class="pre">declare</span></code> 不会对全局变量进行操作。所以推荐使用 <code class="docutils literal"><span class="pre">readonly</span></code> 和 <code class="docutils literal"><span class="pre">export</span></code> 来代替。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="nv">VERBOSE</span><span class="o">=</span><span class="s1">&#39;false&#39;</span>
<span class="k">while</span> <span class="nb">getopts</span> <span class="s1">&#39;v&#39;</span> flag<span class="p">;</span> <span class="k">do</span>
  <span class="k">case</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">flag</span><span class="si">}</span><span class="s2">&quot;</span> in
    v<span class="o">)</span> <span class="nv">VERBOSE</span><span class="o">=</span><span class="s1">&#39;true&#39;</span> <span class="p">;;</span>
  <span class="k">esac</span>
<span class="k">done</span>
<span class="nb">readonly</span> VERBOSE
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>源文件名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">小写，如果需要的话使用下划线分隔单词。</p>
</div>
<p>这是为了和在Google中的其他代码风格保持一致： <code class="docutils literal"><span class="pre">maketemplate</span></code> 或者 <code class="docutils literal"><span class="pre">make_template</span></code> ，而不是 <code class="docutils literal"><span class="pre">make-template</span></code> 。</p>
</div>
<div class="section" id="id6">
<h4>只读变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 <code class="docutils literal"><span class="pre">readonly</span></code> 或者 <code class="docutils literal"><span class="pre">declare</span> <span class="pre">-r</span></code> 来确保变量只读。</p>
</div>
<p>因为全局变量在shell中广泛使用，所以在使用它们的过程中捕获错误是很重要的。当你声明了一个变量，希望其只读，那么请明确指出。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="nv">zip_version</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>dpkg --status zip <span class="p">|</span> grep Version: <span class="p">|</span> cut -d <span class="s1">&#39; &#39;</span> -f <span class="m">2</span><span class="k">)</span><span class="s2">&quot;</span>
<span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;</span><span class="si">${</span><span class="nv">zip_version</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  error_message
<span class="k">else</span>
  <span class="nb">readonly</span> zip_version
<span class="k">fi</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h4>使用本地变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 <code class="docutils literal"><span class="pre">local</span></code> 声明特定功能的变量。声明和赋值应该在不同行。</p>
</div>
<p>使用 <code class="docutils literal"><span class="pre">local</span></code> 来声明局部变量以确保其只在函数内部和子函数中可见。这避免了污染全局命名空间和不经意间设置可能具有函数之外重要性的变量。</p>
<p>当赋值的值由命令替换提供时，声明和赋值必须分开。因为内建的 <code class="docutils literal"><span class="pre">local</span></code> 不会从命令替换中传递退出码。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>my_func2<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local</span> <span class="nv">name</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span>

  <span class="c1"># Separate lines for declaration and assignment:</span>
  <span class="nb">local</span> my_var
  <span class="nv">my_var</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>my_func<span class="k">)</span><span class="s2">&quot;</span> <span class="o">||</span> <span class="k">return</span>

  <span class="c1"># DO NOT do this: $? contains the exit code of &#39;local&#39;, not my_func</span>
  <span class="nb">local</span> <span class="nv">my_var</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>my_func<span class="k">)</span><span class="s2">&quot;</span>
  <span class="o">[[</span> <span class="nv">$?</span> -eq <span class="m">0</span> <span class="o">]]</span> <span class="o">||</span> <span class="k">return</span>

  ...
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h4>函数位置</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">将文件中所有的函数一起放在常量下面。不要在函数之间隐藏可执行代码。</p>
</div>
<p>如果你有函数，请将他们一起放在文件头部。只有includes， <code class="docutils literal"><span class="pre">set</span></code> 声明和常量设置可能在函数声明之前完成。不要在函数之间隐藏可执行代码。如果那样做，会使得代码在调试时难以跟踪并出现意想不到的讨厌结果。</p>
</div>
<div class="section" id="main">
<h4>主函数main</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">对于包含至少一个其他函数的足够长的脚本，需要称为 <code class="docutils literal"><span class="pre">main</span></code> 的函数。</p>
</div>
<p>为了方便查找程序的开始，将主程序放入一个称为 <code class="docutils literal"><span class="pre">main</span></code> 的函数，作为最下面的函数。这使其和代码库的其余部分保持一致性，同时允许你定义更多变量为局部变量（如果主代码不是一个函数就不能这么做）。文件中最后的非注释行应该是对 <code class="docutils literal"><span class="pre">main</span></code> 函数的调用。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>main <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>显然，对于仅仅是线性流的短脚本， <code class="docutils literal"><span class="pre">main</span></code> 是矫枉过正，因此是不需要的。</p>
</div>
</div>
<span id="document-google-shell-styleguide/calling_commands"></span><div class="section" id="id1">
<h3>调用命令</h3>
<div class="section" id="id2">
<h4>检查返回值</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">总是检查返回值，并给出信息返回值。</p>
</div>
<p>对于非管道命令，使用 <code class="docutils literal"><span class="pre">$?</span></code> 或直接通过一个 <code class="docutils literal"><span class="pre">if</span></code> 语句来检查以保持其简洁。</p>
<p>例如：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="k">if</span> ! mv <span class="s2">&quot;</span><span class="si">${</span><span class="nv">file_list</span><span class="si">}</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">dest_dir</span><span class="si">}</span><span class="s2">/&quot;</span> <span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Unable to move </span><span class="si">${</span><span class="nv">file_list</span><span class="si">}</span><span class="s2"> to </span><span class="si">${</span><span class="nv">dest_dir</span><span class="si">}</span><span class="s2">&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="nb">exit</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">E_BAD_MOVE</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">fi</span>

<span class="c1"># Or</span>
mv <span class="s2">&quot;</span><span class="si">${</span><span class="nv">file_list</span><span class="si">}</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">dest_dir</span><span class="si">}</span><span class="s2">/&quot;</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$?</span><span class="s2">&quot;</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Unable to move </span><span class="si">${</span><span class="nv">file_list</span><span class="si">}</span><span class="s2"> to </span><span class="si">${</span><span class="nv">dest_dir</span><span class="si">}</span><span class="s2">&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="nb">exit</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">E_BAD_MOVE</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">fi</span>
</pre></div>
</div>
<p>Bash也有 <code class="docutils literal"><span class="pre">PIPESTATUS</span></code> 变量，允许检查从管道所有部分返回的代码。如果仅仅需要检查整个管道是成功还是失败，以下的方法是可以接受的：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tar -cf - ./* <span class="p">|</span> <span class="o">(</span> <span class="nb">cd</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">&amp;&amp;</span> tar -xf - <span class="o">)</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">PIPESTATUS</span><span class="p">[0]</span><span class="si">}</span><span class="s2">&quot;</span> -ne <span class="m">0</span> <span class="o">||</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">PIPESTATUS</span><span class="p">[1]</span><span class="si">}</span><span class="s2">&quot;</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Unable to tar files to </span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
<span class="k">fi</span>
</pre></div>
</div>
<p>可是，只要你运行任何其他命令， <code class="docutils literal"><span class="pre">PIPESTATUS</span></code> 将会被覆盖。如果你需要基于管道中发生的错误执行不同的操作，那么你需要在运行命令后立即将 <code class="docutils literal"><span class="pre">PIPESTATUS</span></code> 赋值给另一个变量（别忘了 <code class="docutils literal"><span class="pre">[</span></code> 是一个会将 <code class="docutils literal"><span class="pre">PIPESTATUS</span></code> 擦除的命令）。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tar -cf - ./* <span class="p">|</span> <span class="o">(</span> <span class="nb">cd</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">DIR</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">&amp;&amp;</span> tar -xf - <span class="o">)</span>
<span class="nv">return_codes</span><span class="o">=(</span><span class="si">${</span><span class="nv">PIPESTATUS</span><span class="p">[*]</span><span class="si">}</span><span class="o">)</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">return_codes</span><span class="p">[0]</span><span class="si">}</span><span class="s2">&quot;</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  do_something
<span class="k">fi</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">return_codes</span><span class="p">[1]</span><span class="si">}</span><span class="s2">&quot;</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  do_something_else
<span class="k">fi</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h4>内建命令和外部命令</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">可以在调用shell内建命令和调用另外的程序之间选择，请选择内建命令。</p>
</div>
<p>我们更喜欢使用内建命令，如在 <code class="docutils literal"><span class="pre">bash(1)</span></code> 中参数扩展函数。因为它更强健和便携（尤其是跟像 <code class="docutils literal"><span class="pre">sed</span></code> 这样的命令比较）</p>
<p>例如：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># Prefer this:</span>
<span class="nv">addition</span><span class="o">=</span><span class="k">$((</span><span class="si">${</span><span class="nv">X</span><span class="si">}</span> <span class="o">+</span> <span class="si">${</span><span class="nv">Y</span><span class="si">}</span><span class="k">))</span>
<span class="nv">substitution</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">string</span><span class="p">/#foo/bar</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># Instead of this:</span>
<span class="nv">addition</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>expr <span class="si">${</span><span class="nv">X</span><span class="si">}</span> + <span class="si">${</span><span class="nv">Y</span><span class="si">}</span><span class="k">)</span><span class="s2">&quot;</span>
<span class="nv">substitution</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">string</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">|</span> sed -e <span class="s1">&#39;s/^foo/bar/&#39;</span><span class="k">)</span><span class="s2">&quot;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-shell-styleguide/conclusion"></span><div class="section" id="id1">
<h3>结论</h3>
<p>使用常识并保持一致。</p>
<p>请花几分钟阅读在C++风格指南底部的赠别部分。</p>
</div>
</div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright .
      
        <span class="commit">
          Revision <code>ab5d02b2</code>.
        </span>
      

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="/en/latest/">latest</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="//readthedocs.org/projects/zh-google-styleguide/downloads/pdf/latest/">pdf</a></dd>
        
          <dd><a href="//readthedocs.org/projects/zh-google-styleguide/downloads/htmlzip/latest/">htmlzip</a></dd>
        
          <dd><a href="//readthedocs.org/projects/zh-google-styleguide/downloads/epub/latest/">epub</a></dd>
        
      </dl>
      <dl>
        <dt>On Read the Docs</dt>
          <dd>
            <a href="//readthedocs.org/projects/zh-google-styleguide/?fromdocs=zh-google-styleguide">Project Home</a>
          </dd>
          <dd>
            <a href="//readthedocs.org/builds/zh-google-styleguide/?fromdocs=zh-google-styleguide">Builds</a>
          </dd>
      </dl>
      <hr/>
      Free document hosting provided by <a href="http://www.readthedocs.org">Read the Docs</a>.

    </div>
  </div>



  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>